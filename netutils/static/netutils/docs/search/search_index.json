{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Netutils","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>A Python library that is a collection of functions that are used in the common network automation tasks. Tasks such as converting a BGP ASN to and from dotted format, normalizing an interface name, or \"type 5\" encrypting a password. The intention is to centralize these functions while keeping the library light.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>Full web-based HTML documentation for this library can be found over on the Netutils Docs website:</p> <ul> <li>User Guide - Overview, Using the library, Getting Started.</li> <li>Administrator Guide - How to Install, Configure, Upgrade, or Uninstall the library.</li> <li>Developer Guide - Extending the library, Code Reference, Contribution Guide.</li> <li>Release Notes / Changelog.</li> <li>Frequently Asked Questions.</li> </ul>"},{"location":"index.html#contributing-to-the-docs","title":"Contributing to the Docs","text":"<p>All the Markdown source for the library documentation can be found under the docs folder in this repository. For simple edits, a Markdown capable editor is sufficient - clone the repository and edit away.</p> <p>If you need to view the fully generated documentation site, you can build it with mkdocs. A container hosting the docs will be started using the invoke commands (details in the Development Environment Guide) on http://localhost:8001. As your changes are saved, the live docs will be automatically reloaded.</p> <p>Any PRs with fixes or improvements are very welcome!</p>"},{"location":"index.html#questions","title":"Questions","text":"<p>For any questions or comments, please check the FAQ first. Feel free to also swing by the Network to Code Slack (channel <code>#networktocode</code>), sign up here if you don't have an account.</p>"},{"location":"admin/install.html","title":"Installation","text":"<p>Option 1: Install from PyPI.</p> <pre><code>$ pip install netutils\n</code></pre> <p>Option 2: Install from PyPI with optional requirements.</p> <pre><code>$ pip install netutils[napalm]\npip install netutils\n</code></pre> <p>Option 3: Manually install via Poetry.</p> <pre><code>git clone https://github.com/networktocode/netutils.git\ncd netutils\ncurl -sSL https://install.python-poetry.org | python3 -\npoetry install\n</code></pre> <p>Option 4: Install from a GitHub branch, such as develop as shown below.</p> <pre><code>$ pip install git+https://github.com/networktocode/netutils.git@develop\n</code></pre>"},{"location":"admin/install.html#optional-dependencies","title":"Optional Dependencies","text":"<p>One of the requirements of this library is to avoid having dependencies; however, including a few optional dependencies in an opt in fashion allows <code>netutils</code> to remain lean while offering some powerful addons.</p> <p>Installing the optional dependencies is only needed when the user needs access to the functions using the dependencies. As an example <code>get_napalm_getters()</code> which will provide a mapping of available NAPALM getters based on currently installed NAPALM libraries, if NAPALM is not installed the function simply raises an exception and warns the user that the library is not installed.</p>"},{"location":"admin/uninstall.html","title":"Uninstall","text":"<p>Uninstall from environment.</p> <pre><code>pip uninstall netutils\n</code></pre>"},{"location":"admin/upgrade.html","title":"Upgrading the Library","text":"<p>Upgrade from PyPI.</p> <pre><code>pip install netutils --upgrade\n</code></pre>"},{"location":"admin/release_notes/index.html","title":"Release Notes","text":"<p>All the published release notes can be found via the navigation menu. All patch releases are included in the same minor release (e.g. <code>v1.2</code>) document.</p>"},{"location":"admin/release_notes/version_0.1.html","title":"v0.1 Release Notes","text":""},{"location":"admin/release_notes/version_0.1.html#release-overview","title":"Release Overview","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"admin/release_notes/version_0.1.html#v011-2021-05","title":"[v0.1.1] - 2021-05","text":""},{"location":"admin/release_notes/version_0.1.html#added","title":"Added","text":"<ul> <li>Update travis configuration to release a new version from CI/CD pipeline.</li> </ul>"},{"location":"admin/release_notes/version_0.1.html#v010-2021-03-19","title":"[v0.1.0] - 2021-03-19","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"admin/release_notes/version_0.2.html","title":"v0.2 Release Notes","text":""},{"location":"admin/release_notes/version_0.2.html#release-overview","title":"Release Overview","text":"<ul> <li>Update docs, docstrings, and docstring tests</li> <li>Changed name of is_fqdn_valid to is_fqdn_resolvable, prepare to deprecate is_fqdn_valid</li> <li>Removed automatic import of all functions on initiation of package</li> <li>Moved interface mappings from variables to constants</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#v025-2021-11","title":"[v0.2.5] - 2021-11","text":""},{"location":"admin/release_notes/version_0.2.html#added","title":"Added","text":"<ul> <li>#76 Added wrapper for Python ipaddress methods for use with Jinja</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#fixed","title":"Fixed","text":"<ul> <li>#75 Updated Python requirements to be loosened</li> <li>#76 Fixed doc errors with ip methods</li> <li>#77 Fixed CI pipeline for docker caching</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#v024-2021-11","title":"[v0.2.4] - 2021-11","text":""},{"location":"admin/release_notes/version_0.2.html#added_1","title":"Added","text":"<ul> <li>#33 Add interface range compress function</li> <li>#53 Add get peer address function</li> <li>#59 Add bandwidth converting function</li> <li>#65 Added Docker caching</li> <li>#68 Add Fortinet Fortios Parser support</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#changed","title":"Changed","text":"<ul> <li>#64 CI implementation on GitHub actions</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#fixed_1","title":"Fixed","text":"<ul> <li>#52 Update pyproject.toml build-server </li> <li>#55 update version in toml and init files</li> <li>#63 Fix lack of zero padding on ip to binary conversion</li> <li>#70 Fix lack of zero padding on ip to hex conversion</li> <li>#68 Update Black pinning</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#v023-2021-09","title":"[v0.2.3] - 2021-09","text":""},{"location":"admin/release_notes/version_0.2.html#added_2","title":"Added","text":"<ul> <li>#45 Added a jinja2 convenience function</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#changed_1","title":"Changed","text":"<ul> <li>#46 Updated NAPALM Maps to include community drivers</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#fixed_2","title":"Fixed","text":"<ul> <li>#49 Fix read the docs</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#v022-2021-09","title":"[v0.2.2] - 2021-09","text":""},{"location":"admin/release_notes/version_0.2.html#added_3","title":"Added","text":"<ul> <li>#35 TCP/UDP Mappings</li> <li>#31 Interface range expansion</li> <li>#28 IPv6 Functionality to IP Module</li> <li>#34 Interface sorting</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#changed_2","title":"Changed","text":"<ul> <li>#39 Updated docs to include automation library mappings</li> <li>#41 Updated docs to include tcp/udp mappings</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#fixed_3","title":"Fixed","text":"<ul> <li>Corrected contribution and attribution docs</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#v021-2021-06","title":"[v0.2.1] - 2021-06","text":""},{"location":"admin/release_notes/version_0.2.html#added_4","title":"Added","text":"<ul> <li>#16 Cisco ASA Parser.</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#changed_3","title":"Changed","text":"<ul> <li>#17 Update interface mapping for Sync, TenGig, Port-channel.</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#v020-2021-06","title":"[v0.2.0] - 2021-06","text":""},{"location":"admin/release_notes/version_0.2.html#fixed_4","title":"Fixed","text":"<ul> <li>Enable docstring tests</li> <li>Fix docstring tests</li> <li>Fix wording and links on README</li> </ul>"},{"location":"admin/release_notes/version_0.2.html#changed_4","title":"Changed","text":"<ul> <li>Changed name of is_fqdn_valid to is_fqdn_resolvable, prepare to deprecate is_fqdn_valid</li> <li>Removed automatic import of all functions on initiation of package</li> <li>Moved interface mappings from variables to constants</li> </ul>"},{"location":"admin/release_notes/version_1.0.html","title":"v1.0 Release Notes","text":""},{"location":"admin/release_notes/version_1.0.html#release-overview","title":"Release Overview","text":"<ul> <li>Commit to SemVer</li> <li>F5 fixes</li> </ul>"},{"location":"admin/release_notes/version_1.0.html#v100-2021-11","title":"v1.0.0 - 2021-11","text":""},{"location":"admin/release_notes/version_1.0.html#added","title":"Added","text":"<ul> <li>#69 Normalise banner delimiter for IOS to ^C &amp; support parsing delimiter ^.</li> </ul>"},{"location":"admin/release_notes/version_1.0.html#fixed","title":"Fixed","text":"<ul> <li>#79 F5 parser fix for irules with multiline single command lines.</li> </ul>"},{"location":"admin/release_notes/version_1.0.html#removed","title":"Removed","text":"<ul> <li>#83 Remove support for old function 'is_fqdn_valid' as prep for 1.0.0.</li> </ul>"},{"location":"admin/release_notes/version_1.1.html","title":"v1.1 Release Notes","text":""},{"location":"admin/release_notes/version_1.1.html#release-overview","title":"Release Overview","text":"<ul> <li>Added Nokia SrOS</li> </ul>"},{"location":"admin/release_notes/version_1.1.html#v110-2022-04","title":"[v1.1.0] - 2022-04","text":""},{"location":"admin/release_notes/version_1.1.html#added","title":"Added","text":"<ul> <li>#90 Uptime Conversions.</li> <li>#102 Add Ansible mapping for Nokia SrOS.</li> <li>#105 Add min_grouping_sizing to vlanlist_to_config method.</li> <li>#106 Add Nokia SrOS Config Parser.</li> </ul>"},{"location":"admin/release_notes/version_1.1.html#changed","title":"Changed","text":"<ul> <li>#104 Optimize vlanconfig_to_list using builtin Regex methods.</li> </ul>"},{"location":"admin/release_notes/version_1.1.html#fixed","title":"Fixed","text":"<ul> <li>#99 Fixed decimal place in bits_to_name.</li> <li>#107 Fix issue when backup or intended is empty.</li> </ul>"},{"location":"admin/release_notes/version_1.10.html","title":"v1.10 Release Notes","text":""},{"location":"admin/release_notes/version_1.10.html#release-overview","title":"Release Overview","text":"<ul> <li>Added Functionality to ip_network filter to support method calls with kwargs.</li> <li>Fix configuration parsers to allow newlines, no longer auto strip all newlines.</li> </ul>"},{"location":"admin/release_notes/version_1.10.html#v1100-2024-09","title":"[v1.10.0] 2024-09","text":""},{"location":"admin/release_notes/version_1.10.html#added","title":"Added","text":"<ul> <li>534 Extend ip_network extension to support method calls with kwargs.</li> </ul>"},{"location":"admin/release_notes/version_1.10.html#changed","title":"Changed","text":"<ul> <li>570 OUI File Updates.</li> <li>571 PROTOCOL File Updates.</li> </ul>"},{"location":"admin/release_notes/version_1.10.html#fixed","title":"Fixed","text":"<ul> <li>569 Fix banner parsers auto striping all newlines. Allow newlines in banners.</li> <li>574 Fix ntc_template reverse mapping for cisco xe.</li> </ul>"},{"location":"admin/release_notes/version_1.11.html","title":"v1.11 Release Notes","text":""},{"location":"admin/release_notes/version_1.11.html#release-overview","title":"Release Overview","text":"<ul> <li>Release is the same as v1.10.1</li> </ul>"},{"location":"admin/release_notes/version_1.11.html#v1110-2024-12","title":"[v1.11.0] 2024-12","text":""},{"location":"admin/release_notes/version_1.12.html","title":"v1.12 Release Notes","text":""},{"location":"admin/release_notes/version_1.12.html#release-overview","title":"Release Overview","text":"<ul> <li>Added Python 3.13 support.</li> <li>Removed Python 3.8 support.</li> </ul>"},{"location":"admin/release_notes/version_1.12.html#v1120-2025-01","title":"[v1.12.0] 2025-01","text":""},{"location":"admin/release_notes/version_1.12.html#added","title":"Added","text":"<ul> <li>593 Add nokia_srl to the mappers.</li> </ul>"},{"location":"admin/release_notes/version_1.12.html#changed","title":"Changed","text":"<ul> <li>603 Add support for Python 3.8 and add Python 3.13.</li> </ul>"},{"location":"admin/release_notes/version_1.12.html#fixed","title":"Fixed","text":"<ul> <li>602 Fix ASA banner config parsing.</li> </ul>"},{"location":"admin/release_notes/version_1.13.html","title":"v1.13 Release Notes","text":""},{"location":"admin/release_notes/version_1.13.html#release-overview","title":"Release Overview","text":"<ul> <li>Added is_reversible_wildcardmask, netmask_to_wildcardmask, and wildcardmask_to_netmask functions.</li> <li>Added aruba_os and aruba_osswitch parsers.</li> </ul>"},{"location":"admin/release_notes/version_1.13.html#v1130-2025-03","title":"[v1.13.0] 2025-03","text":""},{"location":"admin/release_notes/version_1.13.html#added","title":"Added","text":"<ul> <li>616 Added is_reversible_wildcardmask, netmask_to_wildcardmask, and wildcardmask_to_netmask functions.</li> <li>620 Add cisco_wlc_ssh mapping to ntctemplates lib mapper.</li> <li>632 Added aruba_os and aruba_osswitch parsers.</li> </ul>"},{"location":"admin/release_notes/version_1.14.html","title":"v1.14 Release Notes","text":""},{"location":"admin/release_notes/version_1.14.html#release-overview","title":"Release Overview","text":"<ul> <li>Library mapping updates and fixes.</li> <li>NIST library updates and fixes for CVE reporting.</li> <li>Documentation fixes.</li> <li>Palo Alto brace configuration fixes.</li> </ul>"},{"location":"admin/release_notes/version_1.14.html#v1140-2025-07","title":"[v1.14.0] 2025-07","text":""},{"location":"admin/release_notes/version_1.14.html#added","title":"Added","text":"<ul> <li>644 Add ability to get the lib mapper in a os centric view versus a lib centric view.</li> <li>646 Add Additional SROS Tests.</li> <li>649 Add RUNNING_CONFIG_MAPPER to help map platform to running configuration command.</li> </ul>"},{"location":"admin/release_notes/version_1.14.html#changed","title":"Changed","text":"<ul> <li>652 Flatbot OUI File Updates.</li> <li>653 Flatbot PROTOCOL File Updates.</li> <li>662 NIST library updates and fixes.</li> </ul>"},{"location":"admin/release_notes/version_1.14.html#fixed","title":"Fixed","text":"<ul> <li>640 Fix documentation issues.</li> <li>641 Fix documentation for Jinja examples.</li> <li>651 Fix Palo set format config parsing for curly brace.</li> </ul>"},{"location":"admin/release_notes/version_1.14.html#v1141-2025-07","title":"[v1.14.1] 2025-07","text":""},{"location":"admin/release_notes/version_1.14.html#changed_1","title":"Changed","text":"<ul> <li>672 Update running configuration commands to be full versions. Flatbot OUI and PROTOCOL file updates.</li> </ul>"},{"location":"admin/release_notes/version_1.15.html","title":"v1.15 Release Notes","text":"<p>This document describes all new features and changes in the release. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"admin/release_notes/version_1.15.html#release-overview","title":"Release Overview","text":"<ul> <li>Add parser support for Rad ETX.</li> <li>Update the library to the NTC 2025 development standards.</li> </ul>"},{"location":"admin/release_notes/version_1.15.html#v1151-2025-10-20","title":"v1.15.1 (2025-10-20)","text":""},{"location":"admin/release_notes/version_1.15.html#added","title":"Added","text":"<ul> <li>#704 - Added show running config mapper for 22 additional operating systems.</li> </ul>"},{"location":"admin/release_notes/version_1.15.html#v1150-2025-09-05","title":"v1.15.0 (2025-09-05)","text":""},{"location":"admin/release_notes/version_1.15.html#added_1","title":"Added","text":"<ul> <li>#692 - Add Rad ETX config parser.</li> </ul>"},{"location":"admin/release_notes/version_1.15.html#housekeeping","title":"Housekeeping","text":"<ul> <li>#675 - Replaced black, bandit, flake8 and pydocstyle with ruff.</li> <li>#675 - Updated tasks.py with newest task list.</li> <li>#675 - Updated to using pyinvoke for development environment definition.</li> <li>Fix CI for Flatbot to install Ruff and remove black.</li> </ul>"},{"location":"admin/release_notes/version_1.2.html","title":"v1.2 Release Notes","text":""},{"location":"admin/release_notes/version_1.2.html#release-overview","title":"Release Overview","text":"<ul> <li>Added type hints and mypy testing</li> <li>Encrypt type7 updated</li> </ul>"},{"location":"admin/release_notes/version_1.2.html#v120-2022-08","title":"[v1.2.0] - 2022-08","text":""},{"location":"admin/release_notes/version_1.2.html#added","title":"Added","text":"<ul> <li>#128 Documentation for Nokia SROS duplicate lines/duplicate line detection</li> <li>#138 Added nxos_ssh to Napalm mapper</li> </ul>"},{"location":"admin/release_notes/version_1.2.html#changed","title":"Changed","text":"<ul> <li>#113 Updated lib mapping docs</li> <li>#115 Switched build backend to poetry-core</li> <li>#121 Update banner parsing for EOS</li> <li>#129 Add type hints to the whole project and mypy testing setup and CI</li> <li>#134 Updated CODEOWNERS</li> </ul>"},{"location":"admin/release_notes/version_1.2.html#fixed","title":"Fixed","text":"<ul> <li>#122 Fixed encrypt type7</li> </ul>"},{"location":"admin/release_notes/version_1.3.html","title":"v1.3 Release Notes","text":""},{"location":"admin/release_notes/version_1.3.html#release-overview","title":"Release Overview","text":"<ul> <li>Added IOS Config parsing for get_path and get_path_with_children methods.</li> <li>Added OUI mappings and built a <code>flat ci</code> process to manage freshness of data.</li> <li>Added first getter feature with Napalm Getter feature.</li> <li>Converted to mkdocs docs.</li> <li>Added Citrix NetScaler Parser.</li> <li>Removed support for Python 3.6.</li> </ul>"},{"location":"admin/release_notes/version_1.3.html#v130-2022-11","title":"[v1.3.0] - 2022-11","text":""},{"location":"admin/release_notes/version_1.3.html#added","title":"Added","text":"<ul> <li>#146 Added IOS Config parsing for get_path and get_path_with_children methods.</li> <li>#148 Added OUI mappings and built a <code>flat ci</code> process to manage freshness of data.</li> <li>#149 Added first getter feature with Napalm Getter feature.</li> <li>#153 Added Citrix NetScaler Parser.</li> </ul>"},{"location":"admin/release_notes/version_1.3.html#changed","title":"Changed","text":"<ul> <li>#152 Converted to mkdocs docs.</li> <li>#154 Update testing mock strategy for config parsers.</li> <li>#155 Update links to render properly on rtd and pypi.</li> <li>#159 Change how dunder version is created.</li> </ul>"},{"location":"admin/release_notes/version_1.3.html#removed","title":"Removed","text":"<ul> <li>#152 Removed support for Python 3.6.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html","title":"v1.4 Release Notes","text":""},{"location":"admin/release_notes/version_1.4.html#release-overview","title":"Release Overview","text":"<ul> <li>Added is_classful utility function.</li> <li>Added AOS-CX, IOS-XR, MRV_OPTISWITCH, and EXTREME_NETIRON parsers.</li> <li>Update flatbot CI process.</li> <li>Fix and cleanup tests and parser information.</li> <li>Fix tcp_ping behavior.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html#v141-2023-02","title":"[v1.4.1] - 2023-02","text":""},{"location":"admin/release_notes/version_1.4.html#changed","title":"Changed","text":"<ul> <li>#171 Allow protocol mapper to be auto-generated.</li> <li>#197 Prepend OUI Flatbot step to delete existing branch.</li> <li>#200 Allow bandwith to be represented without \"ps\" in bandwidth.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html#fixed","title":"Fixed","text":"<ul> <li>#206 Fix Passwords docs that show ASN details.</li> <li>#209 Fixed interface_range_expansion with trailing constant.</li> <li>#210 Install black into flat environment, change flat action name.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html#v140-2023-01","title":"[v1.4.0] - 2023-01","text":""},{"location":"admin/release_notes/version_1.4.html#added","title":"Added","text":"<ul> <li>#163 Added IP <code>is_classfull</code> utility function.</li> <li>#172 Added Aruba AOS-CX Parser.</li> <li>#177 Added IOS-XR Parser.</li> <li>#182 Added Mrv Optiswitch Parser.</li> <li>#182 Added Extreme Netiron Parser.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html#changed_1","title":"Changed","text":"<ul> <li>#178 Update OUI flatbot CI process.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html#fixed_1","title":"Fixed","text":"<ul> <li>#173 Fixes classfull address naming.</li> <li>#183 Updates parser folder info, fix aruba tests.</li> <li>#181 Fixes incorrect behavior when calling tcp_ping with timeout &gt;= 3.</li> </ul>"},{"location":"admin/release_notes/version_1.4.html#removed","title":"Removed","text":"<ul> <li>#184 Removed redundant <code>__init__</code> methods on Parser classes.</li> </ul>"},{"location":"admin/release_notes/version_1.5.html","title":"v1.5 Release Notes","text":""},{"location":"admin/release_notes/version_1.5.html#release-overview","title":"Release Overview","text":"<ul> <li>Added Mikrotik, fastiron, and Panos parsers.</li> <li>Added function to allow conversion from Panos curly bracket to set format.</li> <li>Updated Interface mappings for FourHundredGigabitEthernet and TwoGigabitEthernet.</li> <li>Added Encryption/Decryption/Comparison for Cisco &amp; Juniper Type 9.</li> <li>Added Regex functions to primarily be used wihin your Jinja2 environment.</li> </ul>"},{"location":"admin/release_notes/version_1.5.html#announcements","title":"Announcements","text":"<ul> <li>Deprecation of compare_type5, compare_type7, encrypt_type7, encrypt_type5, and decrypt_type7 in favor of vendor namespaced functions, such as compare_cisco_type5 and decrypt_cisco_type7 to take place on netutils 2.0.</li> <li>Support for Python 3.7 is dropped.</li> </ul>"},{"location":"admin/release_notes/version_1.5.html#v150-2023-07","title":"[v1.5.0] - 2023-07","text":""},{"location":"admin/release_notes/version_1.5.html#added","title":"Added","text":"<ul> <li>#223 Interface abbreviation for TwoGigabitEthernet.</li> <li>#227 Add functions for encrypting and decrypting junipter $9$ type passwords.</li> <li>#244 Added Mikrotik RouterOS Parser.</li> <li>#252 New lib mapper to translate between normalized network OS names and names used by hier_config.</li> <li>#253 Add encrypt_type9 (changed to encrypt_cisco_type9) function to netutils.password.</li> <li>#261 Added function get_upgrade_path to provide the step upgrade path of to a new version.</li> <li>#262 Added Palo Alto networks panos parser. </li> <li>#262 Added Palo Alto brace to set conversion function. </li> <li>#264 Added Ruckus fastiron parser.</li> <li>#285 Added FourHundredGigabitEthernet to REVERSE_MAPPING.</li> <li>#318 Added Regex functions to primarily be used wihin your Jinja2 environment.</li> </ul>"},{"location":"admin/release_notes/version_1.5.html#changed","title":"Changed","text":"<ul> <li>#213 Clarify when Python 3.6 support was dropped.</li> <li>#286 Move password helper names to be namespaced with vendor information. Assign new name to old name to not break semver.</li> <li>#317 Dropped Python 3.6 and bump version of dev dependencies.</li> </ul>"},{"location":"admin/release_notes/version_1.5.html#fixed","title":"Fixed","text":"<ul> <li>#217 Moved where deletion of branch took place in workflow.</li> <li>#218 Create dependabot.yml to fix itdependsabot.</li> <li>#219 Fix vlanlist_to_config failing on empty list.</li> <li>#224 Add Interface type for Cisco App-hosting port.</li> <li>#284 Add -f to flatbot branch pushes.</li> <li>#304 Update hier_config docs and add fastiron to NAPALM mapper.</li> <li>#305 Fixed OS Version docs showing in mkdocs.</li> <li>#316 Update panos conversion function to strip out <code>devices localhost.localdomain</code>.</li> <li>#317 Fix Citrix mock tests file location to correctly run.</li> </ul>"},{"location":"admin/release_notes/version_1.6.html","title":"v1.6 Release Notes","text":""},{"location":"admin/release_notes/version_1.6.html#release-overview","title":"Release Overview","text":"<ul> <li>Added <code>ubiquiti_airos</code> parser.</li> <li>Added <code>ACLRule</code> and <code>ACLRules</code> classes.</li> <li>Added the <code>ip</code> functions <code>is_ip_range</code>, <code>is_ip_within</code>, <code>is_network</code>, and <code>get_range_ips</code>.</li> <li>Added the <code>asn</code> function <code>int_to_asn</code> in the function.</li> <li>Added <code>NETUTILSPARSER_LIB_MAPPER</code> and <code>NETUTILSPARSER_LIB_MAPPER_REVERSE</code> to lib mapper.</li> <li>Added classy docs to view config parser classes.</li> </ul>"},{"location":"admin/release_notes/version_1.6.html#v160-2023-09","title":"[v1.6.0] - 2023-09","text":""},{"location":"admin/release_notes/version_1.6.html#added","title":"Added","text":"<ul> <li>#290 Added <code>ACLRule</code> and <code>ACLRules</code> classes.</li> <li>#290 Added the <code>ip</code> functions <code>is_ip_range</code>, <code>is_ip_within</code>, <code>is_network</code>, and <code>get_range_ips</code>.</li> <li>#325 Added classy docs to view config parser classes.</li> <li>#329 Added <code>ubiquiti_airos</code> parser.</li> <li>#332 Added the <code>asn</code> function <code>int_to_asn</code> in the function.</li> <li>#352 Added <code>NETUTILSPARSER_LIB_MAPPER</code> and <code>NETUTILSPARSER_LIB_MAPPER_REVERSE</code> to lib mapper.</li> </ul>"},{"location":"admin/release_notes/version_1.6.html#changed","title":"Changed","text":"<ul> <li>#346 Updated <code>mac_to_format</code> docs.</li> <li>#352 Clean up docs and sorting for lib mapper.</li> <li>#358 Changed flatbot schedule.</li> </ul>"},{"location":"admin/release_notes/version_1.6.html#fixed","title":"Fixed","text":"<ul> <li>#339 Fix for ASN functions.</li> <li>#340 Fixed Netscaler parser slug.</li> <li>#346 Fix issue where interface abbreviation not working.</li> <li>#350 Update library mappings to be correct order.</li> <li>#356 Fixed mkdocs dependencies.</li> </ul>"},{"location":"admin/release_notes/version_1.7.html","title":"v1.7 Release Notes","text":""},{"location":"admin/release_notes/version_1.7.html#release-overview","title":"Release Overview","text":"<ul> <li>Added the ability to hash a value via <code>hash_data</code> function.</li> <li>Added the ability to sort IPs a value via <code>get_ips_sorted</code> function.</li> <li>Added lib_mapper entries for <code>ruckus_smartzone</code>, <code>cisco_xe</code>,  <code>huawei</code> and <code>cisco_xr</code>.</li> </ul>"},{"location":"admin/release_notes/version_1.7.html#v170-2024-03","title":"[v1.7.0] - 2024-03","text":""},{"location":"admin/release_notes/version_1.7.html#added","title":"Added","text":"<ul> <li>#373 Added the ability to hash a value via <code>hash_data</code> function.</li> <li>#374 Added <code>ruckus_smartzone</code> to lib_mapper.</li> <li>#451 Added <code>forward</code> mappings.</li> <li>#473 Added the ability to sort IPs a value via <code>get_ips_sorted</code> function.</li> </ul>"},{"location":"admin/release_notes/version_1.7.html#changed","title":"Changed","text":"<ul> <li>#369 Update doc string example to include the import statement.</li> <li>#429 Updated <code>cisco_xe</code> mappings.</li> <li>#443 Updated <code>ansible</code> platform mappers.</li> <li>#466 Improve performance of jinja2_convenience_function by not importing NAPALM when called.</li> </ul>"},{"location":"admin/release_notes/version_1.7.html#fixed","title":"Fixed","text":"<ul> <li>#429 Fixed <code>huawei</code> and <code>cisco_xr</code> mapping.</li> <li>#445 Fixed dual banner issue.</li> </ul>"},{"location":"admin/release_notes/version_1.8.html","title":"v1.8 Release Notes","text":""},{"location":"admin/release_notes/version_1.8.html#release-overview","title":"Release Overview","text":"<ul> <li>Added support for Python 3.12.</li> <li>Added local support of <code>distutils.version</code> now that Python 3.12 deprecates disutils.</li> <li>Added functions <code>compare_version_loose</code> and <code>compare_version_strict</code> based on <code>distutils.version</code>.</li> <li>Added function <code>paloalto_panos_clean_newlines</code>.</li> <li>Added various lib_mapper updates.</li> <li>Added HP Comware parser.</li> </ul>"},{"location":"admin/release_notes/version_1.8.html#v180-2024-04","title":"[v1.8.0] 2024-04","text":""},{"location":"admin/release_notes/version_1.8.html#added","title":"Added","text":"<ul> <li>#483 Added support for Python 3.12.</li> <li>#483 Added local support of <code>distutils.version</code> now that Python 3.12 deprecates disutils.</li> <li>#490 Add JunOS and Vyatta to HierConfig mappers.</li> <li>#416 Added <code>paloalto_panos_clean_newlines</code> function.</li> <li>#467 Added HP Comware parser.</li> </ul>"},{"location":"admin/release_notes/version_1.8.html#changed","title":"Changed","text":"<ul> <li>#485 Changed order of changelog menu.</li> <li>#494 Changed protocol number import to be dynamic update via flatbot.</li> <li>#495 Changed XR mapping, add tests to ensure always using normalized name, various lib_mapper fixes.</li> </ul>"},{"location":"admin/release_notes/version_1.8.html#fixed","title":"Fixed","text":"<ul> <li>#496 Fixed vyos lib_mapper.</li> <li>#416 Fixed for <code>\\n</code> characters in parsing bug in palo parser.</li> </ul>"},{"location":"admin/release_notes/version_1.8.html#v181-2024-04","title":"[v1.8.1] 2024-04","text":""},{"location":"admin/release_notes/version_1.8.html#fixed_1","title":"Fixed","text":"<ul> <li>#509 Fixed parsing of empty banner, and dual banner for Cisco platforms.</li> </ul>"},{"location":"admin/release_notes/version_1.9.html","title":"v1.9 Release Notes","text":""},{"location":"admin/release_notes/version_1.9.html#release-overview","title":"Release Overview","text":"<ul> <li>Added NIST URL creation and platform mapper.</li> <li>Added DNA Center platform mappings.</li> <li>Improved error message when duplicate line is parsed.</li> </ul>"},{"location":"admin/release_notes/version_1.9.html#v191-2024-08","title":"[v1.9.1] 2024-08","text":""},{"location":"admin/release_notes/version_1.9.html#changed","title":"Changed","text":"<ul> <li>557 OUI File Updates.</li> <li>558 PROTOCOL File Updates.</li> </ul>"},{"location":"admin/release_notes/version_1.9.html#fixed","title":"Fixed","text":"<ul> <li>553 Fixes incorrect cisco_xe to ntc-templates library mapping.</li> </ul>"},{"location":"admin/release_notes/version_1.9.html#v190-2024-07","title":"[v1.9.0] 2024-07","text":""},{"location":"admin/release_notes/version_1.9.html#added","title":"Added","text":"<ul> <li>489 Added NIST URL creation and platform mapper.</li> <li>519 Added DNA Center forward and reverse platform mappings.</li> </ul>"},{"location":"admin/release_notes/version_1.9.html#changed_1","title":"Changed","text":"<ul> <li>539 Provide more descriptive error message when duplicate line is parsed.</li> </ul>"},{"location":"dev/arch_decision.html","title":"Architecture Decision Records","text":"<p>The intention is to document deviations from a standard pattern.</p>"},{"location":"dev/attribution.html","title":"Attribution","text":"<p>The library was built to be a centralized place for common network automation code to be accessed. While in most cases it is difficult, if not impossible to understand the origin of code, the following intends to describe the known motivation for where code was derived from and in the few cases where actual code was directly taken from. Except where noted, all code is believed to be unattributable, from @itdependsnetworks, or from another Network to Code employee. If this is in fact an error, please open an issue, and the proper attribution will be provided. Any errors were not done out of malice, but rather the natural developer workflow of pulling snippets of code from existing locations such as StackOverflow and Github over months and years of development. As an example it is nearly impossible to understand the original author of Cisco type7 encryption/decryption in the sea of available code, and remains unattributable though clearly originally developed prior to this library being created.</p> <p>Influencers</p> <ul> <li>Netmiko</li> <li>NAPALM</li> <li>Ansible</li> <li>IPCal</li> <li>StackOverflow</li> <li>Python 3 Docs</li> <li>Python distutils version</li> </ul> <p>In many instances variables and function names were reused, but the code was built from scratch to avoid any potential licensing issues. Functions that were known to be rewritten and their known origin.</p> Function Origin asn_to_int NAPALM is_ip IPCal ip_to_bin IPCal get_usable_range IPCal encrypt_cisco_type7 unknown decrypt_cisco_type7 unknown vlan_to_list Ansible sanitize_config NAPALM <p>Relevant PR's</p> <ul> <li>NAPALM #493</li> <li>Ansible #39901</li> <li>Ansible #26566</li> </ul> <p>In building out the time conversion, the regex patterns are based on NAPALM implementation with their consent.</p>"},{"location":"dev/contributing.html","title":"Contributing","text":"<p>Pull requests are welcomed and automatically built and tested against multiple versions of Python through GitHub Actions. </p> <p>Except for unit tests, testing is only supported on Python 3.9.</p> <p>The project is packaged with a light development environment based on <code>Docker</code> to help with the local development of the project and to run tests within GitHub Actions.</p> <p>The project is following Network to Code software development guidelines and is leveraging the following:</p> <ul> <li>Python linting and formatting: <code>pylint</code> and <code>ruff</code>.</li> <li>YAML linting is done with <code>yamllint</code>.</li> <li>Typing is done with <code>mypy</code>.</li> </ul> <p>There are a number of things that are required in order to have a successful PR.</p> <ul> <li>All new functions must contain at least 1 example in their docstrings.</li> <li>Docstrings must conform to the google docstring convention.</li> <li>Unit test for newly added functions are required.</li> <li>If applicable, tests related to config parsing and compliance must be added.</li> <li>Update the jinja2 filter (netutils.utils.jinja2_convenience_function) for any new functions (see below for details).</li> <li>If you create a new file in the <code>netutils</code> folder, you must add a new file for including Python and update <code>mkdocs.yml</code> to include the addition (see below for details).</li> <li>Your PR must not introduce any required dependencies. You can introduce optional or development dependencies.</li> </ul> <p>Documentation is built using mkdocs. The Docker based development environment can be started by running <code>invoke docs</code> http://localhost:8001 that auto-refreshes when you make any changes to your local files.</p>"},{"location":"dev/contributing.html#adding-docs-for-a-new-python-file","title":"Adding docs for a new python file","text":"<p>If adding a new python file, the docs must be updated to account for the new file.</p> <ol> <li>Create a new markdown file in <code>docs/dev/code_reference</code> matching the name of your new file such as <code>dns.md</code>.</li> <li>Apply the following pattern to the newly created file.</li> <li>Update the <code>mydocs.yml</code> to point to the new file</li> </ol> <pre><code># DNS\n\n::: netutils.dns\n    options:\n        show_submodules: True\n</code></pre> <p>Update the mkdocs as appropriate, as shown in this truncated example of adding DNS.</p> <pre><code>nav:\n  - Developer Guide:\n      - Extending the Library: \"dev/extending.md\"\n      - Contributing to the Library: \"dev/contributing.md\"\n      - Development Environment: \"dev/dev_environment.md\"\n      - Development Config: \"dev/dev_config.md\"\n      - Code Attribution to the Library: \"dev/attribution.md\"\n      - Code Reference:\n          - \"dev/code_reference/index.md\"\n          - ASN: \"dev/code_reference/asn.md\"\n          - Bandwidth: \"dev/code_reference/bandwidth.md\"\n          - Banner: \"dev/code_reference/banner.md\"\n          - Configs: \"dev/code_reference/configs.md\"\n          - DNS: \"dev/code_reference/dns.md\" &lt;&lt;-- Added\n</code></pre>"},{"location":"dev/contributing.html#adding-lib-mapper-jinja2-filter-or-config-parser","title":"Adding Lib Mapper, jinja2 filter, or Config Parser","text":"<p>When adding to any of these features, you must run the <code>development_scripts</code> from the root directory. This process requires having Jinja2 on the machine that will run the process. This is automatically tested via pytest.</p>"},{"location":"dev/contributing.html#adding-to-the-jinja2-filter-function","title":"Adding to the jinja2 filter function","text":"<p>To add a new function to the jinja2 filter, add a new entry to the <code>_JINJA2_FUNCTION_MAPPINGS</code> located in the <code>utils.py</code> file. When adding an entry, the key corresponds with the name to call the function and the value to the path to find the function.</p> <p>Documentation is built using mkdocs. The Docker based development environment can be started by running <code>invoke docs</code> http://localhost:8001 that auto-refreshes when you make any changes to your local files.</p>"},{"location":"dev/contributing.html#creating-changelog-fragments","title":"Creating Changelog Fragments","text":"<p>All pull requests to <code>next</code> or <code>develop</code> must include a changelog fragment file in the <code>./changes</code> directory. To create a fragment, use your GitHub issue number and fragment type as the filename. For example, <code>2362.added</code>. Valid fragment types are <code>added</code>, <code>changed</code>, <code>deprecated</code>, <code>fixed</code>, <code>removed</code>, and <code>security</code>. The change summary is added to the file in plain text. Change summaries should be complete sentences, starting with a capital letter and ending with a period, and be in past tense. Each line of the change fragment will generate a single change entry in the release notes. Use multiple lines in the same file if your change needs to generate multiple release notes in the same category. If the change needs to create multiple entries in separate categories, create multiple files.</p> <p>Example</p> <p>Wrong changes/1234.fixed<pre><code>fix critical bug in documentation\n</code></pre></p> <p>Right changes/1234.fixed<pre><code>Fixed critical bug in documentation.\n</code></pre></p> <p>Multiple Entry Example</p> <p>This will generate 2 entries in the <code>fixed</code> category and one entry in the <code>changed</code> category.</p> changes/1234.fixed<pre><code>Fixed critical bug in documentation.\nFixed release notes generation.\n</code></pre> changes/1234.changed<pre><code>Changed release notes generation.\n</code></pre>"},{"location":"dev/contributing.html#branching-policy","title":"Branching Policy","text":"<p>The branching policy includes the following tenets:</p> <ul> <li>The develop branch is the primary branch to develop off of.</li> <li>If there is a reason to have a patch version, the maintainers may use cherry-picking strategy.</li> <li>PRs intended to add new features should be sourced from the develop branch.</li> <li>PRs intended to address bug fixes and security patches should be sourced from the develop branch.</li> <li>PRs intended to add new features that break backward compatibility should be discussed before a PR is created.</li> </ul> <p>Netutils will observe semantic versioning, as of 1.0. This may result in an quick turn around in minor versions to keep pace with an ever growing feature set.</p>"},{"location":"dev/contributing.html#release-policy","title":"Release Policy","text":"<p>Netutils has currently no intended scheduled release schedule, and will release new features in minor versions.</p> <p>When a new release is created the following should happen.</p> <ul> <li>A release PR is created with:<ul> <li>Update to the changelog in <code>docs/admin/release_notes/version_&lt;major&gt;.&lt;minor&gt;.md</code> file to reflect the changes.</li> <li>Change the version from <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-beta</code> to <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> in pyproject.toml.</li> <li>Set the PR to the main</li> </ul> </li> <li>Ensure the tests for the PR pass.</li> <li>Merge the PR.</li> <li>Create a new tag:<ul> <li>The tag should be in the form of <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>.</li> <li>The title should be in the form of <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>.</li> <li>The description should be the changes that were added to the <code>version_&lt;major&gt;.&lt;minor&gt;.md</code> document.</li> </ul> </li> <li>If merged into <code>main</code>, then push from <code>main</code> to <code>develop</code>, in order to retain the merge commit created when the PR was merged</li> <li>A post release PR is created with.<ul> <li>Change the version from <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> to <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch + 1&gt;-beta</code> pyproject.toml.</li> <li>Set the PR to the <code>develop</code>.</li> <li>Once tests pass, merge.</li> </ul> </li> </ul>"},{"location":"dev/dev_adr.html","title":"Architecture Decision Records","text":"<p>The intention is to document deviations from a standard pattern.</p>"},{"location":"dev/dev_adr.html#optional-import-for-oui-mapping","title":"Optional Import for OUI Mapping","text":"<p>The following code is purposeful to ensure that we only import the large <code>OUI_MAPPINGS</code> if required. This does not effect the jinja mappings which will load the larger oui_mappings file.</p> <pre><code>@_valid_mac\ndef get_oui(mac: str) -&gt; str:\n    from netutils.oui_mappings import OUI_MAPPINGS  # pylint: disable=import-outside-toplevel\n</code></pre>"},{"location":"dev/dev_adr.html#has-lib","title":"Has Lib","text":"<p>Pending updates from napalm inclusion</p>"},{"location":"dev/dev_config.html","title":"Config Parsers Development","text":""},{"location":"dev/dev_config.html#current-included-parsers","title":"Current Included Parsers","text":"OS Name Parser Class arista_eos netutils.config.parser.EOSConfigParser aruba_aoscx netutils.config.parser.ArubaConfigCXParser aruba_os netutils.config.parser.ArubaConfigOSParser aruba_osswitch netutils.config.parser.ArubaConfigOSParser bigip_f5 netutils.config.parser.F5ConfigParser cisco_aireos netutils.config.parser.AIREOSConfigParser cisco_asa netutils.config.parser.ASAConfigParser cisco_ios netutils.config.parser.IOSConfigParser cisco_iosxr netutils.config.parser.IOSXRConfigParser cisco_nxos netutils.config.parser.NXOSConfigParser citrix_netscaler netutils.config.parser.NetscalerConfigParser extreme_netiron netutils.config.parser.NetironConfigParser fortinet_fortios netutils.config.parser.FortinetConfigParser hp_comware netutils.config.parser.HPComwareConfigParser juniper_junos netutils.config.parser.JunosConfigParser linux netutils.config.parser.LINUXConfigParser mikrotik_routeros netutils.config.parser.RouterOSConfigParser mrv_optiswitch netutils.config.parser.OptiswitchConfigParser netscaler netutils.config.parser.NetscalerConfigParser nokia_sros netutils.config.parser.NokiaConfigParser nvidia_onyx netutils.config.parser.NvidiaOnyxConfigParser paloalto_panos netutils.config.parser.PaloAltoNetworksConfigParser rad_etx netutils.config.parser.RadEtxConfigParser ruckus_fastiron netutils.config.parser.FastironConfigParser ubiquiti_airos netutils.config.parser.UbiquitiAirOSConfigParser"},{"location":"dev/dev_config.html#building-for-actual-use-cases","title":"Building for Actual Use Cases","text":"<p>The library attempts to model actual configuration as shown in the running configuration, traditionally shown with a <code>show run</code> or similar command. Accounting for use cases that do not exist in the running configuration, are generally outside the scope of the project.</p> <p>There are occasions where there will be a exceptions for valid running configuration and will be documented below.</p>"},{"location":"dev/dev_config.html#fortinet-fortios-parser","title":"Fortinet Fortios Parser","text":"<p>In order to support html blocks that exist in Fortios configurations, some preprocessing is executed, this is a regex that specifically grabs everything between quotes after the 'set buffer' sub-command. It's explicitly looking for double quote followed by a newline (\"\\n) to end the captured data.  This support for html data will not support any other html that doesn't follow this convention.</p>"},{"location":"dev/dev_config.html#f5-parser","title":"F5 Parser","text":"<p>The \"ltm rule\" configuration sections are not uniform nor standardized; therefor, these sections are completely removed from the configuration in a preprocessing event.</p>"},{"location":"dev/dev_config.html#nokia-sros-parser","title":"Nokia SROS Parser","text":"<p>The section banners have been simplified to extract the section header itself. This means that <code>echo \"System Configuration\"</code> will be converted to just \"System Configuration\".</p>"},{"location":"dev/dev_config.html#citrix-netscaler-parser","title":"Citrix NetScaler Parser","text":"<p>As the NetScaler configuration uses each line to make a specific configuration change there is no support for parent/child relationships in the parser.</p>"},{"location":"dev/dev_config.html#palo-alto-conversion","title":"Palo Alto Conversion","text":"<p>The conversion from curly to set format via the <code>paloalto_panos_brace_to_set</code> function strips any usage of <code>devices localhost.localdomain</code>. This will be evaluated in the future to be configurable but it is the current intention.</p>"},{"location":"dev/dev_config.html#duplicate-line-detection","title":"Duplicate Line Detection","text":"<p>In some circumstances replacing lines, such as secrets without uniqueness in the replacement, will result in duplicated lines that are invalid configuration, such as:</p> <pre><code>snmp-server community &lt;&lt;REPLACED&gt;&gt; RO SNMP_ACL_RO\nsnmp-server community &lt;&lt;REPLACED&gt;&gt; RO SNMP_ACL_RO\n</code></pre> <p>There are some known use cases, such as the below that are considered::</p> <pre><code>router bgp 6500\n bgp router-id 10.0.0.11\n !\n address-family ipv4 unicast\n  redistribute connected\n exit-address-family &lt;--- duplicated hierarchy\n !\n address-family l2vpn evpn\n  neighbor underlay activate\n exit-address-family &lt;--- duplicated hierarchy\n</code></pre> <p>Documented use cases that are actual configuration on a network device are considered valid and should be opened for bug fixes. However, configuration that does not actually exist on the running config of network devices are out of scope for the parser.</p>"},{"location":"dev/dev_config.html#new-parsers","title":"New Parsers","text":"<p>There are a series of considerations documented below, when developing a new parser.</p> <ul> <li>Creation of a new class that must be created in <code>netutils/config/parser.py</code> file.</li> <li>Creation of a parser class that inherits from the class <code>BaseConfigParser</code> in the Python Method Resolution Order (MRO).<ul> <li>In nearly all cases should inherit directory off of <code>BaseSpaceConfigParser</code> or <code>BaseBraceConfigParser</code>.</li> <li><code>BaseSpaceConfigParser</code> is for Cisco IOS-like configurations.</li> <li><code>BaseBraceConfigParser</code> is for JUNOS-like configurations that use curly braces.</li> </ul> </li> <li>Create the class name in the format of <code>{os_name.title()}ConfigParser</code>.<ul> <li>The classes <code>__init__</code> method must keep true to the signature or <code>__init__(self, config)</code>.</li> <li>The class must provide a <code>self.config_lines</code> that is a list of <code>ConfigLine</code> named tuples.</li> </ul> </li> <li>Build tests for the <code>tests/unit/mock/config/compliance/compliance/{os_name}/*</code> and <code>tests/unit/mock/config/parser/base/{os_name}/*</code>.</li> <li>Add to <code>netutils/config/compliance.py</code> the <code>parser_map</code>, that maps the name of the parser to the Plugin.<ul> <li>Ensure that the key name is based on <code>netutils.lib_mapper.MAIN_LIB_MAPPER_LIB_MAPPER</code> definitions.</li> <li>Ensure that it is alpha sorted.</li> <li>Ensure that it the key is added to <code>netutils.lib_mapper.NETUTILSPARSER_LIB_MAPPER</code> and <code>netutils.lib_mapper.NETUTILSPARSER_LIB_MAPPER_REVERSE</code>.</li> </ul> </li> <li>Fill out docstrings in the class and methods within the class that describe the parameters and an Example that compiles.</li> <li>The following tips will generally be applicable.<ul> <li>Generally a class method should provide a <code>comment_chars</code> and <code>banner_start</code> as well as sometimes <code>banner_end</code>.</li> <li>Generally on the <code>__init__</code> should call the <code>build_config_relationship</code> method.</li> <li>Often can inherit directly from <code>CiscoConfigParser</code>.</li> <li>Observe the existing patterns, make use of <code>super</code>, and inheritance to reuse existing code.</li> </ul> </li> </ul>"},{"location":"dev/dev_environment.html","title":"Building Your Development Environment","text":""},{"location":"dev/dev_environment.html#quickstart","title":"Quickstart","text":"<p>The development environment can be used in two ways:</p> <ol> <li><code>Recommended</code> All services are spun up using Docker and a local mount so you can develop locally, but Netutils is spun up within the Docker container.</li> <li>With a local poetry environment if you wish to develop outside of Docker.</li> </ol> <p>This is a quick reference guide if you're already familiar with the development environment provided, which you can read more about later in this document.</p>"},{"location":"dev/dev_environment.html#invoke","title":"Invoke","text":"<p>The Invoke library is used to provide some helper commands based on the environment. There are a few configuration parameters which can be passed to Invoke to override the default configuration:</p> <ul> <li><code>local</code>: a boolean flag indicating if invoke tasks should be run on the host or inside the docker containers (default: False, commands will be run in docker containers)</li> </ul> <p>Using Invoke these configuration options can be overridden using several methods. Perhaps the simplest is setting an environment variable <code>INVOKE_NETUTILS_VARIABLE_NAME</code> where <code>VARIABLE_NAME</code> is the variable you are trying to override. There is an example <code>invoke.yml</code> (<code>invoke.example.yml</code>) in this directory which can be used as a starting point.</p>"},{"location":"dev/dev_environment.html#docker-development-environment","title":"Docker Development Environment","text":"<p>Tip</p> <p>This is the recommended option for development.</p> <p>This project is managed by Python Poetry and has a few requirements to setup your development environment:</p> <ol> <li>Install Poetry, see the Poetry Documentation for your operating system.</li> <li>Install Docker, see the Docker documentation for your operating system.</li> </ol> <p>Once you have Poetry and Docker installed you can run the following commands (in the root of the repository) to install all other development dependencies in an isolated Python virtual environment:</p> <pre><code>poetry shell\npoetry install\ninvoke build\ninvoke start\n</code></pre> <p>Live documentation can be viewed at http://localhost:8001.</p> <p>To either stop or destroy the development environment use the following options.</p> <ul> <li>invoke stop - Stop the containers, but keep all underlying systems intact</li> <li>invoke destroy - Stop and remove all containers, volumes, etc. (This results in data loss due to the volume being deleted)</li> </ul>"},{"location":"dev/dev_environment.html#poetry","title":"Poetry","text":"<p>Poetry is used in lieu of the \"virtualenv\" commands and is leveraged in both environments. The virtual environment will provide all of the Python packages required to manage the development environment such as Invoke. See the Local Development Environment section to see how to install Netutils if you're going to be developing locally (i.e. not using the Docker container).</p> <p>The <code>pyproject.toml</code> file outlines all of the relevant dependencies for the project:</p> <ul> <li><code>tool.poetry.dependencies</code> - the main list of dependencies.</li> <li><code>tool.poetry.group.dev.dependencies</code> - development dependencies, to facilitate linting, testing, and documentation building.</li> </ul> <p>The <code>poetry shell</code> command is used to create and enable a virtual environment managed by Poetry, so all commands ran going forward are executed within the virtual environment. This is similar to running the <code>source venv/bin/activate</code> command with virtualenvs. To install project dependencies in the virtual environment, you should run <code>poetry install</code> - this will install both project and development dependencies.</p> <p>For more details about Poetry and its commands please check out its online documentation.</p>"},{"location":"dev/dev_environment.html#full-docker-development-environment","title":"Full Docker Development Environment","text":"<p>This project is set up with a number of Invoke tasks consumed as simple CLI commands to get developing fast. You'll use a few <code>invoke</code> commands to get your environment up and running.</p>"},{"location":"dev/dev_environment.html#cli-helper-commands","title":"CLI Helper Commands","text":"<p>The project features a CLI helper based on invoke to help setup the development environment. The commands are listed below in 3 categories: - <code>dev environment</code> - <code>utility</code> - <code>testing</code></p> <p>Each command can be executed with <code>invoke &lt;command&gt;</code>. Each command also has its own help <code>invoke &lt;command&gt; --help</code></p>"},{"location":"dev/dev_environment.html#local-dev-environment","title":"Local dev environment","text":"<pre><code>  build              Build all docker images.\n  clean              Remove the project specific image.\n  docs               Build and serve docs locally.\n  rebuild            Clean the Docker image and then rebuild without using cache.\n</code></pre>"},{"location":"dev/dev_environment.html#utility","title":"Utility","text":"<pre><code>  cli                       Enter the image to perform troubleshooting or dev work.\n  clean                     Remove stopped containers that source for image `netutils:`\n  generate-release-notes    Generate Release Notes using Towncrier.\n</code></pre>"},{"location":"dev/dev_environment.html#testing","title":"Testing","text":"<pre><code>  autoformat (a)    Run code autoformatting.\n  pylint            Run pylint for the specified name and Python version.\n  mypy              Run mypy to validate typing-hints.\n  ruff              Run ruff to perform code formatting and/or linting.\n  pytest            Run pytest for the specified name and Python version.\n  tests             Run all tests for the specified name and Python version.\n  yamllint          Run yamllint to validate formatting adheres to NTC defined YAML standards.\n</code></pre>"},{"location":"dev/extending.html","title":"Extending the Library","text":"<p>Extending the library is welcome, however it is best to open an issue first, to ensure that a PR would be accepted and makes sense in terms of features and design.</p>"},{"location":"dev/include_parser_list.html","title":"Config Parsers","text":"OS Name Parser Class arista_eos netutils.config.parser.EOSConfigParser aruba_aoscx netutils.config.parser.ArubaConfigCXParser aruba_os netutils.config.parser.ArubaConfigOSParser aruba_osswitch netutils.config.parser.ArubaConfigOSParser bigip_f5 netutils.config.parser.F5ConfigParser cisco_aireos netutils.config.parser.AIREOSConfigParser cisco_asa netutils.config.parser.ASAConfigParser cisco_ios netutils.config.parser.IOSConfigParser cisco_iosxr netutils.config.parser.IOSXRConfigParser cisco_nxos netutils.config.parser.NXOSConfigParser citrix_netscaler netutils.config.parser.NetscalerConfigParser extreme_netiron netutils.config.parser.NetironConfigParser fortinet_fortios netutils.config.parser.FortinetConfigParser hp_comware netutils.config.parser.HPComwareConfigParser juniper_junos netutils.config.parser.JunosConfigParser linux netutils.config.parser.LINUXConfigParser mikrotik_routeros netutils.config.parser.RouterOSConfigParser mrv_optiswitch netutils.config.parser.OptiswitchConfigParser netscaler netutils.config.parser.NetscalerConfigParser nokia_sros netutils.config.parser.NokiaConfigParser nvidia_onyx netutils.config.parser.NvidiaOnyxConfigParser paloalto_panos netutils.config.parser.PaloAltoNetworksConfigParser rad_etx netutils.config.parser.RadEtxConfigParser ruckus_fastiron netutils.config.parser.FastironConfigParser ubiquiti_airos netutils.config.parser.UbiquitiAirOSConfigParser"},{"location":"dev/release_checklist.html","title":"Release Checklist","text":"<p>This document is intended for library maintainers and outlines the steps to perform when releasing a new version of the library.</p> <p>Important</p> <p>Before starting, make sure your local <code>develop</code>, <code>main</code> are all up to date with upstream!</p> <pre><code>git fetch\ngit switch develop &amp;&amp; git pull\n</code></pre> <p>Choose your own adventure:</p> <ul> <li>Patch release from <code>develop</code>? Jump here.</li> <li>Minor release? Continue with Minor Version Bumps and then All Releases from <code>develop</code>.</li> </ul>"},{"location":"dev/release_checklist.html#minor-version-bumps","title":"Minor Version Bumps","text":""},{"location":"dev/release_checklist.html#update-requirements","title":"Update Requirements","text":"<p>Every minor version release should refresh <code>poetry.lock</code>, so that it lists the most recent stable release of each package. To do this:</p> <ol> <li>Run <code>poetry update --dry-run</code> to have Poetry automatically tell you what package updates are available and the versions it would upgrade to. This requires an existing environment created from the lock file (i.e. via <code>poetry install</code>).</li> <li>Review each requirement's release notes for any breaking or otherwise noteworthy changes.</li> <li>Run <code>poetry update &lt;package&gt;</code> to update the package versions in <code>poetry.lock</code> as appropriate.</li> <li>If a required package requires updating to a new release not covered in the version constraints for a package as defined in <code>pyproject.toml</code>, (e.g. <code>Django ~3.1.7</code> would never install <code>Django &gt;=4.0.0</code>), update it manually in <code>pyproject.toml</code>.</li> <li>Run <code>poetry install</code> to install the refreshed versions of all required packages.</li> <li>Run all tests (<code>poetry run invoke tests</code>) and check that the UI and API function as expected.</li> </ol>"},{"location":"dev/release_checklist.html#update-documentation","title":"Update Documentation","text":"<p>If there are any changes to the compatibility matrix (such as a bump in the minimum supported Nautobot version), update it accordingly.</p> <p>Commit any resulting changes from the following sections to the documentation before proceeding with the release.</p> <p>Tip</p> <p>Fire up the documentation server in your development environment with <code>poetry run mkdocs serve</code>! This allows you to view the documentation site locally (the link is in the output of the command) and automatically rebuilds it as you make changes.</p>"},{"location":"dev/release_checklist.html#verify-the-installation-and-upgrade-steps","title":"Verify the Installation and Upgrade Steps","text":"<p>Follow the installation instructions to perform a new production installation of the library. If possible, also test the upgrade process from the previous released version.</p> <p>The goal of this step is to walk through the entire install process as documented to make sure nothing there needs to be changed or updated, to catch any errors or omissions in the documentation, and to ensure that it is current with each release.</p>"},{"location":"dev/release_checklist.html#all-releases-from-develop","title":"All Releases from <code>develop</code>","text":""},{"location":"dev/release_checklist.html#verify-ci-build-status","title":"Verify CI Build Status","text":"<p>Ensure that continuous integration testing on the <code>develop</code> branch is completing successfully.</p>"},{"location":"dev/release_checklist.html#bump-the-version","title":"Bump the Version","text":"<p>Update the package version using <code>poetry version</code> if necessary. This command shows the current version of the project or bumps the version of the project and writes the new version back to <code>pyproject.toml</code> if a valid bump rule is provided.</p> <p>The new version must be a valid semver string or a valid bump rule: <code>patch</code>, <code>minor</code>, <code>major</code>, <code>prepatch</code>, <code>preminor</code>, <code>premajor</code>, <code>prerelease</code>. Always try to use a bump rule when you can.</p> <p>Display the current version with no arguments:</p> <pre><code>&gt; poetry version\nnetutils 1.0.0-beta.2\n</code></pre> <p>Bump pre-release versions using <code>prerelease</code>:</p> <pre><code>&gt; poetry version prerelease\nBumping version from 1.0.0-beta.2 to 1.0.0-beta.3\n</code></pre> <p>For major versions, use <code>major</code>:</p> <pre><code>&gt; poetry version major\nBumping version from 1.0.0-beta.2 to 1.0.0\n</code></pre> <p>For patch versions, use <code>minor</code>:</p> <pre><code>&gt; poetry version minor\nBumping version from 1.0.0 to 1.1.0\n</code></pre> <p>And lastly, for patch versions, you guessed it, use <code>patch</code>:</p> <pre><code>&gt; poetry version patch\nBumping version from 1.1.0 to 1.1.1\n</code></pre> <p>Please see the official Poetry documentation on <code>version</code> for more information.</p>"},{"location":"dev/release_checklist.html#update-the-changelog","title":"Update the Changelog","text":"<p>Important</p> <p>The changelog must adhere to the Keep a Changelog style guide.</p> <p>This guide uses <code>1.4.2</code> as the new version in its examples, so change it to match the version you bumped to in the previous step! Every. single. time. you. copy/paste commands :)</p> <p>First, create a release branch off of <code>develop</code> (<code>git switch -c release-1.4.2 develop</code>).</p> <p>You will need to have the project's poetry environment built at this stage, as the towncrier command runs locally only. If you don't have it, run <code>poetry install</code> first. Generate release notes with <code>invoke generate-release-notes --version 1.4.2</code> and answer <code>yes</code> to the prompt <code>Is it okay if I remove those files? [Y/n]:</code>. This will update the release notes in <code>docs/admin/release_notes/version_X.Y.md</code>, stage that file in git, and <code>git rm</code> all the fragments that have now been incorporated into the release notes.</p> <p>There are two possibilities:</p> <ol> <li>If you're releasing a new major or minor version, rename the <code>version_X.Y.md</code> file accordingly (e.g. rename to <code>docs/admin/release_notes/version_1.4.md</code>). Update the <code>Release Overview</code> and add this new page to the table of contents within <code>mkdocs.yml</code>.</li> <li>If you're releasing a patch version, copy your version's section from the <code>version_X.Y.md</code> file into the already existing <code>docs/admin/release_notes/version_1.4.md</code> file. Delete the <code>version_X.Y.md</code> file.</li> </ol> <p>Stage all the changes (<code>git add</code>) and check the diffs to verify all of the changes are correct (<code>git diff --cached</code>).</p> <p>Commit <code>git commit -m \"Release v1.4.2\"</code> and <code>git push</code> the staged changes.</p>"},{"location":"dev/release_checklist.html#submit-release-pull-request","title":"Submit Release Pull Request","text":"<p>Submit a pull request titled <code>Release v1.4.2</code> to merge your release branch into <code>main</code>. Copy the documented release notes into the pull request's body.</p> <p>Important</p> <p>Do not squash merge this branch into <code>main</code>. Make sure to select <code>Create a merge commit</code> when merging in GitHub.</p> <p>Once CI has completed on the PR, merge it.</p>"},{"location":"dev/release_checklist.html#create-a-new-release-in-github","title":"Create a New Release in GitHub","text":"<p>Draft a new release with the following parameters.</p> <ul> <li>Tag: Input current version (e.g. <code>v1.4.2</code>) and select <code>Create new tag: v1.4.2 on publish</code></li> <li>Target: <code>main</code></li> <li>Title: Version and date (e.g. <code>v1.4.2 - 2024-04-02</code>)</li> </ul> <p>Click \"Generate Release Notes\" and edit the auto-generated content as follows:</p> <ul> <li>Change the entries generated by GitHub to only the usernames of the contributors. e.g. <code>* Updated dockerfile by @ntc_user in https://github.com/networktocode/netutils/pull/123</code> -&gt; <code>* @ntc_user</code>.<ul> <li>This should give you the list for the new <code>Contributors</code> section.</li> <li>Make sure there are no duplicated entries.</li> </ul> </li> <li>Replace the content of the <code>What's Changed</code> section with the description of changes from the release PR (what towncrier generated).</li> <li>If it exists, leave the <code>New Contributors</code> list as it is.</li> </ul> <p>The release notes should look as follows:</p> <pre><code>## What's Changed\n\n**Towncrier generated Changed/Fixed/Housekeeping etc. sections here**\n\n## Contributors\n\n* @alice\n* @bob\n\n## New Contributors\n\n* @bob\n\n**Full Changelog**: https://github.com/networktocode/netutils/compare/v1.4.1...v1.4.2\n</code></pre> <p>Publish the release!</p>"},{"location":"dev/release_checklist.html#create-a-pr-from-main-back-to-develop","title":"Create a PR from <code>main</code> back to <code>develop</code>","text":"<p>First, sync your <code>main</code> branch with upstream changes: <code>git switch main &amp;&amp; git pull</code>.</p> <p>Create a new branch from <code>main</code> called <code>release-1.4.2-to-develop</code> and use <code>poetry version prepatch</code> to bump the development version to the next release.</p> <p>For example, if you just released <code>v1.4.2</code>:</p> <pre><code>&gt; git switch -c release-1.4.2-to-develop main\nSwitched to a new branch 'release-1.4.2-to-develop'\n&gt; poetry version prepatch\nBumping version from 1.4.2 to 1.4.3a1\n&gt; git add pyproject.toml &amp;&amp; git commit -m \"Bump version\"\n&gt; git push\n</code></pre> <p>Important</p> <p>Do not squash merge this branch into <code>develop</code>. Make sure to select <code>Create a merge commit</code> when merging in GitHub.</p> <p>Open a new PR from <code>release-1.4.2-to-develop</code> against <code>develop</code>, wait for CI to pass, and merge it.</p>"},{"location":"dev/release_checklist.html#final-checks","title":"Final checks","text":"<p>At this stage, the CI should be running or finished for the <code>v1.4.2</code> tag and a package successfully published to PyPI and added into the GitHub Release. Double check that's the case.</p> <p>Documentation should also have been built for the tag on ReadTheDocs and if you're reading this page online, refresh it and look for the new version in the little version fly-out menu down at the bottom right of the page.</p> <p>All done!</p>"},{"location":"dev/classy/parser.html","title":"<code>netutils.config.parser.BaseConfigParser</code> Found Classes","text":""},{"location":"dev/classy/parser.html#aireosconfigparser","title":"<code>AIREOSConfigParser</code>","text":"<pre><code>from netutils.config.parser import AIREOSConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>AIREOSConfigParser</li> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> AIREOSConfigParser <p>AIREOSConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; None:\n        raise NotImplementedError()\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#asaconfigparser","title":"<code>ASAConfigParser</code>","text":"<pre><code>from netutils.config.parser import ASAConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>ASAConfigParser</li> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> ASAConfigParser <p>ASAConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.unique_config_lines: t.Set[ConfigLine] = set()\n        self.same_line_children: t.Set[ConfigLine] = set()\n        super(ASAConfigParser, self).__init__(config)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> ASAConfigParser <p>ASAConfigParser</p> <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        In addition to adding entries to config_lines, this also updates:\n          * self.same_line_children\n          * self.unique_config_lines\n\n        Args:\n            config_line (str): The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        super(ASAConfigParser, self)._update_config_lines(config_line)\n        entry = self.config_lines[-1]\n        if entry in self.unique_config_lines:\n            self.same_line_children.add(entry)\n        self.unique_config_lines.add(entry)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> ASAConfigParser <p>ASAConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import ASAConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''\n            ... interface Management0/0\n            ...  management-only\n            ...  nameif Management\n            ...  security-level 100\n            ...  ip address 10.1.1.10 255.255.255.0'''\n            &gt;&gt;&gt; config_tree = ASAConfigParser(str(config))\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line=\"interface Management0/0\", parents=()),\n            ...     ConfigLine(config_line=\" management-only\", parents=(\"interface Management0/0\",)),\n            ...     ConfigLine(config_line=\" nameif Management\", parents=(\"interface Management0/0\",)),\n            ...     ConfigLine(config_line=\" security-level 100\", parents=(\"interface Management0/0\",)),\n            ...     ConfigLine(config_line=\" ip address 10.1.1.10 255.255.255.0\", parents=(\"interface Management0/0\",)),\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if line is not None and line[0].isspace():\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    self._current_parents = ()\n\n            if line is None:\n                break\n\n            self._update_config_lines(line)\n\n        return self.config_lines\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> ASAConfigParser <p>ASAConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.startswith(banner_start):\n                return True\n        return False\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#arubaconfigcxparser","title":"<code>ArubaConfigCXParser</code>","text":"<pre><code>from netutils.config.parser import ArubaConfigCXParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>ArubaConfigCXParser</li> <li>_ArubaBaseConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_end <code>'!'</code> _ArubaBaseConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> _ArubaBaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> _ArubaBaseConfigParser <p>_ArubaBaseConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _parse_out_comments(self, config):</code> _ArubaBaseConfigParser <pre><code>    def _parse_out_comments(self, config: str) -&gt; str:\n        \"\"\"Remove comments while retaining the banner end.\n\n        Args:\n            config (str): full config as a string.\n\n        Returns:\n            The non-comment lines from ``config``.\n        \"\"\"\n        # Aruba AOS-CX uses \"!\" as both comments and the banner delimiter.\n        # Even if another delimiter is used while creating the banner, show run changes the delimiter to use \"!\".\n        # We need to remove comments while retaining the banner delimiter.\n\n        config_lines = []\n        banner_started = False\n        banner_ended = False\n        for line in config.splitlines():\n            if self.is_banner_start(line):\n                banner_started = True\n                banner_ended = False\n            if line and banner_started and not banner_ended:\n                config_lines.append(line.rstrip())\n                if line.lstrip().startswith(self.banner_end):\n                    banner_ended = True\n                    banner_started = False\n            else:\n                if line and not self.is_comment(line):\n                    config_lines.append(line.rstrip())\n        full_config = \"\\n\".join(config_lines)\n        return full_config\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#arubaconfigosparser","title":"<code>ArubaConfigOSParser</code>","text":"<pre><code>from netutils.config.parser import ArubaConfigOSParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>ArubaConfigOSParser</li> <li>_ArubaBaseConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_end <code>'!'</code> _ArubaBaseConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> _ArubaBaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> _ArubaBaseConfigParser <p>_ArubaBaseConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _parse_out_comments(self, config):</code> _ArubaBaseConfigParser <pre><code>    def _parse_out_comments(self, config: str) -&gt; str:\n        \"\"\"Remove comments while retaining the banner end.\n\n        Args:\n            config (str): full config as a string.\n\n        Returns:\n            The non-comment lines from ``config``.\n        \"\"\"\n        # Aruba AOS-CX uses \"!\" as both comments and the banner delimiter.\n        # Even if another delimiter is used while creating the banner, show run changes the delimiter to use \"!\".\n        # We need to remove comments while retaining the banner delimiter.\n\n        config_lines = []\n        banner_started = False\n        banner_ended = False\n        for line in config.splitlines():\n            if self.is_banner_start(line):\n                banner_started = True\n                banner_ended = False\n            if line and banner_started and not banner_ended:\n                config_lines.append(line.rstrip())\n                if line.lstrip().startswith(self.banner_end):\n                    banner_ended = True\n                    banner_started = False\n            else:\n                if line and not self.is_comment(line):\n                    config_lines.append(line.rstrip())\n        full_config = \"\\n\".join(config_lines)\n        return full_config\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#arubaconfigparser","title":"<code>ArubaConfigParser</code>","text":"<pre><code>from netutils.config.parser import ArubaConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>ArubaConfigParser</li> <li>_ArubaBaseConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_end <code>'!'</code> _ArubaBaseConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> _ArubaBaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> _ArubaBaseConfigParser <p>_ArubaBaseConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _parse_out_comments(self, config):</code> _ArubaBaseConfigParser <pre><code>    def _parse_out_comments(self, config: str) -&gt; str:\n        \"\"\"Remove comments while retaining the banner end.\n\n        Args:\n            config (str): full config as a string.\n\n        Returns:\n            The non-comment lines from ``config``.\n        \"\"\"\n        # Aruba AOS-CX uses \"!\" as both comments and the banner delimiter.\n        # Even if another delimiter is used while creating the banner, show run changes the delimiter to use \"!\".\n        # We need to remove comments while retaining the banner delimiter.\n\n        config_lines = []\n        banner_started = False\n        banner_ended = False\n        for line in config.splitlines():\n            if self.is_banner_start(line):\n                banner_started = True\n                banner_ended = False\n            if line and banner_started and not banner_ended:\n                config_lines.append(line.rstrip())\n                if line.lstrip().startswith(self.banner_end):\n                    banner_ended = True\n                    banner_started = False\n            else:\n                if line and not self.is_comment(line):\n                    config_lines.append(line.rstrip())\n        full_config = \"\\n\".join(config_lines)\n        return full_config\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#basebraceconfigparser","title":"<code>BaseBraceConfigParser</code>","text":"<pre><code>from netutils.config.parser import BaseBraceConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>BaseBraceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>The below Classes rely on: <code>BaseBraceConfigParser</code>.</p> <ul> <li>F5ConfigParser</li> </ul> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseConfigParser <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_multiline_config(self, delimiter):</code> BaseBraceConfigParser <pre><code>    def _build_multiline_config(self, delimiter: str) -&gt; t.Optional[ConfigLine]:\n        r\"\"\"Build config sections between characters demarcating multiline strings.\n\n        Args:\n            delimiter: The text to look for to end multiline config.\n\n        Returns:\n            The multiline string text that was added to ``self.config_lines``.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     'sys syslog {\\n'\n            ...     '    include \"\\n'\n            ...     '        filter f_local0 {\\n'\n            ...     '        facility(local0) and not match(\\\"DEBUG\");\\n'\n            ...     '    \"\\n'\n            ...     '}'\n            ... )\n            &gt;&gt;&gt; parser = BaseBraceConfigParser(config)\n            &gt;&gt;&gt; # '    include \"' started a multiline config\n            &gt;&gt;&gt; parser.config_lines == \\\n            ... [\n            ...     ConfigLine(config_line='sys syslog {', parents=()),\n            ...     ConfigLine(config_line='    include \"', parents=('sys syslog {',)),\n            ...     ConfigLine(config_line='        filter f_local0 {', parents=('sys syslog {',)),\n            ...     ConfigLine(config_line='        facility(local0) and not match(\"DEBUG\");', parents=('sys syslog {', '        filter f_local0 {')),\n            ...     ConfigLine(config_line='    \"', parents=('sys syslog {', '        filter f_local0 {')),\n            ...     ConfigLine(config_line='}', parents=('sys syslog {', '        filter f_local0 {'))\n            ... ]\n            True\n        \"\"\"\n        multiline_config = []\n        for line in self.generator_config:\n            multiline_config.append(line)\n            if line.lstrip() == delimiter:\n                multiline_entry = ConfigLine(\"\\n\".join(multiline_config), self._current_parents)\n                self.config_lines.append(multiline_entry)\n                self._current_parents = self._current_parents[:-1]\n                return multiline_entry\n        return None\n</code></pre> <code>def build_config_relationship(self):</code> BaseBraceConfigParser <p>BaseBraceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''auth ldap system-auth {\n            ...         port ldaps\n            ...         servers { ams-lda01.ntc.com }\n            ...     }\n            ...     auth partition Common {\n            ...         description \"Repository for system objects and shared objects.\"\n            ...     }\n            ...     auth password-policy { }'''\n            &gt;&gt;&gt; config_tree = BaseBraceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='auth ldap system-auth {', parents=()),\n            ...     ConfigLine(config_line='        port ldaps', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='        servers { ams-lda01.ntc.com }', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='    }', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='    auth partition Common {', parents=()),\n            ...     ConfigLine(config_line='        description \"Repository for system objects and shared objects.\"', parents=('    auth partition Common {',)), ConfigLine(config_line='    }', parents=('    auth partition Common {',)),\n            ...     ConfigLine(config_line='    auth password-policy { }', parents=())\n            ... ]\n            True\n        \"\"\"\n        for line in self.generator_config:\n            self.config_lines.append(ConfigLine(line, self._current_parents))\n            line_end = line[-1]\n            if line.endswith(\"{\"):\n                self._current_parents += (line,)\n            elif line.lstrip() == \"}\":\n                self._current_parents = self._current_parents[:-1]\n            elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n                self._current_parents += (line,)\n                self._build_multiline_config(line_end)\n\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"dev/classy/parser.html#baseconfigparser","title":"<code>BaseConfigParser</code>","text":"<pre><code>from netutils.config.parser import BaseConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>The below Classes rely on: <code>BaseConfigParser</code>.</p> <ul> <li>AIREOSConfigParser</li> <li>ASAConfigParser</li> <li>ArubaConfigCXParser</li> <li>ArubaConfigOSParser</li> <li>ArubaConfigParser</li> <li>BaseBraceConfigParser</li> <li>BaseSpaceConfigParser</li> <li>CiscoConfigParser</li> <li>EOSConfigParser</li> <li>F5ConfigParser</li> <li>FastironConfigParser</li> <li>FortinetConfigParser</li> <li>HPComwareConfigParser</li> <li>HPEConfigParser</li> <li>IOSConfigParser</li> <li>IOSXRConfigParser</li> <li>JunosConfigParser</li> <li>LINUXConfigParser</li> <li>NXOSConfigParser</li> <li>NetironConfigParser</li> <li>NetscalerConfigParser</li> <li>NokiaConfigParser</li> <li>NvidiaOnyxConfigParser</li> <li>OptiswitchConfigParser</li> <li>PaloAltoNetworksConfigParser</li> <li>RadEtxConfigParser</li> <li>RouterOSConfigParser</li> <li>UbiquitiAirOSConfigParser</li> </ul> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseConfigParser <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def build_config_relationship(self):</code> BaseConfigParser <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"dev/classy/parser.html#basespaceconfigparser","title":"<code>BaseSpaceConfigParser</code>","text":"<pre><code>from netutils.config.parser import BaseSpaceConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>The below Classes rely on: <code>BaseSpaceConfigParser</code>.</p> <ul> <li>AIREOSConfigParser</li> <li>ASAConfigParser</li> <li>ArubaConfigCXParser</li> <li>ArubaConfigOSParser</li> <li>ArubaConfigParser</li> <li>CiscoConfigParser</li> <li>EOSConfigParser</li> <li>FastironConfigParser</li> <li>FortinetConfigParser</li> <li>HPComwareConfigParser</li> <li>HPEConfigParser</li> <li>IOSConfigParser</li> <li>IOSXRConfigParser</li> <li>JunosConfigParser</li> <li>LINUXConfigParser</li> <li>NXOSConfigParser</li> <li>NetironConfigParser</li> <li>NetscalerConfigParser</li> <li>NokiaConfigParser</li> <li>OptiswitchConfigParser</li> <li>PaloAltoNetworksConfigParser</li> <li>RadEtxConfigParser</li> <li>RouterOSConfigParser</li> <li>UbiquitiAirOSConfigParser</li> </ul> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#ciscoconfigparser","title":"<code>CiscoConfigParser</code>","text":"<pre><code>from netutils.config.parser import CiscoConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>The below Classes rely on: <code>CiscoConfigParser</code>.</p> <ul> <li>AIREOSConfigParser</li> <li>ASAConfigParser</li> <li>FastironConfigParser</li> <li>IOSConfigParser</li> <li>IOSXRConfigParser</li> <li>NXOSConfigParser</li> </ul> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#eosconfigparser","title":"<code>EOSConfigParser</code>","text":"<pre><code>from netutils.config.parser import EOSConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>EOSConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_end <code>'EOF'</code> EOSConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> EOSConfigParser <p>EOSConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#f5configparser","title":"<code>F5ConfigParser</code>","text":"<pre><code>from netutils.config.parser import F5ConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>F5ConfigParser</li> <li>BaseBraceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> F5ConfigParser <p>F5ConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        super().__init__(self._clean_config_f5(config))\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_multiline_config(self, delimiter):</code> BaseBraceConfigParser <pre><code>    def _build_multiline_config(self, delimiter: str) -&gt; t.Optional[ConfigLine]:\n        r\"\"\"Build config sections between characters demarcating multiline strings.\n\n        Args:\n            delimiter: The text to look for to end multiline config.\n\n        Returns:\n            The multiline string text that was added to ``self.config_lines``.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     'sys syslog {\\n'\n            ...     '    include \"\\n'\n            ...     '        filter f_local0 {\\n'\n            ...     '        facility(local0) and not match(\\\"DEBUG\");\\n'\n            ...     '    \"\\n'\n            ...     '}'\n            ... )\n            &gt;&gt;&gt; parser = BaseBraceConfigParser(config)\n            &gt;&gt;&gt; # '    include \"' started a multiline config\n            &gt;&gt;&gt; parser.config_lines == \\\n            ... [\n            ...     ConfigLine(config_line='sys syslog {', parents=()),\n            ...     ConfigLine(config_line='    include \"', parents=('sys syslog {',)),\n            ...     ConfigLine(config_line='        filter f_local0 {', parents=('sys syslog {',)),\n            ...     ConfigLine(config_line='        facility(local0) and not match(\"DEBUG\");', parents=('sys syslog {', '        filter f_local0 {')),\n            ...     ConfigLine(config_line='    \"', parents=('sys syslog {', '        filter f_local0 {')),\n            ...     ConfigLine(config_line='}', parents=('sys syslog {', '        filter f_local0 {'))\n            ... ]\n            True\n        \"\"\"\n        multiline_config = []\n        for line in self.generator_config:\n            multiline_config.append(line)\n            if line.lstrip() == delimiter:\n                multiline_entry = ConfigLine(\"\\n\".join(multiline_config), self._current_parents)\n                self.config_lines.append(multiline_entry)\n                self._current_parents = self._current_parents[:-1]\n                return multiline_entry\n        return None\n</code></pre> <code>def _build_multiline_single_configuration_line(self, delimiter, prev_line):</code> F5ConfigParser <pre><code>    def _build_multiline_single_configuration_line(self, delimiter: str, prev_line: str) -&gt; t.Optional[ConfigLine]:\n        r\"\"\"Concatenate Multiline strings between delimiter when newlines causes string to traverse multiple lines.\n\n        Args:\n            delimiter: The text to look for to end multiline config.\n            prev_line: The text from the previously analyzed line.\n\n        Returns:\n            The multiline string text that was added to ``self.config_lines``.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import F5ConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''apm resource webtop-link aShare {\n            ...     application-uri http://funshare.example.com\n            ...     customization-group a_customization_group\n            ... }\n            ... apm sso form-based portal_ext_sso_form_based {\n            ...     form-action /Citrix/Example/ExplicitAuth/LoginAttempt\n            ...     form-field \"LoginBtn Log+On\n            ... StateContext \"\n            ...     form-password password\n            ...     form-username username\n            ...     passthru true\n            ...     start-uri /Citrix/Example/ExplicitAuth/Login*\n            ...     success-match-type cookie\n            ...     success-match-value CtxsAuthId\n            ... }\n            ... '''\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; config_tree = F5ConfigParser(str(config))\n            &gt;&gt;&gt; print(config_tree.build_config_relationship())\n            [ConfigLine(config_line='apm resource webtop-link aShare {', parents=()), ConfigLine(config_line='    application-uri http://funshare.example.com', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='    customization-group a_customization_group', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='}', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='apm sso form-based portal_ext_sso_form_based {', parents=()), ConfigLine(config_line='    form-action /Citrix/Example/ExplicitAuth/LoginAttempt', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-field \"LoginBtn Log+On\\nStateContext \"', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-password password', parents=()), ConfigLine(config_line='    form-username username', parents=()), ConfigLine(config_line='    passthru true', parents=()), ConfigLine(config_line='    start-uri /Citrix/Example/ExplicitAuth/Login*', parents=()), ConfigLine(config_line='    success-match-type cookie', parents=()), ConfigLine(config_line='    success-match-value CtxsAuthId', parents=()), ConfigLine(config_line='}', parents=())]\n        \"\"\"\n        multiline_config = [prev_line]\n        for line in self.generator_config:\n            multiline_config.append(line)\n            if line.endswith(delimiter):\n                multiline_entry = ConfigLine(\"\\n\".join(multiline_config), self._current_parents)\n                self.config_lines[-1] = multiline_entry\n                self._current_parents = self._current_parents[:-1]\n                return multiline_entry\n        return None\n</code></pre> <code>def _clean_config_f5(self, config_text):</code> F5ConfigParser <pre><code>    def _clean_config_f5(self, config_text: str) -&gt; str:\n        \"\"\"Removes all configuration items with 'ltm rule'.\n\n        iRules are essentially impossible to parse with the lack of uniformity,\n        therefore, this method ensures they are not included in ``self.config``.\n\n        Args:\n            config_text: The entire config as a string.\n\n        Returns:\n            The sanitized config with all iRules (ltm rule) stanzas removed.\n        \"\"\"\n        config_split = config_text.split(\"ltm rule\")\n        if len(config_split) &gt; 1:\n            start_config = config_split[0]\n            end_config = config_split[-1]\n            _, ltm, clean_config = end_config.partition(\"ltm\")\n            final_config = start_config + ltm + clean_config\n        else:\n            final_config = config_text\n        return final_config\n</code></pre> <code>def build_config_relationship(self):</code> F5ConfigParser <p>F5ConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import F5ConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''apm resource webtop-link aShare {\n            ...     application-uri http://funshare.example.com\n            ...     customization-group a_customization_group\n            ... }\n            ... apm sso form-based portal_ext_sso_form_based {\n            ...     form-action /Citrix/Example/ExplicitAuth/LoginAttempt\n            ...     form-field \"LoginBtn Log+On\n            ... StateContext \"\n            ...     form-password password\n            ...     form-username username\n            ...     passthru true\n            ...     start-uri /Citrix/Example/ExplicitAuth/Login*\n            ...     success-match-type cookie\n            ...     success-match-value CtxsAuthId\n            ... }\n            ... '''\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; config_tree = F5ConfigParser(config)\n            &gt;&gt;&gt; print(config_tree.build_config_relationship())\n            [ConfigLine(config_line='apm resource webtop-link aShare {', parents=()), ConfigLine(config_line='    application-uri http://funshare.example.com', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='    customization-group a_customization_group', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='}', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='apm sso form-based portal_ext_sso_form_based {', parents=()), ConfigLine(config_line='    form-action /Citrix/Example/ExplicitAuth/LoginAttempt', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-field \"LoginBtn Log+On\\nStateContext \"', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-password password', parents=()), ConfigLine(config_line='    form-username username', parents=()), ConfigLine(config_line='    passthru true', parents=()), ConfigLine(config_line='    start-uri /Citrix/Example/ExplicitAuth/Login*', parents=()), ConfigLine(config_line='    success-match-type cookie', parents=()), ConfigLine(config_line='    success-match-value CtxsAuthId', parents=()), ConfigLine(config_line='}', parents=())]\n        \"\"\"\n        for line in self.generator_config:\n            self.config_lines.append(ConfigLine(line, self._current_parents))\n            line_end = line[-1]\n            if line.endswith(\"{\"):\n                self._current_parents += (line,)\n            elif line.lstrip() == \"}\":\n                self._current_parents = self._current_parents[:-1]\n            elif any(\n                delimiters in self.multiline_delimiters and line.count(delimiters) == 1\n                for delimiters in self.multiline_delimiters\n            ):\n                for delimiter in self.multiline_delimiters:\n                    if line.count(delimiter) == 1:\n                        self._build_multiline_single_configuration_line(delimiter, line)\n            elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n                self._current_parents += (line,)\n                self._build_multiline_config(line_end)\n\n        return self.config_lines\n</code></pre> <p>BaseBraceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''auth ldap system-auth {\n            ...         port ldaps\n            ...         servers { ams-lda01.ntc.com }\n            ...     }\n            ...     auth partition Common {\n            ...         description \"Repository for system objects and shared objects.\"\n            ...     }\n            ...     auth password-policy { }'''\n            &gt;&gt;&gt; config_tree = BaseBraceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='auth ldap system-auth {', parents=()),\n            ...     ConfigLine(config_line='        port ldaps', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='        servers { ams-lda01.ntc.com }', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='    }', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='    auth partition Common {', parents=()),\n            ...     ConfigLine(config_line='        description \"Repository for system objects and shared objects.\"', parents=('    auth partition Common {',)), ConfigLine(config_line='    }', parents=('    auth partition Common {',)),\n            ...     ConfigLine(config_line='    auth password-policy { }', parents=())\n            ... ]\n            True\n        \"\"\"\n        for line in self.generator_config:\n            self.config_lines.append(ConfigLine(line, self._current_parents))\n            line_end = line[-1]\n            if line.endswith(\"{\"):\n                self._current_parents += (line,)\n            elif line.lstrip() == \"}\":\n                self._current_parents = self._current_parents[:-1]\n            elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n                self._current_parents += (line,)\n                self._build_multiline_config(line_end)\n\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"dev/classy/parser.html#fastironconfigparser","title":"<code>FastironConfigParser</code>","text":"<pre><code>from netutils.config.parser import FastironConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>FastironConfigParser</li> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^banner(\\\\smotd)?\\\\s+(?P&lt;banner_delimiter&gt;\\\\S)')</code> FastironConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> FastironConfigParser <p>FastironConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        super(FastironConfigParser, self).__init__(config)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> FastironConfigParser <p>FastironConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.banner_end):\n                    banner, end, _ = line.rpartition(self.banner_end)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#fortinetconfigparser","title":"<code>FortinetConfigParser</code>","text":"<pre><code>from netutils.config.parser import FortinetConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>FortinetConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> FortinetConfigParser <p>FortinetConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.uncommon_data = self._get_uncommon_lines(config)\n        super(FortinetConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> FortinetConfigParser <p>FortinetConfigParser</p> <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        if \"[\" in line:\n            updated_line = self.uncommon_data.get(line.split('\"')[1], None)\n            if not updated_line:\n                raise ValueError(\"Input line is malformed.\")\n            line = updated_line\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _get_uncommon_lines(self, config):</code> FortinetConfigParser <pre><code>    def _get_uncommon_lines(self, config: str) -&gt; t.Dict[str, str]:\n        \"\"\"Regex to find replacemsg lines which can contain html/css data.\n\n        Args:\n            config: Original config before parsing.\n\n        Returns:\n            dict: dictionary with replace message name as key, html/css data as value.\n        \"\"\"\n        pattern = r\"(config system replacemsg.*\\n)(\\s{4}set\\sbuffer\\s\\\"[\\S\\s]*?\\\"\\n)\"\n        regex_result = re.findall(pattern, config)\n        result = {}\n        for group_match in regex_result:\n            result.update({group_match[0].split('\"')[1]: group_match[1]})\n        return result\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _parse_out_offending(self, config):</code> FortinetConfigParser <pre><code>    def _parse_out_offending(self, config: str) -&gt; str:\n        \"\"\"Preprocess out strings that offend the normal spaced configuration syntax.\n\n        Args:\n            config (str): full config as a string.\n        \"\"\"\n        # This will grab everything between quotes after the 'set buffer' sub-command.\n        # Its explicitly looking for \"\\n to end the captured data.  This is to support html\n        # data that is supported in Fortinet config with double quotes within the html.\n        pattern = r\"(config system replacemsg.*(\\\".*\\\")\\n)(\\s{4}set\\sbuffer\\s\\\"[\\S\\s]*?\\\"\\n)\"\n        return re.sub(pattern, r\"\\1    [\\2]\\n\", config)\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre> <code>def is_end_next(self, line):</code> FortinetConfigParser <pre><code>    def is_end_next(self, line: str) -&gt; bool:\n        \"\"\"Determine if line has 'end' or 'next' in it.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line has 'end' or 'next', else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import FortinetConfigParser\n            &gt;&gt;&gt; FortinetConfigParser(\"config system virtual-switch\").is_end_next(\"config system virtual-switch\")\n            False\n            &gt;&gt;&gt; FortinetConfigParser(\"end\").is_end_next(\"end\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for end_next in [\"end\", \"next\"]:\n            if line.lstrip() == end_next:\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#hpcomwareconfigparser","title":"<code>HPComwareConfigParser</code>","text":"<pre><code>from netutils.config.parser import HPComwareConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>HPComwareConfigParser</li> <li>HPEConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^header\\\\s(\\\\w+)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|\\\\S?)')</code> HPEConfigParser <p>Methods</p> <code>def __init__(self, config):</code> HPEConfigParser <p>HPEConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Initialize the HPEConfigParser object.\"\"\"\n        self.delimiter = \"\"\n        self._banner_end: t.Optional[str] = None\n        super(HPEConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> HPComwareConfigParser <p>HPComwareConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Build a banner from the given config line.\"\"\"\n        return super(HPComwareConfigParser, self)._build_banner(config_line)\n</code></pre> <p>HPEConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"\n        Builds a banner configuration based on the given config_line.\n\n        Args:\n            config_line (str): The configuration line to process.\n\n        Returns:\n            Optional[str]: The next configuration line, or None if there are no more lines.\n\n        Raises:\n            ValueError: If the banner end cannot be parsed.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.delimiter):\n                    banner, end, _ = line.rpartition(self.delimiter)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(self, config_line):</code> HPEConfigParser <pre><code>    def is_banner_one_line(self, config_line: str) -&gt; bool:\n        \"\"\"Checks if the given configuration line represents a one-line banner.\"\"\"\n        self.set_delimiter(config_line.strip())\n        _, _delimeter, banner = config_line.partition(self.delimiter)\n        banner_config_start = banner.lstrip(_delimeter)\n        if _delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> HPEConfigParser <p>HPEConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Checks if the given line is the start of a banner.\"\"\"\n        state = super(HPEConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre> <code>def set_delimiter(self, config_line):</code> HPEConfigParser <pre><code>    def set_delimiter(self, config_line: str) -&gt; None:\n        \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n        banner_parsed = self.regex_banner.match(config_line)\n        if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n            self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n            return None\n        raise ValueError(\"Unable to find banner delimiter.\")\n</code></pre>"},{"location":"dev/classy/parser.html#hpeconfigparser","title":"<code>HPEConfigParser</code>","text":"<pre><code>from netutils.config.parser import HPEConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>HPEConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>The below Classes rely on: <code>HPEConfigParser</code>.</p> <ul> <li>HPComwareConfigParser</li> </ul> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^header\\\\s(\\\\w+)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|\\\\S?)')</code> HPEConfigParser <p>Methods</p> <code>def __init__(self, config):</code> HPEConfigParser <p>HPEConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Initialize the HPEConfigParser object.\"\"\"\n        self.delimiter = \"\"\n        self._banner_end: t.Optional[str] = None\n        super(HPEConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> HPEConfigParser <p>HPEConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"\n        Builds a banner configuration based on the given config_line.\n\n        Args:\n            config_line (str): The configuration line to process.\n\n        Returns:\n            Optional[str]: The next configuration line, or None if there are no more lines.\n\n        Raises:\n            ValueError: If the banner end cannot be parsed.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.delimiter):\n                    banner, end, _ = line.rpartition(self.delimiter)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(self, config_line):</code> HPEConfigParser <pre><code>    def is_banner_one_line(self, config_line: str) -&gt; bool:\n        \"\"\"Checks if the given configuration line represents a one-line banner.\"\"\"\n        self.set_delimiter(config_line.strip())\n        _, _delimeter, banner = config_line.partition(self.delimiter)\n        banner_config_start = banner.lstrip(_delimeter)\n        if _delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> HPEConfigParser <p>HPEConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Checks if the given line is the start of a banner.\"\"\"\n        state = super(HPEConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre> <code>def set_delimiter(self, config_line):</code> HPEConfigParser <pre><code>    def set_delimiter(self, config_line: str) -&gt; None:\n        \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n        banner_parsed = self.regex_banner.match(config_line)\n        if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n            self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n            return None\n        raise ValueError(\"Unable to find banner delimiter.\")\n</code></pre>"},{"location":"dev/classy/parser.html#iosconfigparser","title":"<code>IOSConfigParser</code>","text":"<pre><code>from netutils.config.parser import IOSConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>IOSConfigParser</li> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> IOSConfigParser <p>IOSConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.unique_config_lines: t.Set[ConfigLine] = set()\n        self.same_line_children: t.Set[ConfigLine] = set()\n        super(IOSConfigParser, self).__init__(config)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> IOSConfigParser <p>IOSConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        config_line = normalise_delimiter_caret_c(self.banner_end, config_line)\n        return super(IOSConfigParser, self)._build_banner(config_line)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> IOSConfigParser <p>IOSConfigParser</p> <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        In addition to adding entries to config_lines, this also updates:\n          * self.same_line_children\n          * self.unique_config_lines\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        super(IOSConfigParser, self)._update_config_lines(config_line)\n        entry = self.config_lines[-1]\n        if entry in self.unique_config_lines:\n            self.same_line_children.add(entry)\n        self.unique_config_lines.add(entry)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def _update_same_line_children_configs(self):</code> IOSConfigParser <pre><code>    def _update_same_line_children_configs(self) -&gt; None:\n        \"\"\"Update parents in ``self.config_lines`` per ``self.same_line_children``.\"\"\"\n        new_config_lines: t.List[ConfigLine] = []\n        for line in self.config_lines:\n            if line in self.same_line_children:\n                try:\n                    previous_line = new_config_lines[-1]\n                except IndexError as error:\n                    raise IndexError(\n                        f\"This error is likely from a duplicate line detected at the line `{line.config_line}`, \"\n                        \"see https://netutils.readthedocs.io/en/latest/dev/dev_config/#duplicate-line-detection \"\n                        f\"for more details.\\nOriginal Error: {error}\"\n                    )\n                previous_config_line = previous_line.config_line\n                current_parents = previous_line.parents + (previous_config_line,)\n                line = ConfigLine(line.config_line, current_parents)\n            new_config_lines.append(line)\n        self.config_lines = new_config_lines\n</code></pre> <code>def build_config_relationship(self):</code> IOSConfigParser <p>IOSConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import IOSConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''\n            ... interface Ethernet1/1\n            ...   vlan 10\n            ...   no shutdown\n            ... interface Ethernet1/2\n            ...   shutdown'''\n            &gt;&gt;&gt; config_tree = IOSConfigParser(str(config))\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=()),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        super(IOSConfigParser, self).build_config_relationship()\n        self._update_same_line_children_configs()\n        return self.config_lines\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#iosxrconfigparser","title":"<code>IOSXRConfigParser</code>","text":"<pre><code>from netutils.config.parser import IOSXRConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>IOSXRConfigParser</li> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^banner\\\\s+\\\\S+\\\\s+(?P&lt;banner_delimiter&gt;\\\\S)')</code> IOSXRConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> IOSXRConfigParser <p>IOSXRConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.delimiter = \"\"\n        super(IOSXRConfigParser, self).__init__(config)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> IOSXRConfigParser <p>IOSXRConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.delimiter):\n                    banner, end, _ = line.rpartition(self.delimiter)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> IOSXRConfigParser <p>IOSXRConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import IOSXRConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = IOSXRConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdowninterface Ethernet1/2', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/1',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            if not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    if not self.delimiter:\n                        self.set_delimiter(line)\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                line = self._build_nested_config(line)  # type: ignore\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre> <code>def set_delimiter(self, config_line):</code> IOSXRConfigParser <pre><code>    def set_delimiter(self, config_line: str) -&gt; None:\n        \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n        banner_parsed = self.regex_banner.match(config_line)\n        if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n            self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n            return None\n        raise ValueError(\"Unable to find banner delimiter.\")\n</code></pre>"},{"location":"dev/classy/parser.html#junosconfigparser","title":"<code>JunosConfigParser</code>","text":"<pre><code>from netutils.config.parser import JunosConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>JunosConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#linuxconfigparser","title":"<code>LINUXConfigParser</code>","text":"<pre><code>from netutils.config.parser import LINUXConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>LINUXConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#nxosconfigparser","title":"<code>NXOSConfigParser</code>","text":"<pre><code>from netutils.config.parser import NXOSConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>NXOSConfigParser</li> <li>CiscoConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser regex_banner <code>re.compile('^banner\\\\s+\\\\S+\\\\s+(?P&lt;banner_delimiter&gt;\\\\S)')</code> NXOSConfigParser regex_banner <code>re.compile('^(banner\\\\s+\\\\S+|\\\\s*vacant-message)\\\\s+(?P&lt;banner_delimiter&gt;\\\\^C|.)')</code> CiscoConfigParser <p>Methods</p> <code>def __init__(self, config):</code> NXOSConfigParser <p>NXOSConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.unique_config_lines: t.Set[ConfigLine] = set()\n        self.same_line_children: t.Set[ConfigLine] = set()\n        super(NXOSConfigParser, self).__init__(config)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> NXOSConfigParser <p>NXOSConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        config_line = normalise_delimiter_caret_c(self.banner_end, config_line)\n        return super(NXOSConfigParser, self)._build_banner(config_line)\n</code></pre> <p>CiscoConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_one_line(config_line):</code> CiscoConfigParser <pre><code>    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n</code></pre> <code>def is_banner_start(self, line):</code> CiscoConfigParser <p>CiscoConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#netironconfigparser","title":"<code>NetironConfigParser</code>","text":"<pre><code>from netutils.config.parser import NetironConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>NetironConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#netscalerconfigparser","title":"<code>NetscalerConfigParser</code>","text":"<pre><code>from netutils.config.parser import NetscalerConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>NetscalerConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#nokiaconfigparser","title":"<code>NokiaConfigParser</code>","text":"<pre><code>from netutils.config.parser import NokiaConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>NokiaConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _get_section_title(self, line):</code> NokiaConfigParser <pre><code>    def _get_section_title(self, line: str) -&gt; t.Union[str, bool]:\n        \"\"\"Determine section title from banner.\n\n        Args:\n            line: A config line from the device that has been found to be a section title.\n\n        Returns:\n            The section's title from the section banner, else False.\n        \"\"\"\n        section_title = re.match(r\"^echo\\s\\\"(?P&lt;section_name&gt;.+)\\\"\", string=line)\n        if section_title:\n            return section_title.group(\"section_name\")\n        return False\n</code></pre> <code>def _is_section_title(self, line):</code> NokiaConfigParser <pre><code>    def _is_section_title(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a section title in banner.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a section, else False.\n        \"\"\"\n        if re.match(r\"^echo\\s\\\".+\\\"\", string=line):\n            return True\n        return False\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#nvidiaonyxconfigparser","title":"<code>NvidiaOnyxConfigParser</code>","text":"<pre><code>from netutils.config.parser import NvidiaOnyxConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>NvidiaOnyxConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_char <code>'#'</code> NvidiaOnyxConfigParser comment_chars <code>['!']</code> BaseConfigParser section_char <code>'##'</code> NvidiaOnyxConfigParser <p>Methods</p> <code>def __init__(self, config):</code> NvidiaOnyxConfigParser <p>NvidiaOnyxConfigParser</p> <pre><code>    def __init__(self, config: str):  # pylint: disable=super-init-not-called\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in (self._config_lines_only()))\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _config_lines_only(self):</code> NvidiaOnyxConfigParser <pre><code>    def _config_lines_only(self) -&gt; t.List[str]:\n        \"\"\"Remove spaces and unwanted lines from config lines.\n\n        Returns:\n            An array with non-space and non-comment lines from ``config``.\n        \"\"\"\n        banner_text = \"\"\n        config_lines = []\n        for line in self.config.splitlines():\n            if line.startswith(self.section_char):\n                continue\n            stripped = line.strip()\n            if re.match(r\"banner \\w+ (?!\\\".+\\\")\", stripped):\n                banner_text += line.lstrip()\n            elif banner_text and not stripped.endswith('\"'):\n                banner_text += \"\\n\" + line\n            elif banner_text and stripped.endswith('\"'):\n                banner_text += \"\\n\" + line\n                config_lines.append(banner_text)\n                banner_text = \"\"\n            elif stripped:\n                config_lines.append(stripped)\n\n        return config_lines\n</code></pre> <code>def build_config_relationship(self):</code> NvidiaOnyxConfigParser <p>NvidiaOnyxConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text config lines and banners.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''\n            ...     ##\n            ...     ## VLAN configuration\n            ...     ##\n            ...        vlan 1\n            ...        vlan 2\n            ...        vlan 3\n            ...\n            ...     ##\n            ...     ## Network management configuration\n            ...     ##\n            ...        banner login \"\n            ...\n            ...        MULTILINE BANNER\"'''\n            &gt;&gt;&gt; config_tree = NvidiaOnyxConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='vlan 1', parents=()),\n            ...     ConfigLine(config_line='vlan 2', parents=()),\n            ...     ConfigLine(config_line='vlan 3', parents=()),\n            ...     ConfigLine(config_line='banner login \"\\n\\n       MULTILINE BANNER\"', parents=()),\n            ... ]\n            True\n        \"\"\"\n        for line in self.generator_config:\n            if not line.startswith(self.comment_char):\n                self.config_lines.append(ConfigLine(line, ()))\n\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"dev/classy/parser.html#optiswitchconfigparser","title":"<code>OptiswitchConfigParser</code>","text":"<pre><code>from netutils.config.parser import OptiswitchConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>OptiswitchConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#paloaltonetworksconfigparser","title":"<code>PaloAltoNetworksConfigParser</code>","text":"<pre><code>from netutils.config.parser import PaloAltoNetworksConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>PaloAltoNetworksConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_end <code>'\"'</code> PaloAltoNetworksConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> PaloAltoNetworksConfigParser <p>PaloAltoNetworksConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line.strip())\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line.strip())\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> PaloAltoNetworksConfigParser <p>PaloAltoNetworksConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:  # pylint: disable=too-many-branches\n        r\"\"\"Parse text of config lines and find their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import PaloAltoNetworksConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"set deviceconfig system hostname firewall1\\n\"\n            ...     \"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\\n\"\n            ...     \"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\\n\"\n            ...     \"set deviceconfig setting config rematch yes\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = PaloAltoNetworksConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line=\"set deviceconfig system hostname firewall1\", parents=()),\n            ...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\", parents=()),\n            ...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\", parents=()),\n            ...     ConfigLine(config_line=\"set deviceconfig setting config rematch yes\", parents=()),\n            ... ]\n            True\n        \"\"\"\n        # assume configuration does not need conversion\n        _needs_conversion = False\n\n        # if config is in palo brace format, convert to set\n        if self.config_lines_only is not None:\n            for line in self.config_lines_only.splitlines():\n                if line.endswith(\"{\"):\n                    _needs_conversion = True\n        if _needs_conversion:\n            converted_config = paloalto_panos_brace_to_set(cfg=self.config, cfg_type=\"string\")\n            list_config = converted_config.splitlines()\n            self.generator_config = (line for line in list_config)\n\n        # build config relationships\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> PaloAltoNetworksConfigParser <p>PaloAltoNetworksConfigParser</p> <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if end of banner.\"\"\"\n        if line.endswith('\"') or line.startswith('\";') or line.startswith(\"set\") or line.endswith(self.banner_end):\n            return True\n        return False\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#radetxconfigparser","title":"<code>RadEtxConfigParser</code>","text":"<pre><code>from netutils.config.parser import RadEtxConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>RadEtxConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#routerosconfigparser","title":"<code>RouterOSConfigParser</code>","text":"<pre><code>from netutils.config.parser import RouterOSConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>RouterOSConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> RouterOSConfigParser <p>RouterOSConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner (system note) config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        banner_config = [config_line]\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner (system note) end.\")\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> RouterOSConfigParser <p>RouterOSConfigParser</p> <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if end of banner.\"\"\"\n        if line.endswith('\"') or line.startswith(\"/\"):\n            return True\n        return False\n</code></pre> <p>BaseSpaceConfigParser</p> <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/classy/parser.html#ubiquitiairosconfigparser","title":"<code>UbiquitiAirOSConfigParser</code>","text":"<pre><code>from netutils.config.parser import UbiquitiAirOSConfigParser\n</code></pre> <p>Ancestors (MRO)</p> <p>The Method Resolution Order is described below.</p> <ol> <li>UbiquitiAirOSConfigParser</li> <li>BaseSpaceConfigParser</li> <li>BaseConfigParser</li> </ol> <p>Descendant Classes</p> <p>Attributes</p> Key Value Defined in banner_start <code>['banner', 'vacant-message']</code> BaseSpaceConfigParser banner_start <code>['banner', 'vacant-message']</code> BaseConfigParser comment_chars <code>['!']</code> BaseSpaceConfigParser comment_chars <code>['!']</code> BaseConfigParser <p>Methods</p> <code>def __init__(self, config):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n</code></pre> <code>def _build_banner(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre> <code>def _build_nested_config(self, line):</code> BaseSpaceConfigParser <pre><code>    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n</code></pre> <code>def _match_type_check(line, pattern, match_type):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n</code></pre> <code>def _remove_parents(self, line, current_spaces):</code> BaseSpaceConfigParser <pre><code>    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n</code></pre> <code>def _update_config_lines(self, config_line):</code> BaseSpaceConfigParser <pre><code>    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n</code></pre> <code>def build_config_relationship(self):</code> BaseSpaceConfigParser <p>BaseSpaceConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre> <p>BaseConfigParser</p> <pre><code>    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre> <code>def find_all_children(self, pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def find_children_w_parents(self, parent_pattern, child_pattern, match_type=exact):</code> BaseSpaceConfigParser <pre><code>    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre> <code>def get_leading_space_count(config_line):</code> BaseSpaceConfigParser <pre><code>    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n</code></pre> <code>def is_banner_end(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n</code></pre> <code>def is_banner_start(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n</code></pre> <code>def is_comment(self, line):</code> BaseSpaceConfigParser <pre><code>    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n</code></pre>"},{"location":"dev/code_reference/index.html","title":"Code Reference","text":"<p>Auto-generated code reference documentation from docstrings. This is the official method to document examples of using the code, this ensures that there is always an example and that the example is accurate.</p>"},{"location":"dev/code_reference/acl.html","title":"ACLs","text":""},{"location":"dev/code_reference/acl.html#netutils.acl","title":"<code>netutils.acl</code>","text":"<p>Classes to help manage ACLs .</p>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule","title":"<code>ACLRule</code>","text":"<p>A class that helps you imagine an acl rule via methodologies.</p> Source code in <code>netutils/acl.py</code> <pre><code>class ACLRule:\n    \"\"\"A class that helps you imagine an acl rule via methodologies.\"\"\"\n\n    attrs: t.List[str] = [\"name\", \"src_ip\", \"src_zone\", \"dst_ip\", \"dst_port\", \"dst_zone\", \"action\"]\n    permit: str = \"permit\"\n    deny: str = \"deny\"\n\n    input_data_verify: bool = False\n    input_data_schema: t.Any = INPUT_SCHEMA\n\n    result_data_verify: bool = False\n    result_data_schema: t.Any = RESULT_SCHEMA\n\n    matrix: t.Any = {}\n    matrix_enforced: bool = False\n    matrix_definition: t.Any = {}\n\n    dst_port_process: bool = True\n\n    order_validate: t.List[str] = []\n    order_enforce: t.List[str] = []\n    filter_same_ip: bool = True\n\n    def __init__(self, data: t.Any, *args: t.Any, **kwargs: t.Any):  # pylint: disable=unused-argument\n        \"\"\"Initialize and load data.\n\n        Args:\n            data: A dictionary with string keys and either string or list of string values\n            args: Additional positional arguments.\n            kwargs: Additional keyword arguments.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.acl import ACLRule\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; acl_data = dict(\n            ...     name=\"Check no match\",\n            ...     src_ip=[\"10.1.1.1\"],\n            ...     dst_ip=\"172.16.0.10\",\n            ...     dst_port=\"tcp/www-http\",\n            ...     action=\"permit\",\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; rule = ACLRule(acl_data)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; rule.expanded_rules\n            [{'name': 'Check no match', 'src_ip': '10.1.1.1', 'dst_ip': '172.16.0.10', 'dst_port': '6/80', 'action': 'permit'}]\n            &gt;&gt;&gt;\n        \"\"\"\n        self.processed: t.Dict[str, str] = {}\n        self.data = data\n        self.load_data()\n\n    def load_data(self) -&gt; None:\n        \"\"\"Load the data into the rule while verifying input data, result data, and processing data.\"\"\"\n        self.input_data_check()\n        for attr in self.attrs:\n            if not self.data.get(attr):\n                continue\n            if hasattr(self, f\"process_{attr}\"):\n                proccessor = getattr(self, f\"process_{attr}\")\n                _attr_data = proccessor(self.data[attr])\n            else:\n                _attr_data = self.data[attr]\n            self.processed[attr] = _attr_data\n            setattr(self, attr, _attr_data)\n        self.result_data_check()\n        self.validate()\n        self.expanded_rules = _cartesian_product(self.processed)\n        if self.filter_same_ip:\n            self.expanded_rules = [item for item in self.expanded_rules if item[\"dst_ip\"] != item[\"src_ip\"]]\n\n    def input_data_check(self) -&gt; None:\n        \"\"\"Verify the input data against the specified JSONSchema or using a simple dictionary check.\"\"\"\n        return _check_schema(self.data, self.input_data_schema, self.input_data_verify)\n\n    def result_data_check(self) -&gt; None:\n        \"\"\"Verify the result data against the specified JSONSchema or using a simple dictionary check.\"\"\"\n        return _check_schema(self.processed, self.result_data_schema, self.result_data_verify)\n\n    def validate(self) -&gt; t.Any:\n        \"\"\"Run through any method that startswith('validate_') and run that method.\"\"\"\n        if self.order_validate:\n            method_order = self.order_validate\n        else:\n            method_order = dir(self)\n        results = []\n        for name in method_order:\n            if name.startswith(\"validate_\"):\n                result = getattr(self, name)()\n                if not result:\n                    continue\n                if result and isinstance(result, dict):\n                    results.append(result)\n                elif result and isinstance(result, list):\n                    results.extend(result)\n        return results\n\n    def process_dst_port(self, dst_port: t.Any) -&gt; t.Union[t.List[str], None]:  # pylint: disable=inconsistent-return-statements\n        \"\"\"Convert port and protocol information.\n\n        Method supports a single format of `{protocol}/{port}`, and will translate the\n        protocol for all IANA defined protocols. The port will be translated for TCP and\n        UDP ports only. For all other protocols should use port of 0, e.g. `ICMP/0` for ICMP\n        or `50/0` for ESP. Similarly, IANA defines the port mappings, while these are mostly\n        staying unchanged, but sourced from\n        https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv.\n        \"\"\"\n        output = []\n        if not self.dst_port_process:\n            return None\n        if not isinstance(dst_port, list):\n            dst_port = [dst_port]\n        for item in dst_port:\n            protocol = item.split(\"/\")[0]\n            port = item.split(\"/\")[1]\n            if protocol.isalpha():\n                if not PROTO_NAME_TO_NUM.get(protocol.upper()):\n                    raise ValueError(\n                        f\"Protocol {protocol} was not found in netutils.protocol_mapper.PROTO_NAME_TO_NUM.\"\n                    )\n                protocol = PROTO_NAME_TO_NUM[protocol.upper()]\n            # test port[0] vs port, since dashes do not count, e.g. www-http\n            if int(protocol) == 6 and port[0].isalpha():\n                if not TCP_NAME_TO_NUM.get(port.upper()):\n                    raise ValueError(f\"Port {port} was not found in netutils.protocol_mapper.TCP_NAME_TO_NUM.\")\n                port = TCP_NAME_TO_NUM[port.upper()]\n            if int(protocol) == 17 and port[0].isalpha():\n                if not UDP_NAME_TO_NUM.get(port.upper()):\n                    raise ValueError(f\"Port {port} was not found in netutils.protocol_mapper.UDP_NAME_TO_NUM.\")\n                port = UDP_NAME_TO_NUM[port.upper()]\n            output.append(f\"{protocol}/{port}\")\n        return output\n\n    def enforce(self) -&gt; t.List[t.Dict[str, t.Any]]:\n        \"\"\"Run through any method that startswith('enforce_') and run that method.\n\n        Returns:\n            A list of dictionaries that explains the results of the enforcement.\n        \"\"\"\n        if self.order_enforce:\n            method_order = self.order_enforce\n        else:\n            method_order = dir(self)\n        results = []\n        for name in method_order:\n            if name.startswith(\"enforce_\"):\n                result = getattr(self, name)()\n                if not result:\n                    continue\n                if result and isinstance(result, dict):\n                    results.append(result)\n                elif result and isinstance(result, list):\n                    results.extend(result)\n        return results\n\n    def enforce_matrix(self) -&gt; t.Union[t.List[t.Dict[str, t.Any]], None]:\n        \"\"\"A simple `matrix` or grid style check of a rule.\n\n        Returns:\n            A list of dictionaries that explains the results of the matrix being enforced.\n        \"\"\"\n        if not self.matrix_enforced:\n            return None\n        if not self.matrix:\n            raise ValueError(\"You must set a matrix dictionary to use the matrix feature.\")\n        if not self.matrix_definition:\n            raise ValueError(\"You must set a matrix definition dictionary to use the matrix feature.\")\n        actions = []\n        for rule in self.expanded_rules:\n            source = rule[\"src_ip\"]\n            destination = rule[\"dst_ip\"]\n            port = rule[\"dst_port\"]\n            src_zone = \"\"\n            dst_zone = \"\"\n            as_tuple = (source, destination, port)\n            for zone, ips in self.matrix_definition.items():\n                if is_ip_within(source, ips):\n                    src_zone = zone\n                if is_ip_within(destination, ips):\n                    dst_zone = zone\n            if port in self.matrix.get(src_zone, {}).get(dst_zone, {}).get(\"allow\", []):\n                actions.append({\"obj\": as_tuple, \"action\": \"allow\"})\n            elif port in self.matrix.get(src_zone, {}).get(dst_zone, {}).get(\"notify\", []):\n                actions.append({\"obj\": as_tuple, \"action\": \"notify\"})\n            else:\n                actions.append({\"obj\": as_tuple, \"action\": \"deny\"})\n        return actions\n\n    def match_action(self, existing_action: str, check_action: str) -&gt; bool:\n        \"\"\"Match the action for equality.\n\n        Args:\n            existing_action: The existing action value to be matched.\n            check_action: The action value to be checked against the existing action.\n\n        Returns:\n            True if `existing_action` matches `check_action`, False otherwise.\n        \"\"\"\n        return existing_action == check_action\n\n    def match_src_ip(self, existing_ip: str, check_ip: str) -&gt; bool:\n        \"\"\"Determined if source `check_ip` is within `existing_ip`.\n\n        Args:\n            existing_ip: The existing source IP address or IP range to be matched against.\n            check_ip: The source IP address to be checked.\n\n        Returns:\n            True if `check_ip` is within the range of `existing_ip`, False otherwise.\n        \"\"\"\n        return is_ip_within(check_ip, existing_ip)\n\n    def match_src_zone(self, existing_src_zone: str, check_src_zone: str) -&gt; bool:\n        \"\"\"Match the source zone for equality.\n\n        Args:\n            existing_src_zone: The existing source zone value to be matched.\n            check_src_zone: The source zone value to be checked against the existing zone.\n\n        Returns:\n            True if `existing_src_zone` matches `check_src_zone`, False otherwise.\n        \"\"\"\n        return existing_src_zone == check_src_zone\n\n    def match_dst_ip(self, existing_ip: str, check_ip: str) -&gt; bool:\n        \"\"\"Determined if destination `check_ip` is within `existing_ip.\n\n        Args:\n            existing_ip: The existing destination IP address or IP range to be matched against.\n            check_ip: The destination IP address to be checked.\n\n        Returns:\n            True if `check_ip` is within the range of `existing_ip`, False otherwise.\n        \"\"\"\n        return is_ip_within(check_ip, existing_ip)\n\n    def match_dst_zone(self, existing_dst_zone: str, check_dst_zone: str) -&gt; bool:\n        \"\"\"Match the destination zone for equality.\n\n        Args:\n            existing_dst_zone: The existing destination zone value to be matched.\n            check_dst_zone: The destination zone value to be checked against the existing zone.\n\n        Returns:\n            True if `existing_dst_zone` matches `check_dst_zone`, False otherwise.\n        \"\"\"\n        return existing_dst_zone == check_dst_zone\n\n    def match_dst_port(self, existing_port: str, check_port: str) -&gt; bool:\n        \"\"\"Match the destination port for equality.\n\n        Args:\n            existing_port: The existing destination port value to be matched.\n            check_port: The destination port value to be checked against the existing port.\n\n        Returns:\n            True if `existing_port` matches `check_port`, False otherwise.\n        \"\"\"\n        return existing_port == check_port\n\n    def match_details(self, match_rule: \"ACLRule\") -&gt; t.Dict[str, t.Any]:  # pylint: disable=too-many-locals\n        \"\"\"Verbose way of verifying match details.\n\n        Args:\n            match_rule: The rule which you are testing against.\n\n        Returns:\n            A dictionary with root keys of `rules_matched` and `rules_matched`.\n        \"\"\"\n        attrs = []\n        for name in dir(self):\n            if name.startswith(\"match_\"):\n                obj_name = name[len(\"match_\") :]  # noqa: E203\n                # When an attribute is not defined, can skip it\n                if not hasattr(match_rule, obj_name):\n                    continue\n                attrs.append(obj_name)\n\n        rules_found: t.List[bool] = []\n        rules_unmatched: t.List[t.Dict[str, t.Any]] = []\n        rules_matched: t.List[t.Dict[str, t.Any]] = []\n\n        if not match_rule.expanded_rules:\n            raise ValueError(\"There is no expanded rules to test against.\")\n        for rule in match_rule.expanded_rules:\n            rules_found.append(False)\n            for existing_rule in self.expanded_rules:\n                missing = False\n                for attr in attrs:\n                    # Examples of obj are match_rule.src_ip, match_rule.dst_port\n                    rule_value = rule[attr]\n                    existing_value = existing_rule[attr]\n                    # Examples of getter are self.match_src_ip, self.match_dst_port\n                    getter = getattr(self, f\"match_{attr}\")(existing_value, rule_value)\n                    if not getter and getter is not None:\n                        missing = True\n                        break\n                # If the loop gets through with each existing rule not flagging\n                # the `missing` value, we know everything was matched, and the rule has\n                # found a complete match, we can break out of the loop at this point.\n                if not missing:\n                    rules_found[-1] = True\n                    break\n            detailed_info = {\n                \"existing_rule_product\": existing_rule,  # pylint: disable=undefined-loop-variable\n                \"match_rule\": match_rule.processed,\n                \"existing_rule\": self.processed,\n            }\n            if rules_found[-1]:\n                detailed_info[\"match_rule_product\"] = rule\n                rules_matched.append(detailed_info)\n            else:\n                rules_unmatched.append(detailed_info)\n        return {\"rules_matched\": rules_matched, \"rules_unmatched\": rules_unmatched}\n\n    def match(self, match_rule: \"ACLRule\") -&gt; bool:\n        \"\"\"Simple boolean way of verifying match or not.\n\n        Args:\n            match_rule: The rule which you are testing against.\n\n        Returns:\n            A boolean if there was a full match or not.\n        \"\"\"\n        details = self.match_details(match_rule)\n        return not bool(details[\"rules_unmatched\"])\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Set repr of the object to be sane.\"\"\"\n        output = []\n        for attr in self.attrs:\n            if self.processed.get(attr):\n                output.append(f\"{attr}: {self.processed[attr]}\")\n        return \", \".join(output)\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.__init__","title":"<code>__init__(data, *args, **kwargs)</code>","text":"<p>Initialize and load data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>A dictionary with string keys and either string or list of string values</p> required <code>args</code> <code>Any</code> <p>Additional positional arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.acl import ACLRule\n&gt;&gt;&gt;\n&gt;&gt;&gt; acl_data = dict(\n...     name=\"Check no match\",\n...     src_ip=[\"10.1.1.1\"],\n...     dst_ip=\"172.16.0.10\",\n...     dst_port=\"tcp/www-http\",\n...     action=\"permit\",\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; rule = ACLRule(acl_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; rule.expanded_rules\n[{'name': 'Check no match', 'src_ip': '10.1.1.1', 'dst_ip': '172.16.0.10', 'dst_port': '6/80', 'action': 'permit'}]\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/acl.py</code> <pre><code>def __init__(self, data: t.Any, *args: t.Any, **kwargs: t.Any):  # pylint: disable=unused-argument\n    \"\"\"Initialize and load data.\n\n    Args:\n        data: A dictionary with string keys and either string or list of string values\n        args: Additional positional arguments.\n        kwargs: Additional keyword arguments.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.acl import ACLRule\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; acl_data = dict(\n        ...     name=\"Check no match\",\n        ...     src_ip=[\"10.1.1.1\"],\n        ...     dst_ip=\"172.16.0.10\",\n        ...     dst_port=\"tcp/www-http\",\n        ...     action=\"permit\",\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; rule = ACLRule(acl_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; rule.expanded_rules\n        [{'name': 'Check no match', 'src_ip': '10.1.1.1', 'dst_ip': '172.16.0.10', 'dst_port': '6/80', 'action': 'permit'}]\n        &gt;&gt;&gt;\n    \"\"\"\n    self.processed: t.Dict[str, str] = {}\n    self.data = data\n    self.load_data()\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.__repr__","title":"<code>__repr__()</code>","text":"<p>Set repr of the object to be sane.</p> Source code in <code>netutils/acl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Set repr of the object to be sane.\"\"\"\n    output = []\n    for attr in self.attrs:\n        if self.processed.get(attr):\n            output.append(f\"{attr}: {self.processed[attr]}\")\n    return \", \".join(output)\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.enforce","title":"<code>enforce()</code>","text":"<p>Run through any method that startswith('enforce_') and run that method.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of dictionaries that explains the results of the enforcement.</p> Source code in <code>netutils/acl.py</code> <pre><code>def enforce(self) -&gt; t.List[t.Dict[str, t.Any]]:\n    \"\"\"Run through any method that startswith('enforce_') and run that method.\n\n    Returns:\n        A list of dictionaries that explains the results of the enforcement.\n    \"\"\"\n    if self.order_enforce:\n        method_order = self.order_enforce\n    else:\n        method_order = dir(self)\n    results = []\n    for name in method_order:\n        if name.startswith(\"enforce_\"):\n            result = getattr(self, name)()\n            if not result:\n                continue\n            if result and isinstance(result, dict):\n                results.append(result)\n            elif result and isinstance(result, list):\n                results.extend(result)\n    return results\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.enforce_matrix","title":"<code>enforce_matrix()</code>","text":"<p>A simple <code>matrix</code> or grid style check of a rule.</p> <p>Returns:</p> Type Description <code>Union[List[Dict[str, Any]], None]</code> <p>A list of dictionaries that explains the results of the matrix being enforced.</p> Source code in <code>netutils/acl.py</code> <pre><code>def enforce_matrix(self) -&gt; t.Union[t.List[t.Dict[str, t.Any]], None]:\n    \"\"\"A simple `matrix` or grid style check of a rule.\n\n    Returns:\n        A list of dictionaries that explains the results of the matrix being enforced.\n    \"\"\"\n    if not self.matrix_enforced:\n        return None\n    if not self.matrix:\n        raise ValueError(\"You must set a matrix dictionary to use the matrix feature.\")\n    if not self.matrix_definition:\n        raise ValueError(\"You must set a matrix definition dictionary to use the matrix feature.\")\n    actions = []\n    for rule in self.expanded_rules:\n        source = rule[\"src_ip\"]\n        destination = rule[\"dst_ip\"]\n        port = rule[\"dst_port\"]\n        src_zone = \"\"\n        dst_zone = \"\"\n        as_tuple = (source, destination, port)\n        for zone, ips in self.matrix_definition.items():\n            if is_ip_within(source, ips):\n                src_zone = zone\n            if is_ip_within(destination, ips):\n                dst_zone = zone\n        if port in self.matrix.get(src_zone, {}).get(dst_zone, {}).get(\"allow\", []):\n            actions.append({\"obj\": as_tuple, \"action\": \"allow\"})\n        elif port in self.matrix.get(src_zone, {}).get(dst_zone, {}).get(\"notify\", []):\n            actions.append({\"obj\": as_tuple, \"action\": \"notify\"})\n        else:\n            actions.append({\"obj\": as_tuple, \"action\": \"deny\"})\n    return actions\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.input_data_check","title":"<code>input_data_check()</code>","text":"<p>Verify the input data against the specified JSONSchema or using a simple dictionary check.</p> Source code in <code>netutils/acl.py</code> <pre><code>def input_data_check(self) -&gt; None:\n    \"\"\"Verify the input data against the specified JSONSchema or using a simple dictionary check.\"\"\"\n    return _check_schema(self.data, self.input_data_schema, self.input_data_verify)\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.load_data","title":"<code>load_data()</code>","text":"<p>Load the data into the rule while verifying input data, result data, and processing data.</p> Source code in <code>netutils/acl.py</code> <pre><code>def load_data(self) -&gt; None:\n    \"\"\"Load the data into the rule while verifying input data, result data, and processing data.\"\"\"\n    self.input_data_check()\n    for attr in self.attrs:\n        if not self.data.get(attr):\n            continue\n        if hasattr(self, f\"process_{attr}\"):\n            proccessor = getattr(self, f\"process_{attr}\")\n            _attr_data = proccessor(self.data[attr])\n        else:\n            _attr_data = self.data[attr]\n        self.processed[attr] = _attr_data\n        setattr(self, attr, _attr_data)\n    self.result_data_check()\n    self.validate()\n    self.expanded_rules = _cartesian_product(self.processed)\n    if self.filter_same_ip:\n        self.expanded_rules = [item for item in self.expanded_rules if item[\"dst_ip\"] != item[\"src_ip\"]]\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match","title":"<code>match(match_rule)</code>","text":"<p>Simple boolean way of verifying match or not.</p> <p>Parameters:</p> Name Type Description Default <code>match_rule</code> <code>ACLRule</code> <p>The rule which you are testing against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean if there was a full match or not.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match(self, match_rule: \"ACLRule\") -&gt; bool:\n    \"\"\"Simple boolean way of verifying match or not.\n\n    Args:\n        match_rule: The rule which you are testing against.\n\n    Returns:\n        A boolean if there was a full match or not.\n    \"\"\"\n    details = self.match_details(match_rule)\n    return not bool(details[\"rules_unmatched\"])\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_action","title":"<code>match_action(existing_action, check_action)</code>","text":"<p>Match the action for equality.</p> <p>Parameters:</p> Name Type Description Default <code>existing_action</code> <code>str</code> <p>The existing action value to be matched.</p> required <code>check_action</code> <code>str</code> <p>The action value to be checked against the existing action.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>existing_action</code> matches <code>check_action</code>, False otherwise.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_action(self, existing_action: str, check_action: str) -&gt; bool:\n    \"\"\"Match the action for equality.\n\n    Args:\n        existing_action: The existing action value to be matched.\n        check_action: The action value to be checked against the existing action.\n\n    Returns:\n        True if `existing_action` matches `check_action`, False otherwise.\n    \"\"\"\n    return existing_action == check_action\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_details","title":"<code>match_details(match_rule)</code>","text":"<p>Verbose way of verifying match details.</p> <p>Parameters:</p> Name Type Description Default <code>match_rule</code> <code>ACLRule</code> <p>The rule which you are testing against.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary with root keys of <code>rules_matched</code> and <code>rules_matched</code>.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_details(self, match_rule: \"ACLRule\") -&gt; t.Dict[str, t.Any]:  # pylint: disable=too-many-locals\n    \"\"\"Verbose way of verifying match details.\n\n    Args:\n        match_rule: The rule which you are testing against.\n\n    Returns:\n        A dictionary with root keys of `rules_matched` and `rules_matched`.\n    \"\"\"\n    attrs = []\n    for name in dir(self):\n        if name.startswith(\"match_\"):\n            obj_name = name[len(\"match_\") :]  # noqa: E203\n            # When an attribute is not defined, can skip it\n            if not hasattr(match_rule, obj_name):\n                continue\n            attrs.append(obj_name)\n\n    rules_found: t.List[bool] = []\n    rules_unmatched: t.List[t.Dict[str, t.Any]] = []\n    rules_matched: t.List[t.Dict[str, t.Any]] = []\n\n    if not match_rule.expanded_rules:\n        raise ValueError(\"There is no expanded rules to test against.\")\n    for rule in match_rule.expanded_rules:\n        rules_found.append(False)\n        for existing_rule in self.expanded_rules:\n            missing = False\n            for attr in attrs:\n                # Examples of obj are match_rule.src_ip, match_rule.dst_port\n                rule_value = rule[attr]\n                existing_value = existing_rule[attr]\n                # Examples of getter are self.match_src_ip, self.match_dst_port\n                getter = getattr(self, f\"match_{attr}\")(existing_value, rule_value)\n                if not getter and getter is not None:\n                    missing = True\n                    break\n            # If the loop gets through with each existing rule not flagging\n            # the `missing` value, we know everything was matched, and the rule has\n            # found a complete match, we can break out of the loop at this point.\n            if not missing:\n                rules_found[-1] = True\n                break\n        detailed_info = {\n            \"existing_rule_product\": existing_rule,  # pylint: disable=undefined-loop-variable\n            \"match_rule\": match_rule.processed,\n            \"existing_rule\": self.processed,\n        }\n        if rules_found[-1]:\n            detailed_info[\"match_rule_product\"] = rule\n            rules_matched.append(detailed_info)\n        else:\n            rules_unmatched.append(detailed_info)\n    return {\"rules_matched\": rules_matched, \"rules_unmatched\": rules_unmatched}\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_dst_ip","title":"<code>match_dst_ip(existing_ip, check_ip)</code>","text":"<p>Determined if destination <code>check_ip</code> is within `existing_ip.</p> <p>Parameters:</p> Name Type Description Default <code>existing_ip</code> <code>str</code> <p>The existing destination IP address or IP range to be matched against.</p> required <code>check_ip</code> <code>str</code> <p>The destination IP address to be checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>check_ip</code> is within the range of <code>existing_ip</code>, False otherwise.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_dst_ip(self, existing_ip: str, check_ip: str) -&gt; bool:\n    \"\"\"Determined if destination `check_ip` is within `existing_ip.\n\n    Args:\n        existing_ip: The existing destination IP address or IP range to be matched against.\n        check_ip: The destination IP address to be checked.\n\n    Returns:\n        True if `check_ip` is within the range of `existing_ip`, False otherwise.\n    \"\"\"\n    return is_ip_within(check_ip, existing_ip)\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_dst_port","title":"<code>match_dst_port(existing_port, check_port)</code>","text":"<p>Match the destination port for equality.</p> <p>Parameters:</p> Name Type Description Default <code>existing_port</code> <code>str</code> <p>The existing destination port value to be matched.</p> required <code>check_port</code> <code>str</code> <p>The destination port value to be checked against the existing port.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>existing_port</code> matches <code>check_port</code>, False otherwise.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_dst_port(self, existing_port: str, check_port: str) -&gt; bool:\n    \"\"\"Match the destination port for equality.\n\n    Args:\n        existing_port: The existing destination port value to be matched.\n        check_port: The destination port value to be checked against the existing port.\n\n    Returns:\n        True if `existing_port` matches `check_port`, False otherwise.\n    \"\"\"\n    return existing_port == check_port\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_dst_zone","title":"<code>match_dst_zone(existing_dst_zone, check_dst_zone)</code>","text":"<p>Match the destination zone for equality.</p> <p>Parameters:</p> Name Type Description Default <code>existing_dst_zone</code> <code>str</code> <p>The existing destination zone value to be matched.</p> required <code>check_dst_zone</code> <code>str</code> <p>The destination zone value to be checked against the existing zone.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>existing_dst_zone</code> matches <code>check_dst_zone</code>, False otherwise.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_dst_zone(self, existing_dst_zone: str, check_dst_zone: str) -&gt; bool:\n    \"\"\"Match the destination zone for equality.\n\n    Args:\n        existing_dst_zone: The existing destination zone value to be matched.\n        check_dst_zone: The destination zone value to be checked against the existing zone.\n\n    Returns:\n        True if `existing_dst_zone` matches `check_dst_zone`, False otherwise.\n    \"\"\"\n    return existing_dst_zone == check_dst_zone\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_src_ip","title":"<code>match_src_ip(existing_ip, check_ip)</code>","text":"<p>Determined if source <code>check_ip</code> is within <code>existing_ip</code>.</p> <p>Parameters:</p> Name Type Description Default <code>existing_ip</code> <code>str</code> <p>The existing source IP address or IP range to be matched against.</p> required <code>check_ip</code> <code>str</code> <p>The source IP address to be checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>check_ip</code> is within the range of <code>existing_ip</code>, False otherwise.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_src_ip(self, existing_ip: str, check_ip: str) -&gt; bool:\n    \"\"\"Determined if source `check_ip` is within `existing_ip`.\n\n    Args:\n        existing_ip: The existing source IP address or IP range to be matched against.\n        check_ip: The source IP address to be checked.\n\n    Returns:\n        True if `check_ip` is within the range of `existing_ip`, False otherwise.\n    \"\"\"\n    return is_ip_within(check_ip, existing_ip)\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.match_src_zone","title":"<code>match_src_zone(existing_src_zone, check_src_zone)</code>","text":"<p>Match the source zone for equality.</p> <p>Parameters:</p> Name Type Description Default <code>existing_src_zone</code> <code>str</code> <p>The existing source zone value to be matched.</p> required <code>check_src_zone</code> <code>str</code> <p>The source zone value to be checked against the existing zone.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>existing_src_zone</code> matches <code>check_src_zone</code>, False otherwise.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_src_zone(self, existing_src_zone: str, check_src_zone: str) -&gt; bool:\n    \"\"\"Match the source zone for equality.\n\n    Args:\n        existing_src_zone: The existing source zone value to be matched.\n        check_src_zone: The source zone value to be checked against the existing zone.\n\n    Returns:\n        True if `existing_src_zone` matches `check_src_zone`, False otherwise.\n    \"\"\"\n    return existing_src_zone == check_src_zone\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.process_dst_port","title":"<code>process_dst_port(dst_port)</code>","text":"<p>Convert port and protocol information.</p> <p>Method supports a single format of <code>{protocol}/{port}</code>, and will translate the protocol for all IANA defined protocols. The port will be translated for TCP and UDP ports only. For all other protocols should use port of 0, e.g. <code>ICMP/0</code> for ICMP or <code>50/0</code> for ESP. Similarly, IANA defines the port mappings, while these are mostly staying unchanged, but sourced from https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv.</p> Source code in <code>netutils/acl.py</code> <pre><code>def process_dst_port(self, dst_port: t.Any) -&gt; t.Union[t.List[str], None]:  # pylint: disable=inconsistent-return-statements\n    \"\"\"Convert port and protocol information.\n\n    Method supports a single format of `{protocol}/{port}`, and will translate the\n    protocol for all IANA defined protocols. The port will be translated for TCP and\n    UDP ports only. For all other protocols should use port of 0, e.g. `ICMP/0` for ICMP\n    or `50/0` for ESP. Similarly, IANA defines the port mappings, while these are mostly\n    staying unchanged, but sourced from\n    https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv.\n    \"\"\"\n    output = []\n    if not self.dst_port_process:\n        return None\n    if not isinstance(dst_port, list):\n        dst_port = [dst_port]\n    for item in dst_port:\n        protocol = item.split(\"/\")[0]\n        port = item.split(\"/\")[1]\n        if protocol.isalpha():\n            if not PROTO_NAME_TO_NUM.get(protocol.upper()):\n                raise ValueError(\n                    f\"Protocol {protocol} was not found in netutils.protocol_mapper.PROTO_NAME_TO_NUM.\"\n                )\n            protocol = PROTO_NAME_TO_NUM[protocol.upper()]\n        # test port[0] vs port, since dashes do not count, e.g. www-http\n        if int(protocol) == 6 and port[0].isalpha():\n            if not TCP_NAME_TO_NUM.get(port.upper()):\n                raise ValueError(f\"Port {port} was not found in netutils.protocol_mapper.TCP_NAME_TO_NUM.\")\n            port = TCP_NAME_TO_NUM[port.upper()]\n        if int(protocol) == 17 and port[0].isalpha():\n            if not UDP_NAME_TO_NUM.get(port.upper()):\n                raise ValueError(f\"Port {port} was not found in netutils.protocol_mapper.UDP_NAME_TO_NUM.\")\n            port = UDP_NAME_TO_NUM[port.upper()]\n        output.append(f\"{protocol}/{port}\")\n    return output\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.result_data_check","title":"<code>result_data_check()</code>","text":"<p>Verify the result data against the specified JSONSchema or using a simple dictionary check.</p> Source code in <code>netutils/acl.py</code> <pre><code>def result_data_check(self) -&gt; None:\n    \"\"\"Verify the result data against the specified JSONSchema or using a simple dictionary check.\"\"\"\n    return _check_schema(self.processed, self.result_data_schema, self.result_data_verify)\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRule.validate","title":"<code>validate()</code>","text":"<p>Run through any method that startswith('validate_') and run that method.</p> Source code in <code>netutils/acl.py</code> <pre><code>def validate(self) -&gt; t.Any:\n    \"\"\"Run through any method that startswith('validate_') and run that method.\"\"\"\n    if self.order_validate:\n        method_order = self.order_validate\n    else:\n        method_order = dir(self)\n    results = []\n    for name in method_order:\n        if name.startswith(\"validate_\"):\n            result = getattr(self, name)()\n            if not result:\n                continue\n            if result and isinstance(result, dict):\n                results.append(result)\n            elif result and isinstance(result, list):\n                results.extend(result)\n    return results\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRules","title":"<code>ACLRules</code>","text":"<p>Class to help match multiple ACLRule objects.</p> Source code in <code>netutils/acl.py</code> <pre><code>class ACLRules:\n    \"\"\"Class to help match multiple ACLRule objects.\"\"\"\n\n    class_obj = ACLRule\n\n    def __init__(self, data: t.Any, *args: t.Any, **kwargs: t.Any):  # pylint: disable=unused-argument\n        \"\"\"Class to help match multiple ACLRule.\n\n        Args:\n            data: A list of `ACLRule` rules.\n            args: Additional positional arguments.\n            kwargs: Additional keyword arguments.\n        \"\"\"\n        self.data: t.Any = data\n        self.rules: t.List[t.Any] = []\n        self.load_data()\n\n    def load_data(self) -&gt; None:\n        \"\"\"Load the data for multiple rules.\"\"\"\n        for item in self.data:\n            self.rules.append(self.class_obj(item))\n\n    def match(self, rule: ACLRule) -&gt; str:\n        \"\"\"Check the rules loaded in `load_data` match against a new `rule`.\n\n        Args:\n            rule: The `ACLRule` rule to test against the list of `ACLRule`s loaded in initiation.\n\n        Returns:\n            The response from the rule that matched, or `deny` by default.\n        \"\"\"\n        for item in self.rules:\n            if item.match(self.class_obj(rule)):\n                return str(item.action)\n        return str(item.deny)  # pylint: disable=undefined-loop-variable\n\n    def match_details(self, rule: ACLRule) -&gt; t.Any:\n        \"\"\"Verbosely check the rules loaded in `load_data` match against a new `rule`.\n\n        Args:\n            rule: The `ACLRule` rule to test against the list of `ACLRule`s loaded in initiation.\n\n        Returns:\n            The details from the `ACLRule.match_details` results.\n        \"\"\"\n        output = []\n        for item in self.rules:\n            output.append(item.match_details(self.class_obj(rule)))\n        return output\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRules.__init__","title":"<code>__init__(data, *args, **kwargs)</code>","text":"<p>Class to help match multiple ACLRule.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>A list of <code>ACLRule</code> rules.</p> required <code>args</code> <code>Any</code> <p>Additional positional arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>netutils/acl.py</code> <pre><code>def __init__(self, data: t.Any, *args: t.Any, **kwargs: t.Any):  # pylint: disable=unused-argument\n    \"\"\"Class to help match multiple ACLRule.\n\n    Args:\n        data: A list of `ACLRule` rules.\n        args: Additional positional arguments.\n        kwargs: Additional keyword arguments.\n    \"\"\"\n    self.data: t.Any = data\n    self.rules: t.List[t.Any] = []\n    self.load_data()\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRules.load_data","title":"<code>load_data()</code>","text":"<p>Load the data for multiple rules.</p> Source code in <code>netutils/acl.py</code> <pre><code>def load_data(self) -&gt; None:\n    \"\"\"Load the data for multiple rules.\"\"\"\n    for item in self.data:\n        self.rules.append(self.class_obj(item))\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRules.match","title":"<code>match(rule)</code>","text":"<p>Check the rules loaded in <code>load_data</code> match against a new <code>rule</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>ACLRule</code> <p>The <code>ACLRule</code> rule to test against the list of <code>ACLRule</code>s loaded in initiation.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The response from the rule that matched, or <code>deny</code> by default.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match(self, rule: ACLRule) -&gt; str:\n    \"\"\"Check the rules loaded in `load_data` match against a new `rule`.\n\n    Args:\n        rule: The `ACLRule` rule to test against the list of `ACLRule`s loaded in initiation.\n\n    Returns:\n        The response from the rule that matched, or `deny` by default.\n    \"\"\"\n    for item in self.rules:\n        if item.match(self.class_obj(rule)):\n            return str(item.action)\n    return str(item.deny)  # pylint: disable=undefined-loop-variable\n</code></pre>"},{"location":"dev/code_reference/acl.html#netutils.acl.ACLRules.match_details","title":"<code>match_details(rule)</code>","text":"<p>Verbosely check the rules loaded in <code>load_data</code> match against a new <code>rule</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>ACLRule</code> <p>The <code>ACLRule</code> rule to test against the list of <code>ACLRule</code>s loaded in initiation.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The details from the <code>ACLRule.match_details</code> results.</p> Source code in <code>netutils/acl.py</code> <pre><code>def match_details(self, rule: ACLRule) -&gt; t.Any:\n    \"\"\"Verbosely check the rules loaded in `load_data` match against a new `rule`.\n\n    Args:\n        rule: The `ACLRule` rule to test against the list of `ACLRule`s loaded in initiation.\n\n    Returns:\n        The details from the `ACLRule.match_details` results.\n    \"\"\"\n    output = []\n    for item in self.rules:\n        output.append(item.match_details(self.class_obj(rule)))\n    return output\n</code></pre>"},{"location":"dev/code_reference/asn.html","title":"BGP ASNs","text":""},{"location":"dev/code_reference/asn.html#netutils.asn","title":"<code>netutils.asn</code>","text":"<p>Functions for working with BGP ASNs.</p>"},{"location":"dev/code_reference/asn.html#netutils.asn.asn_to_int","title":"<code>asn_to_int(asplain)</code>","text":"<p>Convert AS Number to standardized asplain notation as an integer.</p> <p>Parameters:</p> Name Type Description Default <code>asplain</code> <code>str</code> <p>An <code>asplain</code> notated BGP ASN with community.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Integer value within of the given asplain value provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.asn import asn_to_int\n&gt;&gt;&gt; asn_to_int(\"65000\")\n65000\n&gt;&gt;&gt; asn_to_int(\"65000.111\")\n4259840111\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/asn.py</code> <pre><code>def asn_to_int(asplain: str) -&gt; int:\n    \"\"\"Convert AS Number to standardized asplain notation as an integer.\n\n    Args:\n        asplain: An `asplain` notated BGP ASN with community.\n\n    Returns:\n        Integer value within of the given asplain value provided.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.asn import asn_to_int\n        &gt;&gt;&gt; asn_to_int(\"65000\")\n        65000\n        &gt;&gt;&gt; asn_to_int(\"65000.111\")\n        4259840111\n        &gt;&gt;&gt;\n    \"\"\"\n    # ASN is in asdot notation\n    if \".\" in asplain:\n        asn_list = asplain.split(\".\")\n        asn = int(f\"{int(asn_list[0]):016b}{int(asn_list[1]):016b}\", 2)\n        return asn\n    return int(asplain)\n</code></pre>"},{"location":"dev/code_reference/asn.html#netutils.asn.int_to_asdot","title":"<code>int_to_asdot(asn_int)</code>","text":"<p>Convert integer to standardized asdot notation for BGP ASN.</p> <p>Parameters:</p> Name Type Description Default <code>asn_int</code> <code>int</code> <p>Integer value of the BGP ASN.</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>asdot</code> notated BGP ASN as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.asn import int_to_asdot\n&gt;&gt;&gt; int_to_asdot(65000)\n'65000'\n&gt;&gt;&gt; int_to_asdot(4259840111)\n'65000.111'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/asn.py</code> <pre><code>def int_to_asdot(asn_int: int) -&gt; str:\n    \"\"\"Convert integer to standardized asdot notation for BGP ASN.\n\n    Args:\n        asn_int: Integer value of the BGP ASN.\n\n    Returns:\n        `asdot` notated BGP ASN as a string.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.asn import int_to_asdot\n        &gt;&gt;&gt; int_to_asdot(65000)\n        '65000'\n        &gt;&gt;&gt; int_to_asdot(4259840111)\n        '65000.111'\n        &gt;&gt;&gt;\n    \"\"\"\n    if isinstance(asn_int, str):\n        asn_int = int(asn_int)\n    if asn_int &gt; 2**32 - 1 or asn_int &lt; 1:\n        raise ValueError(f\"`{str(asn_int)}` is not within range of 1 - 2^32-1\")\n    if asn_int &gt;= 2**16:\n        asn1 = asn_int &gt;&gt; 16\n        asn2 = asn_int &amp; ((1 &lt;&lt; 16) - 1)\n        return f\"{asn1}.{asn2}\"\n    return str(asn_int)\n</code></pre>"},{"location":"dev/code_reference/bandwidth.html","title":"Bandwidth","text":""},{"location":"dev/code_reference/bandwidth.html#netutils.bandwidth","title":"<code>netutils.bandwidth</code>","text":"<p>Functions for performing bandwidth calculations.</p>"},{"location":"dev/code_reference/bandwidth.html#netutils.bandwidth.bits_to_name","title":"<code>bits_to_name(speed, nbr_decimal=0)</code>","text":"<p>Method to convert an int value for speed int bits to the name value.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>int</code> <p>Speed in bits to be converted.</p> required <code>nbr_decimal</code> <code>Optional[int]</code> <p>Precision of end result, ie number of decimal points to round to. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>Name value for speed in bits</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.bandwidth import bits_to_name\n&gt;&gt;&gt; bits_to_name(125000)\n'125Kbps'\n&gt;&gt;&gt; bits_to_name(1000000000)\n'1Gbps'\n</code></pre> Source code in <code>netutils/bandwidth.py</code> <pre><code>def bits_to_name(  # pylint: disable=too-many-branches,too-many-return-statements\n    speed: int, nbr_decimal: t.Optional[int] = 0\n) -&gt; str:\n    \"\"\"Method to convert an int value for speed int bits to the name value.\n\n    Args:\n        speed: Speed in bits to be converted.\n        nbr_decimal: Precision of end result, ie number of decimal points to round to. Defaults to 0.\n\n    Returns:\n        Name value for speed in bits\n\n    Examples:\n        &gt;&gt;&gt; from netutils.bandwidth import bits_to_name\n        &gt;&gt;&gt; bits_to_name(125000)\n        '125Kbps'\n        &gt;&gt;&gt; bits_to_name(1000000000)\n        '1Gbps'\n    \"\"\"\n    if not isinstance(speed, int):\n        raise ValueError(f\"Speed of {speed} was not a valid speed integer.\")\n    if nbr_decimal == 0:\n        nbr_decimal = None\n\n    for bit_type, val in BITS_MAPPING.items():\n        if val[\"low\"] &lt;= speed &lt; val[\"high\"]:\n            if val[\"low\"] == 0:\n                return f\"{round(speed, nbr_decimal)}{bit_type}\"\n            return f\"{round(speed / val['low'], nbr_decimal)}{bit_type}\"\n    raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n</code></pre>"},{"location":"dev/code_reference/bandwidth.html#netutils.bandwidth.bytes_to_name","title":"<code>bytes_to_name(speed, nbr_decimal=0)</code>","text":"<p>Method to convert an int value for speed in bytes to the name value.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Speed in bytes to be converted.</p> required <code>nbr_decimal</code> <code>int</code> <p>Precision of end result, ie number of decimal points to round to. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>Name value for speed in bytes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.bandwidth import bytes_to_name\n&gt;&gt;&gt; bytes_to_name(10000.0)\n'10.0KBps'\n&gt;&gt;&gt; bytes_to_name(10000000.0)\n'10.0MBps'\n</code></pre> Source code in <code>netutils/bandwidth.py</code> <pre><code>def bytes_to_name(speed: float, nbr_decimal: int = 0) -&gt; str:\n    \"\"\"Method to convert an int value for speed in bytes to the name value.\n\n    Args:\n        speed: Speed in bytes to be converted.\n        nbr_decimal: Precision of end result, ie number of decimal points to round to. Defaults to 0.\n\n    Returns:\n        Name value for speed in bytes\n\n    Examples:\n        &gt;&gt;&gt; from netutils.bandwidth import bytes_to_name\n        &gt;&gt;&gt; bytes_to_name(10000.0)\n        '10.0KBps'\n        &gt;&gt;&gt; bytes_to_name(10000000.0)\n        '10.0MBps'\n    \"\"\"\n    if not isinstance(speed, float):\n        raise ValueError(f\"Speed of {speed} was not a valid speed.\")\n\n    byte_speed = speed * 8\n    for bit_type, val in BYTES_MAPPING.items():\n        if val[\"low\"] &lt;= speed &lt; val[\"high\"]:\n            try:\n                return f\"{round(byte_speed / val['low'], nbr_decimal)}{bit_type}\"\n            except ZeroDivisionError:\n                return f\"{round(byte_speed, nbr_decimal)}{bit_type}\"\n    raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n</code></pre>"},{"location":"dev/code_reference/bandwidth.html#netutils.bandwidth.name_to_bits","title":"<code>name_to_bits(speed)</code>","text":"<p>Method to convert a short bandwidth name to int value in bps.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>str</code> <p>Bandwidth to be converted like <code>100Gbps</code> to bps.</p> required <p>Returns:</p> Type Description <code>int</code> <p>value of bandwidth to be converted to bps</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.bandwidth import name_to_bits\n&gt;&gt;&gt; name_to_bits(\"10Gbps\")\n10000000000\n&gt;&gt;&gt; name_to_bits(\"33.6Kbps\")\n33600\n&gt;&gt;&gt; name_to_bits(\"2.5Gbps\")\n2500000000\n&gt;&gt;&gt; name_to_bits('100 MB')\n800000000\n</code></pre> Source code in <code>netutils/bandwidth.py</code> <pre><code>def name_to_bits(speed: str) -&gt; int:\n    \"\"\"Method to convert a short bandwidth name to int value in bps.\n\n    Args:\n        speed: Bandwidth to be converted like `100Gbps` to bps.\n\n    Returns:\n        value of bandwidth to be converted to bps\n\n    Examples:\n        &gt;&gt;&gt; from netutils.bandwidth import name_to_bits\n        &gt;&gt;&gt; name_to_bits(\"10Gbps\")\n        10000000000\n        &gt;&gt;&gt; name_to_bits(\"33.6Kbps\")\n        33600\n        &gt;&gt;&gt; name_to_bits(\"2.5Gbps\")\n        2500000000\n        &gt;&gt;&gt; name_to_bits('100 MB')\n        800000000\n    \"\"\"\n    if not isinstance(speed, str):\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n    speed = _normalize_bw(speed)\n    match = re.match(r\"([0-9.]+)([A-Z]?[bB]ps)\", speed)\n    if not match:\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n    bit_speed, bit_name = match.groups()\n    if bit_name in BITS_MAPPING.keys():\n        return int(float(bit_speed) * BITS_MAPPING[bit_name][\"low\"])\n    if bit_name in BYTES_MAPPING.keys():\n        return int(float(bit_speed) * BYTES_MAPPING[bit_name][\"low\"])\n    raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n</code></pre>"},{"location":"dev/code_reference/bandwidth.html#netutils.bandwidth.name_to_bytes","title":"<code>name_to_bytes(speed)</code>","text":"<p>Method to convert a short bandwidth name to float value in Bps.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>str</code> <p>Bandwidth to be converted like <code>100GBps</code> to Bps.</p> required <p>Returns:</p> Type Description <code>float</code> <p>value of bandwidth to be converted to Bps</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.bandwidth import name_to_bytes\n&gt;&gt;&gt; name_to_bytes(\"10Gbps\")\n1250000000.0\n&gt;&gt;&gt; name_to_bytes(\"100Mbps\")\n12500000.0\n&gt;&gt;&gt; name_to_bytes(\"100GBps\")\n100000000000.0\n&gt;&gt;&gt; name_to_bytes('100 GB')\n100000000000.0\n</code></pre> Source code in <code>netutils/bandwidth.py</code> <pre><code>def name_to_bytes(speed: str) -&gt; float:\n    \"\"\"Method to convert a short bandwidth name to float value in Bps.\n\n    Args:\n        speed: Bandwidth to be converted like `100GBps` to Bps.\n\n    Returns:\n        value of bandwidth to be converted to Bps\n\n    Examples:\n        &gt;&gt;&gt; from netutils.bandwidth import name_to_bytes\n        &gt;&gt;&gt; name_to_bytes(\"10Gbps\")\n        1250000000.0\n        &gt;&gt;&gt; name_to_bytes(\"100Mbps\")\n        12500000.0\n        &gt;&gt;&gt; name_to_bytes(\"100GBps\")\n        100000000000.0\n        &gt;&gt;&gt; name_to_bytes('100 GB')\n        100000000000.0\n    \"\"\"\n    if not isinstance(speed, str):\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n    speed = _normalize_bw(speed)\n    match = re.match(r\"([0-9.]+)([A-Z]?[bB]ps)\", speed)\n    if not match:\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n    byte_speed, byte_name = match.groups()\n    if byte_name in BYTES_MAPPING.keys():\n        return (float(byte_speed) * BYTES_MAPPING[byte_name][\"low\"]) / 8\n    if byte_name in BITS_MAPPING.keys():\n        return (float(byte_speed) * BITS_MAPPING[byte_name][\"low\"]) * 0.125\n    raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n</code></pre>"},{"location":"dev/code_reference/bandwidth.html#netutils.bandwidth.name_to_name","title":"<code>name_to_name(speed, speed_type, nbr_decimal=0)</code>","text":"<p>Method to convert a short bandwidth name to another bandwidth name.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>str</code> <p>Bandwidth to be converted like <code>100GBps</code>.</p> required <code>speed_type</code> <code>str</code> <p>Name to convert the bandwidth to like <code>MBps</code>.</p> required <code>nbr_decimal</code> <code>int</code> <p>Precision of end result, ie number of decimal points to round to. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The named value which user wishes to return to.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.bandwidth import name_to_name\n&gt;&gt;&gt; name_to_name(\"10Gbps\", \"Kbps\")\n'10000000.0Kbps'\n&gt;&gt;&gt; name_to_name(\"10GBps\", \"Kbps\")\n'80000000.0Kbps'\n&gt;&gt;&gt; name_to_name(\"10KBps\", \"Gbps\", 4)\n'0.0001Gbps'\n</code></pre> Source code in <code>netutils/bandwidth.py</code> <pre><code>def name_to_name(speed: str, speed_type: str, nbr_decimal: int = 0) -&gt; str:\n    \"\"\"Method to convert a short bandwidth name to another bandwidth name.\n\n    Args:\n        speed: Bandwidth to be converted like `100GBps`.\n        speed_type: Name to convert the bandwidth to like `MBps`.\n        nbr_decimal: Precision of end result, ie number of decimal points to round to. Defaults to 0.\n\n    Returns:\n        The named value which user wishes to return to.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.bandwidth import name_to_name\n        &gt;&gt;&gt; name_to_name(\"10Gbps\", \"Kbps\")\n        '10000000.0Kbps'\n        &gt;&gt;&gt; name_to_name(\"10GBps\", \"Kbps\")\n        '80000000.0Kbps'\n        &gt;&gt;&gt; name_to_name(\"10KBps\", \"Gbps\", 4)\n        '0.0001Gbps'\n    \"\"\"\n    if not isinstance(speed, str):\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n    speed = speed.replace(\" \", \"\")\n    match = re.match(r\"([0-9.]+)([A-Z]?[bB]ps)\", speed)\n    if not match:\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n    _, name = match.groups()\n    # Find out if the `original` value is a bit or a byte\n    if name in BYTES_MAPPING.keys():\n        bit_value = name_to_bytes(speed) * 8\n    elif name in BITS_MAPPING.keys():\n        bit_value = name_to_bits(speed)\n    else:\n        raise ValueError(f\"Speed of {speed} was not a valid speed representation.\")\n\n    # Find out if the `expected` value is a bit or a byte\n    if speed_type in BYTES_MAPPING.keys():\n        bit_multiplier = BYTES_MAPPING[speed_type][\"low\"]\n    elif speed_type in BITS_MAPPING.keys():\n        bit_multiplier = BITS_MAPPING[speed_type][\"low\"]\n    else:\n        raise ValueError(f\"Speed type of {speed_type} was not a valid type.\")\n\n    try:\n        return f\"{round(bit_value / bit_multiplier, nbr_decimal)}{speed_type}\"\n    except ZeroDivisionError:\n        return f\"{round(bit_value, nbr_decimal)}{speed_type}\"\n</code></pre>"},{"location":"dev/code_reference/banner.html","title":"Banner","text":""},{"location":"dev/code_reference/banner.html#netutils.banner","title":"<code>netutils.banner</code>","text":"<p>Functions for working with the banner configuration.</p>"},{"location":"dev/code_reference/banner.html#netutils.banner.delimiter_change","title":"<code>delimiter_change(config, from_delimiter, to_delimiter)</code>","text":"<p>Change the banner delimiter.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Configuration line containing banner delimiter.</p> required <code>from_delimiter</code> <code>str</code> <p>Delimiter to replace in the banner.</p> required <code>to_delimiter</code> <code>str</code> <p>Delimiter to include in the config.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Configuration with delimiter replaced.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.banner import delimiter_change\n&gt;&gt;&gt; delimiter_change(\"banner login ^\\n******************\\n    TEST BANNER\\n******************^\", \"^\", \"^C\")\n'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n&gt;&gt;&gt; delimiter_change(\"banner login #\\n******************\\n    TEST BANNER\\n******************#\", \"#\", \"^C\")\n'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n&gt;&gt;&gt; delimiter_change(\"banner login ^CCCCC\\n******************\\n    TEST BANNER\\n******************^C\", \"^C\", \"^C\")\n'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n</code></pre> Source code in <code>netutils/banner.py</code> <pre><code>def delimiter_change(config: str, from_delimiter: str, to_delimiter: str) -&gt; str:\n    r\"\"\"Change the banner delimiter.\n\n    Args:\n        config: Configuration line containing banner delimiter.\n        from_delimiter: Delimiter to replace in the banner.\n        to_delimiter: Delimiter to include in the config.\n\n    Returns:\n        Configuration with delimiter replaced.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.banner import delimiter_change\n        &gt;&gt;&gt; delimiter_change(\"banner login ^\\n******************\\n    TEST BANNER\\n******************^\", \"^\", \"^C\")\n        'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n        &gt;&gt;&gt; delimiter_change(\"banner login #\\n******************\\n    TEST BANNER\\n******************#\", \"#\", \"^C\")\n        'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n        &gt;&gt;&gt; delimiter_change(\"banner login ^CCCCC\\n******************\\n    TEST BANNER\\n******************^C\", \"^C\", \"^C\")\n        'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n    \"\"\"\n    config_line = config.replace(from_delimiter, to_delimiter)\n    if to_delimiter == CARET_C:\n        config_line = re.sub(r\"\\^C+\", CARET_C, config_line)\n    return config_line\n</code></pre>"},{"location":"dev/code_reference/banner.html#netutils.banner.normalise_delimiter_caret_c","title":"<code>normalise_delimiter_caret_c(delimiter, config)</code>","text":"<p>Normalise delimiter to ^C.</p> <p>Parameters:</p> Name Type Description Default <code>delimiter</code> <code>str</code> <p>Banner delimiter.</p> required <code>config</code> <code>str</code> <p>Configuration line containing banner delimiter.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Configuration with delimiter normalised to ^C.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.banner import normalise_delimiter_caret_c\n&gt;&gt;&gt; normalise_delimiter_caret_c(\"^\", \"banner login ^\\n******************\\n    TEST BANNER\\n******************^\")\n'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n&gt;&gt;&gt; normalise_delimiter_caret_c(\"^C\", \"banner login ^CCCCC\\n******************\\n    TEST BANNER\\n******************^C\")\n'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n</code></pre> Source code in <code>netutils/banner.py</code> <pre><code>def normalise_delimiter_caret_c(delimiter: str, config: str) -&gt; str:\n    r\"\"\"Normalise delimiter to ^C.\n\n    Args:\n        delimiter: Banner delimiter.\n        config: Configuration line containing banner delimiter.\n\n    Returns:\n        Configuration with delimiter normalised to ^C.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.banner import normalise_delimiter_caret_c\n        &gt;&gt;&gt; normalise_delimiter_caret_c(\"^\", \"banner login ^\\n******************\\n    TEST BANNER\\n******************^\")\n        'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n        &gt;&gt;&gt; normalise_delimiter_caret_c(\"^C\", \"banner login ^CCCCC\\n******************\\n    TEST BANNER\\n******************^C\")\n        'banner login ^C\\n******************\\n    TEST BANNER\\n******************^C'\n    \"\"\"\n    config_line = delimiter_change(config, delimiter, CARET_C)\n    return config_line\n</code></pre>"},{"location":"dev/code_reference/configs.html","title":"Configs","text":""},{"location":"dev/code_reference/configs.html#netutils.config","title":"<code>netutils.config</code>","text":"<p>Initialization file for config methods.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.clean","title":"<code>clean</code>","text":"<p>Functions for working with configuration to clean the config.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.clean.clean_config","title":"<code>clean_config(config, filters)</code>","text":"<p>Given a list of regex patterns, delete those lines that match.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>A string representation of a device configuration.</p> required <code>filters</code> <code>List[Dict[str, str]]</code> <p>A list of regex patterns used to delete remove configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Stripped down configuration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.clean import clean_config\n&gt;&gt;&gt; config = '''Building configuration...\n... Current configuration : 1582 bytes\n... !\n... version 12.4\n... service timestamps debug datetime msec\n... service timestamps log datetime msec\n... no service password-encryption\n... !\n... hostname CSR1\n... !\n... !\n... !'''\n&gt;&gt;&gt; clean_filters = [\n...         {\"regex\": r\"^Current\\s+configuration.*\\n\"},\n...         {\"regex\": r\"^Building\\s+configuration.*\\n\"},\n...         {\"regex\": r\"^ntp\\s+clock-period.*\\n\"},\n... ]\n&gt;&gt;&gt; print(clean_config(config, clean_filters))\n!\nversion 12.4\nservice timestamps debug datetime msec\nservice timestamps log datetime msec\nno service password-encryption\n!\nhostname CSR1\n!\n!\n!\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/config/clean.py</code> <pre><code>def clean_config(config: str, filters: t.List[t.Dict[str, str]]) -&gt; str:\n    r\"\"\"Given a list of regex patterns, delete those lines that match.\n\n    Args:\n        config: A string representation of a device configuration.\n        filters: A list of regex patterns used to delete remove configuration.\n\n    Returns:\n         Stripped down configuration.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.clean import clean_config\n        &gt;&gt;&gt; config = '''Building configuration...\n        ... Current configuration : 1582 bytes\n        ... !\n        ... version 12.4\n        ... service timestamps debug datetime msec\n        ... service timestamps log datetime msec\n        ... no service password-encryption\n        ... !\n        ... hostname CSR1\n        ... !\n        ... !\n        ... !'''\n        &gt;&gt;&gt; clean_filters = [\n        ...         {\"regex\": r\"^Current\\s+configuration.*\\n\"},\n        ...         {\"regex\": r\"^Building\\s+configuration.*\\n\"},\n        ...         {\"regex\": r\"^ntp\\s+clock-period.*\\n\"},\n        ... ]\n        &gt;&gt;&gt; print(clean_config(config, clean_filters))\n        !\n        version 12.4\n        service timestamps debug datetime msec\n        service timestamps log datetime msec\n        no service password-encryption\n        !\n        hostname CSR1\n        !\n        !\n        !\n        &gt;&gt;&gt;\n    \"\"\"\n    for item in filters:\n        config = re.sub(item[\"regex\"], \"\", config, flags=re.MULTILINE)\n    return config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.clean.sanitize_config","title":"<code>sanitize_config(config, filters=None)</code>","text":"<p>Given a dictionary of filters, remove sensitive data from the provided config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>A string representation of a device configuration.</p> required <code>filters</code> <code>Optional[List[Dict[str, str]]]</code> <p>A list of dictionaries of regex patterns used to sanitize configuration, namely secrets. Defaults to an empty list.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Sanitized configuration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.clean import sanitize_config\n&gt;&gt;&gt; config = '''enable secret 5 $1$nc08$bizeEFbgCBKjZP4nurNCd.!'''\n&gt;&gt;&gt; SANITIZE_FILTERS = [\n...    {\n...         \"regex\": r\"^(enable (password|secret)( level \\d+)? \\d) .+$\",\n...         \"replace\": r\"\\1 &lt;removed&gt;\",\n...    }\n... ]\n&gt;&gt;&gt; sanitize_config(config, SANITIZE_FILTERS)\n'enable secret 5 &lt;removed&gt;'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/config/clean.py</code> <pre><code>def sanitize_config(config: str, filters: t.Optional[t.List[t.Dict[str, str]]] = None) -&gt; str:\n    r\"\"\"Given a dictionary of filters, remove sensitive data from the provided config.\n\n    Args:\n        config: A string representation of a device configuration.\n        filters: A list of dictionaries of regex patterns used to sanitize configuration, namely secrets. Defaults to an empty list.\n\n    Returns:\n        str: Sanitized configuration.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.clean import sanitize_config\n        &gt;&gt;&gt; config = '''enable secret 5 $1$nc08$bizeEFbgCBKjZP4nurNCd.!'''\n        &gt;&gt;&gt; SANITIZE_FILTERS = [\n        ...    {\n        ...         \"regex\": r\"^(enable (password|secret)( level \\d+)? \\d) .+$\",\n        ...         \"replace\": r\"\\1 &lt;removed&gt;\",\n        ...    }\n        ... ]\n        &gt;&gt;&gt; sanitize_config(config, SANITIZE_FILTERS)\n        'enable secret 5 &lt;removed&gt;'\n        &gt;&gt;&gt;\n    \"\"\"\n    if not filters:\n        filters = []\n    for item in filters:\n        config = re.sub(item[\"regex\"], item[\"replace\"], config, flags=re.MULTILINE)\n    return config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance","title":"<code>compliance</code>","text":"<p>Filter Plugins for compliance checks.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance.compliance","title":"<code>compliance(features, backup, intended, network_os, cfg_type='file')</code>","text":"<p>Report compliance for all features provided as input.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>List[Dict[str, Union[str, bool, List[str]]]]</code> <p>List of features for particular network os.</p> required <code>backup</code> <code>str</code> <p>running config or config backup file  to compare against intended.</p> required <code>intended</code> <code>str</code> <p>intended config to compare against backup.</p> required <code>network_os</code> <code>str</code> <p>Device network operating system that is in parser_map keys.</p> required <code>cfg_type</code> <code>str</code> <p>A string that is effectively a choice between <code>file</code> and <code>string</code>. Defaults to <code>file</code>.</p> <code>'file'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Dict[str, Union[str, bool]]]</code> <p>Compliance information per feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.compliance import compliance\n&gt;&gt;&gt; features = [\n...     {\n...         \"name\": \"hostname\",\n...         \"ordered\": True,\n...         \"section\": [\n...             \"hostname\"\n...         ]\n...     },\n...     {\n...         \"name\": \"ntp\",\n...         \"ordered\": True,\n...         \"section\": [\n...             \"ntp\"\n...         ]\n...     }\n... ]\n&gt;&gt;&gt; backup = \"ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer\"\n&gt;&gt;&gt; intended = \"ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer\"\n&gt;&gt;&gt; network_os = \"cisco_ios\"\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; compliance(features, backup, intended, network_os, \"string\") == \\\n... {'hostname': {'actual': '',\n...     'cannot_parse': True,\n...     'compliant': True,\n...     'extra': '',\n...     'intended': '',\n...     'missing': '',\n...     'ordered_compliant': True,\n...     'unordered_compliant': True},\n... 'ntp': {'actual': 'ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer',\n...     'cannot_parse': True,\n...     'compliant': False,\n...     'extra': 'ntp server 192.168.1.2 prefer',\n...     'intended': 'ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer',\n...     'missing': 'ntp server 192.168.1.5 prefer',\n...     'ordered_compliant': False,\n...     'unordered_compliant': False}}\nTrue\n</code></pre> Source code in <code>netutils/config/compliance.py</code> <pre><code>def compliance(\n    features: t.List[t.Dict[str, t.Union[str, bool, t.List[str]]]],\n    backup: str,\n    intended: str,\n    network_os: str,\n    cfg_type: str = \"file\",\n) -&gt; t.Dict[str, t.Dict[str, t.Union[str, bool]]]:\n    r\"\"\"Report compliance for all features provided as input.\n\n    Args:\n        features: List of features for particular network os.\n        backup: running config or config backup file  to compare against intended.\n        intended: intended config to compare against backup.\n        network_os: Device network operating system that is in parser_map keys.\n        cfg_type: A string that is effectively a choice between `file` and `string`. Defaults to `file`.\n\n    Returns:\n        dict: Compliance information per feature.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.compliance import compliance\n        &gt;&gt;&gt; features = [\n        ...     {\n        ...         \"name\": \"hostname\",\n        ...         \"ordered\": True,\n        ...         \"section\": [\n        ...             \"hostname\"\n        ...         ]\n        ...     },\n        ...     {\n        ...         \"name\": \"ntp\",\n        ...         \"ordered\": True,\n        ...         \"section\": [\n        ...             \"ntp\"\n        ...         ]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; backup = \"ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer\"\n        &gt;&gt;&gt; intended = \"ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer\"\n        &gt;&gt;&gt; network_os = \"cisco_ios\"\n        &gt;&gt;&gt; from pprint import pprint\n        &gt;&gt;&gt; compliance(features, backup, intended, network_os, \"string\") == \\\n        ... {'hostname': {'actual': '',\n        ...     'cannot_parse': True,\n        ...     'compliant': True,\n        ...     'extra': '',\n        ...     'intended': '',\n        ...     'missing': '',\n        ...     'ordered_compliant': True,\n        ...     'unordered_compliant': True},\n        ... 'ntp': {'actual': 'ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer',\n        ...     'cannot_parse': True,\n        ...     'compliant': False,\n        ...     'extra': 'ntp server 192.168.1.2 prefer',\n        ...     'intended': 'ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer',\n        ...     'missing': 'ntp server 192.168.1.5 prefer',\n        ...     'ordered_compliant': False,\n        ...     'unordered_compliant': False}}\n        True\n    \"\"\"\n    if cfg_type not in [\"file\", \"string\"]:\n        raise ValueError(\"The variable `cfg_type` must be either `file` or `string`.\")\n    if cfg_type == \"file\":\n        backup_cfg = _open_file_config(backup)\n        intended_cfg = _open_file_config(intended)\n    else:\n        backup_cfg = backup\n        intended_cfg = intended\n\n    compliance_results = {}\n\n    for feature in features:\n        backup_str = section_config(feature, backup_cfg, network_os)\n        intended_str = section_config(feature, intended_cfg, network_os)\n        compliance_results.update({feature[\"name\"]: feature_compliance(feature, backup_str, intended_str, network_os)})\n\n    return compliance_results  # type: ignore\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance.config_section_not_parsed","title":"<code>config_section_not_parsed(features, device_cfg, network_os)</code>","text":"<p>Return device config section that is not checked by compliance.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>List[Dict[str, Union[str, bool, List[str]]]]</code> <p>List of features for particular network os.</p> required <code>device_cfg</code> <code>str</code> <p>Device configuration.</p> required <code>network_os</code> <code>str</code> <p>Device network operating system that is in parser_map keys.</p> required <p>Returns:</p> Type Description <code>Dict[str, Union[str, List[str]]]</code> <p>Config that was not parsed or section not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.compliance import config_section_not_parsed\n&gt;&gt;&gt; features = [{\n...    \"name\": \"BGP\",\n...    \"ordered\": True,\n...    \"section\": [\n...        \"router bgp \"\n...    ]\n... }]\n&gt;&gt;&gt; network_os = 'cisco_ios'\n&gt;&gt;&gt; device_cfg = '''router bgp 100\n...  bgp router-id 10.6.6.5\n... !\n... access-list 1 permit 10.10.10.10\n... access-list 1 permit 10.10.10.11'''\n&gt;&gt;&gt; config_section_not_parsed(features, device_cfg, network_os)\n{'remaining_cfg': '!\\naccess-list 1 permit 10.10.10.10\\naccess-list 1 permit 10.10.10.11', 'section_not_found': []}\n</code></pre> Source code in <code>netutils/config/compliance.py</code> <pre><code>def config_section_not_parsed(\n    features: t.List[t.Dict[str, t.Union[str, bool, t.List[str]]]],\n    device_cfg: str,\n    network_os: str,\n) -&gt; t.Dict[str, t.Union[str, t.List[str]]]:\n    r\"\"\"Return device config section that is not checked by compliance.\n\n    Args:\n        features: List of features for particular network os.\n        device_cfg: Device configuration.\n        network_os: Device network operating system that is in parser_map keys.\n\n    Returns:\n        Config that was not parsed or section not found.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.compliance import config_section_not_parsed\n        &gt;&gt;&gt; features = [{\n        ...    \"name\": \"BGP\",\n        ...    \"ordered\": True,\n        ...    \"section\": [\n        ...        \"router bgp \"\n        ...    ]\n        ... }]\n        &gt;&gt;&gt; network_os = 'cisco_ios'\n        &gt;&gt;&gt; device_cfg = '''router bgp 100\n        ...  bgp router-id 10.6.6.5\n        ... !\n        ... access-list 1 permit 10.10.10.10\n        ... access-list 1 permit 10.10.10.11'''\n        &gt;&gt;&gt; config_section_not_parsed(features, device_cfg, network_os)\n        {'remaining_cfg': '!\\naccess-list 1 permit 10.10.10.10\\naccess-list 1 permit 10.10.10.11', 'section_not_found': []}\n    \"\"\"\n    remaining_cfg = device_cfg\n    section_not_found = []\n    for feature in features:\n        feature_cfg = section_config(feature, device_cfg, network_os)\n        if not feature_cfg:\n            section_not_found.append(feature[\"name\"])\n        remaining_cfg = remaining_cfg.replace(feature_cfg, \"\")\n    return {\n        \"remaining_cfg\": remaining_cfg.strip(),\n        \"section_not_found\": section_not_found,  # type: ignore\n    }\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance.diff_network_config","title":"<code>diff_network_config(compare_config, base_config, network_os)</code>","text":"<p>Identify which lines in compare_config are not in base_config.</p> <p>Parameters:</p> Name Type Description Default <code>compare_config</code> <code>str</code> <p>The config to evaluate against base_config.</p> required <code>base_config</code> <code>str</code> <p>The config to compare compare_config against.</p> required <code>network_os</code> <code>str</code> <p>Device network operating system that is in parser_map keys.</p> required <p>Returns:</p> Name Type Description <code>base_config</code> <code>str</code> <p>The string of additional commands in compare_config separated by a newline.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.compliance import diff_network_config\n&gt;&gt;&gt; compare_config = '''router bgp 100\n...  bgp router-id 10.6.6.5\n... !\n... snmp-server ifindex persist\n... snmp-server packetsize 4096\n... snmp-server location SFO\n... access-list 1 permit 10.15.20.20\n... access-list 1 permit 10.15.20.21'''\n&gt;&gt;&gt;\n&gt;&gt;&gt; base_config = '''router bgp 100\n...  bgp router-id 10.6.6.5\n... !\n... snmp-server packetsize 4096\n... snmp-server location SFO\n... access-list 1 permit 10.15.20.20\n... access-list 1 permit 10.15.20.21'''\n&gt;&gt;&gt;\n&gt;&gt;&gt; network_os = \"cisco_ios\"\n&gt;&gt;&gt; diff_network_config(compare_config, base_config, network_os)\n'snmp-server ifindex persist'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/config/compliance.py</code> <pre><code>def diff_network_config(compare_config: str, base_config: str, network_os: str) -&gt; str:\n    \"\"\"Identify which lines in compare_config are not in base_config.\n\n    Args:\n        compare_config: The config to evaluate against base_config.\n        base_config: The config to compare compare_config against.\n        network_os: Device network operating system that is in parser_map keys.\n\n    Returns:\n        base_config: The string of additional commands in compare_config separated by a newline.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.compliance import diff_network_config\n        &gt;&gt;&gt; compare_config = '''router bgp 100\n        ...  bgp router-id 10.6.6.5\n        ... !\n        ... snmp-server ifindex persist\n        ... snmp-server packetsize 4096\n        ... snmp-server location SFO\n        ... access-list 1 permit 10.15.20.20\n        ... access-list 1 permit 10.15.20.21'''\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; base_config = '''router bgp 100\n        ...  bgp router-id 10.6.6.5\n        ... !\n        ... snmp-server packetsize 4096\n        ... snmp-server location SFO\n        ... access-list 1 permit 10.15.20.20\n        ... access-list 1 permit 10.15.20.21'''\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; network_os = \"cisco_ios\"\n        &gt;&gt;&gt; diff_network_config(compare_config, base_config, network_os)\n        'snmp-server ifindex persist'\n        &gt;&gt;&gt;\n    \"\"\"\n    os_parser = parser_map[network_os]\n    compare_parser = os_parser(compare_config)\n    base_parser = os_parser(base_config)\n    base = set(base_parser.config_lines)\n\n    needed_lines = []\n    for line in compare_parser.config_lines:\n        if line not in base:\n            for parent in line.parents:\n                if parent not in needed_lines:\n                    needed_lines.append(parent)\n            if line.config_line:\n                needed_lines.append(line.config_line)\n    return \"\\n\".join(needed_lines)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance.feature_compliance","title":"<code>feature_compliance(feature, backup_cfg, intended_cfg, network_os)</code>","text":"<p>Report compliance for all features provided as input.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>Dict[str, Union[str, bool, List[str]]]</code> <p>A dictionary with the attributes of the feature check</p> required <code>backup_cfg</code> <code>str</code> <p>running config or config backup of a specific feature to compare.</p> required <code>intended_cfg</code> <code>str</code> <p>intended config of a specific feature to compare.</p> required <code>network_os</code> <code>str</code> <p>Device network operating system that is in parser_map keys.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Union[str, bool]]</code> <p>Compliance information of a single feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.compliance import feature_compliance\n&gt;&gt;&gt; feature = {\n...     \"name\": \"ntp\",\n...     \"ordered\": True,\n...     \"section\": [\n...         \"ntp\"\n...     ]\n... }\n&gt;&gt;&gt; backup = \"ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer\"\n&gt;&gt;&gt; intended = \"ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer\"\n&gt;&gt;&gt; network_os = \"cisco_ios\"\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; feature_compliance(feature, backup, intended, network_os) == \\\n... {'actual': 'ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer',\n...     'cannot_parse': True,\n...     'compliant': False,\n...     'extra': 'ntp server 192.168.1.2 prefer',\n...     'intended': 'ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer',\n...     'missing': 'ntp server 192.168.1.5 prefer',\n...     'ordered_compliant': False,\n...     'unordered_compliant': False}\nTrue\n</code></pre> Source code in <code>netutils/config/compliance.py</code> <pre><code>def feature_compliance(\n    feature: t.Dict[str, t.Union[str, bool, t.List[str]]],\n    backup_cfg: str,\n    intended_cfg: str,\n    network_os: str,\n) -&gt; t.Dict[str, t.Union[str, bool]]:\n    r\"\"\"Report compliance for all features provided as input.\n\n    Args:\n        feature: A dictionary with the attributes of the feature check\n        backup_cfg: running config or config backup of a specific feature to compare.\n        intended_cfg: intended config of a specific feature to compare.\n        network_os: Device network operating system that is in parser_map keys.\n\n    Returns:\n        dict: Compliance information of a single feature.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.compliance import feature_compliance\n        &gt;&gt;&gt; feature = {\n        ...     \"name\": \"ntp\",\n        ...     \"ordered\": True,\n        ...     \"section\": [\n        ...         \"ntp\"\n        ...     ]\n        ... }\n        &gt;&gt;&gt; backup = \"ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer\"\n        &gt;&gt;&gt; intended = \"ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer\"\n        &gt;&gt;&gt; network_os = \"cisco_ios\"\n        &gt;&gt;&gt; from pprint import pprint\n        &gt;&gt;&gt; feature_compliance(feature, backup, intended, network_os) == \\\n        ... {'actual': 'ntp server 192.168.1.1\\nntp server 192.168.1.2 prefer',\n        ...     'cannot_parse': True,\n        ...     'compliant': False,\n        ...     'extra': 'ntp server 192.168.1.2 prefer',\n        ...     'intended': 'ntp server 192.168.1.1\\nntp server 192.168.1.5 prefer',\n        ...     'missing': 'ntp server 192.168.1.5 prefer',\n        ...     'ordered_compliant': False,\n        ...     'unordered_compliant': False}\n        True\n    \"\"\"\n    feature_data = default_feature.copy()\n    feature_data[\"actual\"] = backup_cfg\n    feature_data[\"intended\"] = intended_cfg\n    # Check for ordered compliant which is accomplished with a simple exact match\n    feature_data[\"ordered_compliant\"] = _is_feature_ordered_compliant(intended_cfg, backup_cfg)\n\n    if feature_data[\"ordered_compliant\"]:\n        feature_data.update(\n            {\n                \"missing\": \"\",\n                \"extra\": \"\",\n                \"unordered_compliant\": True,\n            }\n        )\n    else:\n        feature_data.update(_check_configs_differences(intended_cfg, backup_cfg, network_os))\n    if feature[\"ordered\"] is True:\n        feature_data[\"compliant\"] = feature_data[\"ordered_compliant\"]\n    elif feature[\"ordered\"] is False:\n        feature_data[\"compliant\"] = feature_data[\"unordered_compliant\"]\n    else:\n        raise  # pylint: disable=misplaced-bare-raise\n\n    return feature_data  # type: ignore\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance.find_unordered_cfg_lines","title":"<code>find_unordered_cfg_lines(intended_cfg, actual_cfg)</code>","text":"<p>Check if config lines are miss-ordered, i.e in ACL-s.</p> <p>Parameters:</p> Name Type Description Default <code>intended_cfg</code> <code>str</code> <p>Feature intended configuration.</p> required <code>actual_cfg</code> <code>str</code> <p>Feature actual configuration.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>Tuple[bool, List[Tuple[str, str]]]</code> <p>List of tuples with unordered_compliant cfg lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.compliance import find_unordered_cfg_lines\n&gt;&gt;&gt; intended_cfg = '''\n... ntp server 10.10.10.10\n... ntp server 10.10.10.11\n... ntp server 10.10.10.12'''\n&gt;&gt;&gt;\n&gt;&gt;&gt; actual_cfg = '''\n... ntp server 10.10.10.12\n... ntp server 10.10.10.11\n... ntp server 10.10.10.10'''\n&gt;&gt;&gt;\n&gt;&gt;&gt; find_unordered_cfg_lines(intended_cfg, actual_cfg)\n(True, [('ntp server 10.10.10.10', 'ntp server 10.10.10.12'), ('ntp server 10.10.10.12', 'ntp server 10.10.10.10')])\n</code></pre> Source code in <code>netutils/config/compliance.py</code> <pre><code>def find_unordered_cfg_lines(intended_cfg: str, actual_cfg: str) -&gt; t.Tuple[bool, t.List[t.Tuple[str, str]]]:\n    \"\"\"Check if config lines are miss-ordered, i.e in ACL-s.\n\n    Args:\n        intended_cfg: Feature intended configuration.\n        actual_cfg: Feature actual configuration.\n\n    Returns:\n        list: List of tuples with unordered_compliant cfg lines.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.compliance import find_unordered_cfg_lines\n        &gt;&gt;&gt; intended_cfg = '''\n        ... ntp server 10.10.10.10\n        ... ntp server 10.10.10.11\n        ... ntp server 10.10.10.12'''\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; actual_cfg = '''\n        ... ntp server 10.10.10.12\n        ... ntp server 10.10.10.11\n        ... ntp server 10.10.10.10'''\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; find_unordered_cfg_lines(intended_cfg, actual_cfg)\n        (True, [('ntp server 10.10.10.10', 'ntp server 10.10.10.12'), ('ntp server 10.10.10.12', 'ntp server 10.10.10.10')])\n    \"\"\"\n    intended_lines = intended_cfg.splitlines()\n    actual_lines = actual_cfg.splitlines()\n    unordered_lines = []\n    if len(intended_lines) == len(actual_lines):\n        # Process to find actual lines that are misordered\n        unordered_lines = [(e1, e2) for e1, e2 in zip(intended_lines, actual_lines) if e1 != e2]\n    # Process to find determine if there are any different lines, regardless of order\n    if not set(intended_lines).difference(actual_lines):\n        return (True, unordered_lines)\n    return (False, unordered_lines)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.compliance.section_config","title":"<code>section_config(feature, device_cfg, network_os)</code>","text":"<p>Parse feature section config from device cfg.</p> <pre><code>In case section attribute of the the feature is not provided\nentire content of the device_cfg is returned.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>Dict[str, Union[str, bool, List[str]]]</code> <p>Feature name and cfg lines that should be parsed.</p> required <code>device_cfg</code> <code>str</code> <p>Device configuration.</p> required <code>network_os</code> <p>Device network operating system that is in parser_map keys.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The hash report data mapping file hashes to report data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.compliance import section_config\n&gt;&gt;&gt; feature =  {\n...    \"name\": \"BGP\",\n...    \"ordered\": False,\n...    \"section\": [\n...        \"router bgp \"\n...    ]\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; device_cfg = '''router bgp 100\n...  bgp router-id 10.6.6.5\n... !\n... snmp-server ifindex persist\n... snmp-server packetsize 4096\n... snmp-server location SFO\n... access-list 1 permit 10.10.15.15\n... access-list 1 permit 10.10.20.20'''\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(section_config(feature, device_cfg, \"cisco_ios\"))# ==\nrouter bgp 100\n bgp router-id 10.6.6.5\n</code></pre> Source code in <code>netutils/config/compliance.py</code> <pre><code>def section_config(\n    feature: t.Dict[str, t.Union[str, bool, t.List[str]]],\n    device_cfg: str,\n    network_os: str,\n) -&gt; str:\n    \"\"\"Parse feature section config from device cfg.\n\n        In case section attribute of the the feature is not provided\n        entire content of the device_cfg is returned.\n\n    Args:\n        feature: Feature name and cfg lines that should be parsed.\n        device_cfg: Device configuration.\n        network_os : Device network operating system that is in parser_map keys.\n\n    Returns:\n        The hash report data mapping file hashes to report data.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.compliance import section_config\n        &gt;&gt;&gt; feature =  {\n        ...    \"name\": \"BGP\",\n        ...    \"ordered\": False,\n        ...    \"section\": [\n        ...        \"router bgp \"\n        ...    ]\n        ... }\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; device_cfg = '''router bgp 100\n        ...  bgp router-id 10.6.6.5\n        ... !\n        ... snmp-server ifindex persist\n        ... snmp-server packetsize 4096\n        ... snmp-server location SFO\n        ... access-list 1 permit 10.10.15.15\n        ... access-list 1 permit 10.10.20.20'''\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; print(section_config(feature, device_cfg, \"cisco_ios\"))# ==\n        router bgp 100\n         bgp router-id 10.6.6.5\n    \"\"\"\n    section_starts_with = feature.get(\"section\")\n    if not section_starts_with:\n        return device_cfg\n\n    match = False\n    section_config_list = []\n    os_parser = parser_map[network_os]\n    config_parsed = os_parser(device_cfg)\n    for line in config_parsed.config_lines:\n        # If multiple banners, line after first banner will be None.\n        # This conditional allows multiple banners in config.\n        if not line.config_line:\n            continue\n        if match:\n            if line.parents:  # pylint: disable=no-else-continue\n                section_config_list.append(line.config_line)\n                continue\n            else:\n                match = False\n        for line_start in section_starts_with:  # type: ignore\n            if not match and line.config_line.startswith(line_start):\n                section_config_list.append(line.config_line)\n                match = True\n    return \"\\n\".join(section_config_list).strip()\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.conversion","title":"<code>conversion</code>","text":"<p>Configuration conversion methods for different network operating systems.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.conversion.paloalto_panos_brace_to_set","title":"<code>paloalto_panos_brace_to_set(cfg, cfg_type='file')</code>","text":"<p>Convert Palo Alto Brace format configuration to set format.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str</code> <p>Configuration as a string</p> required <code>cfg_type</code> <code>str</code> <p>A string that is effectively a choice between <code>file</code> and <code>string</code>. Defaults to <code>file</code>.</p> <code>'file'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Converted configuration as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.conversion import paloalto_panos_brace_to_set\n&gt;&gt;&gt; config = '''\n...     config {\n...            mgt-config {\n...                users {\n...                  admin {\n...                    phash *;\n...                    permissions {\n...                      role-based {\n...                        superuser yes;\n...                      }\n...                    }\n...                    public-key thisisasuperduperlongbase64encodedstring;\n...                }\n...                panadmin {\n...                    permissions {\n...                      role-based {\n...                        superuser yes;\n...                      }\n...                    }\n...                    phash passwordhash;\n...                }\n...              }\n...            }\n...         }'''\n&gt;&gt;&gt; paloalto_panos_brace_to_set(cfg=config, cfg_type='string') == \\\n... '''set mgt-config users admin phash *\n... set mgt-config users admin permissions role-based superuser yes\n... set mgt-config users admin public-key thisisasuperduperlongbase64encodedstring\n... set mgt-config users panadmin permissions role-based superuser yes\n... set mgt-config users panadmin phash passwordhash'''\nTrue\n</code></pre> Source code in <code>netutils/config/conversion.py</code> <pre><code>def paloalto_panos_brace_to_set(cfg: str, cfg_type: str = \"file\") -&gt; str:\n    r\"\"\"Convert Palo Alto Brace format configuration to set format.\n\n    Args:\n        cfg: Configuration as a string\n        cfg_type: A string that is effectively a choice between `file` and `string`. Defaults to `file`.\n\n    Returns:\n        str: Converted configuration as a string.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.conversion import paloalto_panos_brace_to_set\n        &gt;&gt;&gt; config = '''\n        ...     config {\n        ...            mgt-config {\n        ...                users {\n        ...                  admin {\n        ...                    phash *;\n        ...                    permissions {\n        ...                      role-based {\n        ...                        superuser yes;\n        ...                      }\n        ...                    }\n        ...                    public-key thisisasuperduperlongbase64encodedstring;\n        ...                }\n        ...                panadmin {\n        ...                    permissions {\n        ...                      role-based {\n        ...                        superuser yes;\n        ...                      }\n        ...                    }\n        ...                    phash passwordhash;\n        ...                }\n        ...              }\n        ...            }\n        ...         }'''\n        &gt;&gt;&gt; paloalto_panos_brace_to_set(cfg=config, cfg_type='string') == \\\n        ... '''set mgt-config users admin phash *\n        ... set mgt-config users admin permissions role-based superuser yes\n        ... set mgt-config users admin public-key thisisasuperduperlongbase64encodedstring\n        ... set mgt-config users panadmin permissions role-based superuser yes\n        ... set mgt-config users panadmin phash passwordhash'''\n        True\n    \"\"\"\n    stack: t.List[str] = []\n    cfg_value: t.List[str] = []\n    cfg_string: str = \"\"\n\n    if cfg_type not in [\"file\", \"string\"]:\n        raise ValueError(\"The variable `cfg_type` must be either `file` or `string`.\")\n    if cfg_type == \"file\":\n        cfg_raw = _open_file_config(cfg)\n        cfg_list = paloalto_panos_clean_newlines(cfg=cfg_raw).splitlines()\n    else:\n        cfg_raw = paloalto_panos_clean_newlines(cfg=cfg)\n        cfg_list = cfg_raw.splitlines()\n\n    for i, line in enumerate(cfg_list):\n        line = line.strip()\n        if line.endswith(\";\") and not line.startswith('\";'):\n            line = line.split(\";\", 1)[0]\n            line = \"\".join(str(s) for s in stack) + line\n            line = line.split(\"config \", 1)[1]\n            line = \"set \" + line\n            cfg_value.append(line.strip())\n        elif line.endswith('login-banner \"') or line.endswith('content \"'):\n            _first_banner_line = \"\".join(str(s) for s in stack) + line\n            cfg_value.append(\"set \" + _first_banner_line.split(\"config \", 1)[1])\n\n            for banner_line in cfg_list[i + 1:]:  # fmt: skip\n                if '\"' in banner_line:\n                    banner_line = banner_line.split(\";\", 1)[0]\n                    cfg_value.append(banner_line.strip())\n                    break\n                cfg_value.append(banner_line.strip())\n        elif line.endswith(\"{\"):\n            stack.append(line[:-1])\n        elif line == \"}\" and len(stack) &gt; 0:\n            stack.pop()\n\n    for _l, _line in enumerate(cfg_value):\n        cfg_string += _line\n        if _l &lt; len(cfg_value) - 1:\n            cfg_string += \"\\n\"\n\n    # Filter out 'devices localhost.local domain' from the entire cfg_string\n    # TODO: Add flagging capability to disable this behavior\n    cfg_string = cfg_string.replace(\"devices localhost.localdomain \", \"\")\n\n    return cfg_string\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.conversion.paloalto_panos_clean_newlines","title":"<code>paloalto_panos_clean_newlines(cfg)</code>","text":"<p>Takes in the configuration and replaces any inappropriate newline characters with a space.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str</code> <p>Configuration as a string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cleaned configuration as a string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.conversion import paloalto_panos_clean_newlines\n&gt;&gt;&gt; config = '''\n... config {\n...     syslog {\n...         Traffic_Syslog {\n...             server {\n...             splunk {\n...                 transport UDP;\n...                 port 514;\n...                 format BSD;\n...                 server 1.1.1.1;\n...                 facility LOG_USER;\n...             }\n...             graylog {\n...                 transport UDP;\n...                 port 514;\n...                 format BSD;\n...                 server 2.2.2.2;\n...                 facility LOG_USER;\n...             }\n...             }\n...             format {\n...             config \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$result|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial shost=$host cs3Label=Virtual System cs3=$vsys act=$cmd duser=$admin destinationServiceName=$client msg=$path externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\n... Optional: cs1Label=Before Change Detail cs1=$before-change-detail cs2Label=After Change Detail cs2=$after-change-detail\";\n...             system \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial cs3Label=Virtual System cs3=$vsys fname=$object flexString2Label=Module flexString2=$module msg=$opaque externalId=$seqno cat=$eventid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n...             threat \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             traffic \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsReceived=$pkts_received PanOSPacketsSent=$pkts_sent start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed cs2Label=URL Category cs2=$category externalId=$seqno reason=$session_end_reason PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cat=$action_source PanOSActionFlags=$actionflags PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel\";\n...             url \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno requestContext=$contenttype cat=$threatid fileId=$pcap_id requestMethod=$http_method requestClientApplication=$user_agent PanOSXForwarderfor=$xff PanOSReferer=$referer PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             data \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             wildfire \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid filePath=$cloud fileId=$pcap_id fileHash=$filedigest fileType=$filetype suid=$sender msg=$subject duid=$recipient oldFileId=$reportid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             tunnel \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=Log Action cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action externalId=$seqno PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time cs2Label=Tunnel Type cs2=$tunnel flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsSent=$pkts_sent PanOSPacketsReceived=$pkts_received flexNumber2Label=Maximum Encapsulation flexNumber2=$max_encap cfp1Label=Unknown Protocol cfp1=$unknown_proto cfp2Label=Strict Checking cfp2=$strict_check PanOSTunnelFragment=$tunnel_fragment cfp3Label=Sessions Created cfp3=$sessions_created cfp4Label=Sessions Closed cfp4=$sessions_closed reason=$session_end_reason cat=$action_source start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed\";\n...             auth \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Server Profile cs1=$serverprofile cs2Label=Normalize User cs2=$normalize_user cs3Label=Virtual System cs3=$vsys cs4Label=Authentication Policy cs4=$authpolicy cs5Label=Client Type cs5=$clienttype cs6Label=Log Action cs6=$logset fname=$object cn1Label=Factor Number cn1=$factorno cn2Label=Authentication ID cn2=$authid src=$ip cnt=$repeatcnt duser=$user flexString2Label=Vendor flexString2=$vendor msg=$event externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags PanOSDesc=$desc\n... \";\n...             userid \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Factor Type cs1=$factortype cs3Label=Virtual System cs3=$vsys cs4Label=Data Source Name cs4=$datasourcename cs5Label=Data Source cs5=$datasource cs6Label=Data Source Type cs6=$datasourcetype cn1Label=Factor Number cn1=$factorno cn2Label=Virtual System ID cn2=$vsys_id cn3Label=Timeout Threshold cn3=$timeout src=$ip spt=$beginport dpt=$endport cnt=$repeatcnt duser=$user externalId=$seqno cat=$eventid end=$factorcompletiontime PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n...             hip-match \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$matchtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial suser=$srcuser cs3Label=Virtual System cs3=$vsys shost=$machinename src=$src cnt=$repeatcnt externalId=$seqno cat=$matchname start=$cef-formatted-time_generated cs2Label=Operating System cs2=$os PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id c6a2Label=IPv6 Source Address c6a2=$srcipv6\";\n...             correlation \"CEF:0|Palo Alto Networks|PAN-OS|8.0|$category|$type|$severity|rt=$cef-formatted-receive_time deviceExternalId=$serial start=$cef-formatted-time_generated src=$src suser=$srcuser cs3Label=Virtual System cs3=$vsys severity=$severity PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id fname=$object_name cn3Label=Object ID cn3=$object_id msg=$evidence\";\n...             escaping {\n...                 escaped-characters \\=;\n...                 escape-character \\;\n...             }\n...             }\n...         }\n...         }\n... }'''\n&gt;&gt;&gt; paloalto_panos_clean_newlines(cfg=config) == \\\n... '''\n... config {\n...     syslog {\n...         Traffic_Syslog {\n...             server {\n...             splunk {\n...                 transport UDP;\n...                 port 514;\n...                 format BSD;\n...                 server 1.1.1.1;\n...                 facility LOG_USER;\n...             }\n...             graylog {\n...                 transport UDP;\n...                 port 514;\n...                 format BSD;\n...                 server 2.2.2.2;\n...                 facility LOG_USER;\n...             }\n...             }\n...             format {\n...             config \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$result|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial shost=$host cs3Label=Virtual System cs3=$vsys act=$cmd duser=$admin destinationServiceName=$client msg=$path externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags Optional: cs1Label=Before Change Detail cs1=$before-change-detail cs2Label=After Change Detail cs2=$after-change-detail\";\n...             system \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial cs3Label=Virtual System cs3=$vsys fname=$object flexString2Label=Module flexString2=$module msg=$opaque externalId=$seqno cat=$eventid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n...             threat \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             traffic \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsReceived=$pkts_received PanOSPacketsSent=$pkts_sent start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed cs2Label=URL Category cs2=$category externalId=$seqno reason=$session_end_reason PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cat=$action_source PanOSActionFlags=$actionflags PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel\";\n...             url \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno requestContext=$contenttype cat=$threatid fileId=$pcap_id requestMethod=$http_method requestClientApplication=$user_agent PanOSXForwarderfor=$xff PanOSReferer=$referer PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             data \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             wildfire \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid filePath=$cloud fileId=$pcap_id fileHash=$filedigest fileType=$filetype suid=$sender msg=$subject duid=$recipient oldFileId=$reportid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n...             tunnel \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=Log Action cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action externalId=$seqno PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time cs2Label=Tunnel Type cs2=$tunnel flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsSent=$pkts_sent PanOSPacketsReceived=$pkts_received flexNumber2Label=Maximum Encapsulation flexNumber2=$max_encap cfp1Label=Unknown Protocol cfp1=$unknown_proto cfp2Label=Strict Checking cfp2=$strict_check PanOSTunnelFragment=$tunnel_fragment cfp3Label=Sessions Created cfp3=$sessions_created cfp4Label=Sessions Closed cfp4=$sessions_closed reason=$session_end_reason cat=$action_source start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed\";\n...             auth \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Server Profile cs1=$serverprofile cs2Label=Normalize User cs2=$normalize_user cs3Label=Virtual System cs3=$vsys cs4Label=Authentication Policy cs4=$authpolicy cs5Label=Client Type cs5=$clienttype cs6Label=Log Action cs6=$logset fname=$object cn1Label=Factor Number cn1=$factorno cn2Label=Authentication ID cn2=$authid src=$ip cnt=$repeatcnt duser=$user flexString2Label=Vendor flexString2=$vendor msg=$event externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags PanOSDesc=$desc \";\n...             userid \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Factor Type cs1=$factortype cs3Label=Virtual System cs3=$vsys cs4Label=Data Source Name cs4=$datasourcename cs5Label=Data Source cs5=$datasource cs6Label=Data Source Type cs6=$datasourcetype cn1Label=Factor Number cn1=$factorno cn2Label=Virtual System ID cn2=$vsys_id cn3Label=Timeout Threshold cn3=$timeout src=$ip spt=$beginport dpt=$endport cnt=$repeatcnt duser=$user externalId=$seqno cat=$eventid end=$factorcompletiontime PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n...             hip-match \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$matchtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial suser=$srcuser cs3Label=Virtual System cs3=$vsys shost=$machinename src=$src cnt=$repeatcnt externalId=$seqno cat=$matchname start=$cef-formatted-time_generated cs2Label=Operating System cs2=$os PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id c6a2Label=IPv6 Source Address c6a2=$srcipv6\";\n...             correlation \"CEF:0|Palo Alto Networks|PAN-OS|8.0|$category|$type|$severity|rt=$cef-formatted-receive_time deviceExternalId=$serial start=$cef-formatted-time_generated src=$src suser=$srcuser cs3Label=Virtual System cs3=$vsys severity=$severity PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id fname=$object_name cn3Label=Object ID cn3=$object_id msg=$evidence\";\n...             escaping {\n...                 escaped-characters \\=;\n...                 escape-character \\;\n...             }\n...             }\n...         }\n...         }\n... }'''\nTrue\n</code></pre> Source code in <code>netutils/config/conversion.py</code> <pre><code>def paloalto_panos_clean_newlines(cfg: str) -&gt; str:\n    r\"\"\"Takes in the configuration and replaces any inappropriate newline characters with a space.\n\n    Args:\n        cfg: Configuration as a string.\n\n    Returns:\n        str: Cleaned configuration as a string\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.conversion import paloalto_panos_clean_newlines\n        &gt;&gt;&gt; config = '''\n        ... config {\n        ...     syslog {\n        ...         Traffic_Syslog {\n        ...             server {\n        ...             splunk {\n        ...                 transport UDP;\n        ...                 port 514;\n        ...                 format BSD;\n        ...                 server 1.1.1.1;\n        ...                 facility LOG_USER;\n        ...             }\n        ...             graylog {\n        ...                 transport UDP;\n        ...                 port 514;\n        ...                 format BSD;\n        ...                 server 2.2.2.2;\n        ...                 facility LOG_USER;\n        ...             }\n        ...             }\n        ...             format {\n        ...             config \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$result|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial shost=$host cs3Label=Virtual System cs3=$vsys act=$cmd duser=$admin destinationServiceName=$client msg=$path externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\n        ... Optional: cs1Label=Before Change Detail cs1=$before-change-detail cs2Label=After Change Detail cs2=$after-change-detail\";\n        ...             system \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial cs3Label=Virtual System cs3=$vsys fname=$object flexString2Label=Module flexString2=$module msg=$opaque externalId=$seqno cat=$eventid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n        ...             threat \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             traffic \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsReceived=$pkts_received PanOSPacketsSent=$pkts_sent start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed cs2Label=URL Category cs2=$category externalId=$seqno reason=$session_end_reason PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cat=$action_source PanOSActionFlags=$actionflags PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel\";\n        ...             url \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno requestContext=$contenttype cat=$threatid fileId=$pcap_id requestMethod=$http_method requestClientApplication=$user_agent PanOSXForwarderfor=$xff PanOSReferer=$referer PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             data \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             wildfire \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid filePath=$cloud fileId=$pcap_id fileHash=$filedigest fileType=$filetype suid=$sender msg=$subject duid=$recipient oldFileId=$reportid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             tunnel \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=Log Action cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action externalId=$seqno PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time cs2Label=Tunnel Type cs2=$tunnel flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsSent=$pkts_sent PanOSPacketsReceived=$pkts_received flexNumber2Label=Maximum Encapsulation flexNumber2=$max_encap cfp1Label=Unknown Protocol cfp1=$unknown_proto cfp2Label=Strict Checking cfp2=$strict_check PanOSTunnelFragment=$tunnel_fragment cfp3Label=Sessions Created cfp3=$sessions_created cfp4Label=Sessions Closed cfp4=$sessions_closed reason=$session_end_reason cat=$action_source start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed\";\n        ...             auth \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Server Profile cs1=$serverprofile cs2Label=Normalize User cs2=$normalize_user cs3Label=Virtual System cs3=$vsys cs4Label=Authentication Policy cs4=$authpolicy cs5Label=Client Type cs5=$clienttype cs6Label=Log Action cs6=$logset fname=$object cn1Label=Factor Number cn1=$factorno cn2Label=Authentication ID cn2=$authid src=$ip cnt=$repeatcnt duser=$user flexString2Label=Vendor flexString2=$vendor msg=$event externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags PanOSDesc=$desc\n        ... \";\n        ...             userid \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Factor Type cs1=$factortype cs3Label=Virtual System cs3=$vsys cs4Label=Data Source Name cs4=$datasourcename cs5Label=Data Source cs5=$datasource cs6Label=Data Source Type cs6=$datasourcetype cn1Label=Factor Number cn1=$factorno cn2Label=Virtual System ID cn2=$vsys_id cn3Label=Timeout Threshold cn3=$timeout src=$ip spt=$beginport dpt=$endport cnt=$repeatcnt duser=$user externalId=$seqno cat=$eventid end=$factorcompletiontime PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n        ...             hip-match \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$matchtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial suser=$srcuser cs3Label=Virtual System cs3=$vsys shost=$machinename src=$src cnt=$repeatcnt externalId=$seqno cat=$matchname start=$cef-formatted-time_generated cs2Label=Operating System cs2=$os PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id c6a2Label=IPv6 Source Address c6a2=$srcipv6\";\n        ...             correlation \"CEF:0|Palo Alto Networks|PAN-OS|8.0|$category|$type|$severity|rt=$cef-formatted-receive_time deviceExternalId=$serial start=$cef-formatted-time_generated src=$src suser=$srcuser cs3Label=Virtual System cs3=$vsys severity=$severity PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id fname=$object_name cn3Label=Object ID cn3=$object_id msg=$evidence\";\n        ...             escaping {\n        ...                 escaped-characters \\=;\n        ...                 escape-character \\;\n        ...             }\n        ...             }\n        ...         }\n        ...         }\n        ... }'''\n        &gt;&gt;&gt; paloalto_panos_clean_newlines(cfg=config) == \\\n        ... '''\n        ... config {\n        ...     syslog {\n        ...         Traffic_Syslog {\n        ...             server {\n        ...             splunk {\n        ...                 transport UDP;\n        ...                 port 514;\n        ...                 format BSD;\n        ...                 server 1.1.1.1;\n        ...                 facility LOG_USER;\n        ...             }\n        ...             graylog {\n        ...                 transport UDP;\n        ...                 port 514;\n        ...                 format BSD;\n        ...                 server 2.2.2.2;\n        ...                 facility LOG_USER;\n        ...             }\n        ...             }\n        ...             format {\n        ...             config \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$result|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial shost=$host cs3Label=Virtual System cs3=$vsys act=$cmd duser=$admin destinationServiceName=$client msg=$path externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags Optional: cs1Label=Before Change Detail cs1=$before-change-detail cs2Label=After Change Detail cs2=$after-change-detail\";\n        ...             system \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial cs3Label=Virtual System cs3=$vsys fname=$object flexString2Label=Module flexString2=$module msg=$opaque externalId=$seqno cat=$eventid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n        ...             threat \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             traffic \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsReceived=$pkts_received PanOSPacketsSent=$pkts_sent start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed cs2Label=URL Category cs2=$category externalId=$seqno reason=$session_end_reason PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cat=$action_source PanOSActionFlags=$actionflags PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel\";\n        ...             url \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno requestContext=$contenttype cat=$threatid fileId=$pcap_id requestMethod=$http_method requestClientApplication=$user_agent PanOSXForwarderfor=$xff PanOSReferer=$referer PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             data \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid fileId=$pcap_id PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             wildfire \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|$number-of-severity|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=LogProfile cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action request=$misc cs2Label=URL Category cs2=$category flexString2Label=Direction flexString2=$direction PanOSActionFlags=$actionflags externalId=$seqno cat=$threatid filePath=$cloud fileId=$pcap_id fileHash=$filedigest fileType=$filetype suid=$sender msg=$subject duid=$recipient oldFileId=$reportid PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSSrcUUID=$src_uuid PanOSDstUUID=$dst_uuid PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time PanOSTunnelType=$tunnel PanOSThreatCategory=$thr_category PanOSContentVer=$contentver\";\n        ...             tunnel \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial src=$src dst=$dst sourceTranslatedAddress=$natsrc destinationTranslatedAddress=$natdst cs1Label=Rule cs1=$rule suser=$srcuser duser=$dstuser app=$app cs3Label=Virtual System cs3=$vsys cs4Label=Source Zone cs4=$from cs5Label=Destination Zone cs5=$to deviceInboundInterface=$inbound_if deviceOutboundInterface=$outbound_if cs6Label=Log Action cs6=$logset cn1Label=SessionID cn1=$sessionid cnt=$repeatcnt spt=$sport dpt=$dport sourceTranslatedPort=$natsport destinationTranslatedPort=$natdport flexString1Label=Flags flexString1=$flags proto=$proto act=$action externalId=$seqno PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSTunnelID=$tunnelid PanOSMonitorTag=$monitortag PanOSParentSessionID=$parent_session_id PanOSParentStartTime=$parent_start_time cs2Label=Tunnel Type cs2=$tunnel flexNumber1Label=Total bytes flexNumber1=$bytes in=$bytes_sent out=$bytes_received cn2Label=Packets cn2=$packets PanOSPacketsSent=$pkts_sent PanOSPacketsReceived=$pkts_received flexNumber2Label=Maximum Encapsulation flexNumber2=$max_encap cfp1Label=Unknown Protocol cfp1=$unknown_proto cfp2Label=Strict Checking cfp2=$strict_check PanOSTunnelFragment=$tunnel_fragment cfp3Label=Sessions Created cfp3=$sessions_created cfp4Label=Sessions Closed cfp4=$sessions_closed reason=$session_end_reason cat=$action_source start=$cef-formatted-time_generated cn3Label=Elapsed time in seconds cn3=$elapsed\";\n        ...             auth \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Server Profile cs1=$serverprofile cs2Label=Normalize User cs2=$normalize_user cs3Label=Virtual System cs3=$vsys cs4Label=Authentication Policy cs4=$authpolicy cs5Label=Client Type cs5=$clienttype cs6Label=Log Action cs6=$logset fname=$object cn1Label=Factor Number cn1=$factorno cn2Label=Authentication ID cn2=$authid src=$ip cnt=$repeatcnt duser=$user flexString2Label=Vendor flexString2=$vendor msg=$event externalId=$seqno PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags PanOSDesc=$desc \";\n        ...             userid \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$subtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial cs1Label=Factor Type cs1=$factortype cs3Label=Virtual System cs3=$vsys cs4Label=Data Source Name cs4=$datasourcename cs5Label=Data Source cs5=$datasource cs6Label=Data Source Type cs6=$datasourcetype cn1Label=Factor Number cn1=$factorno cn2Label=Virtual System ID cn2=$vsys_id cn3Label=Timeout Threshold cn3=$timeout src=$ip spt=$beginport dpt=$endport cnt=$repeatcnt duser=$user externalId=$seqno cat=$eventid end=$factorcompletiontime PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name PanOSActionFlags=$actionflags\";\n        ...             hip-match \"CEF:0|Palo Alto Networks|PAN-OS|$sender_sw_version|$matchtype|$type|1|rt=$cef-formatted-receive_time deviceExternalId=$serial suser=$srcuser cs3Label=Virtual System cs3=$vsys shost=$machinename src=$src cnt=$repeatcnt externalId=$seqno cat=$matchname start=$cef-formatted-time_generated cs2Label=Operating System cs2=$os PanOSActionFlags=$actionflags PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id c6a2Label=IPv6 Source Address c6a2=$srcipv6\";\n        ...             correlation \"CEF:0|Palo Alto Networks|PAN-OS|8.0|$category|$type|$severity|rt=$cef-formatted-receive_time deviceExternalId=$serial start=$cef-formatted-time_generated src=$src suser=$srcuser cs3Label=Virtual System cs3=$vsys severity=$severity PanOSDGl1=$dg_hier_level_1 PanOSDGl2=$dg_hier_level_2 PanOSDGl3=$dg_hier_level_3 PanOSDGl4=$dg_hier_level_4 PanOSVsysName=$vsys_name dvchost=$device_name cn2Label=Virtual System ID cn2=$vsys_id fname=$object_name cn3Label=Object ID cn3=$object_id msg=$evidence\";\n        ...             escaping {\n        ...                 escaped-characters \\=;\n        ...                 escape-character \\;\n        ...             }\n        ...             }\n        ...         }\n        ...         }\n        ... }'''\n        True\n    \"\"\"\n    paloalto_panos_no_newline_cleanup_match = [\"private-key\", \"public-key\", \"login-banner\"]\n    paloalto_panos_newline_regex = re.compile(\n        r\"\\w+?-?\\w+\\s\\\"(?:[^\\\"\\\\]|\\\\.)*\\n(?:[^\\\"\\\\]|\\\\.)*\\\";$\", re.MULTILINE | re.DOTALL\n    )\n\n    newlines_cleaned_cfg = paloalto_panos_newline_regex.sub(\n        lambda match: (\n            match.group().replace(\"\\n\", \" \")\n            if not any(substring in match.group() for substring in paloalto_panos_no_newline_cleanup_match)\n            else match.group()\n        ),\n        cfg,\n    )\n\n    return newlines_cleaned_cfg\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser","title":"<code>parser</code>","text":"<p>Parsers for different network operating systems.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.AIREOSConfigParser","title":"<code>AIREOSConfigParser</code>","text":"<p>               Bases: <code>CiscoConfigParser</code>, <code>BaseSpaceConfigParser</code></p> <p>AireOSConfigParser implementation fo ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class AIREOSConfigParser(CiscoConfigParser, BaseSpaceConfigParser):\n    \"\"\"AireOSConfigParser implementation fo ConfigParser Class.\"\"\"\n\n    banner_start: t.List[str] = []\n\n    def _build_banner(self, config_line: str) -&gt; None:\n        raise NotImplementedError()\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ASAConfigParser","title":"<code>ASAConfigParser</code>","text":"<p>               Bases: <code>CiscoConfigParser</code></p> <p>Cisco ASA implementation of ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class ASAConfigParser(CiscoConfigParser):\n    \"\"\"Cisco ASA implementation of ConfigParser Class.\"\"\"\n\n    banner_start: t.List[str] = [\"banner\"]\n    comment_chars: t.List[str] = [\"!\", \":\"]\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.unique_config_lines: t.Set[ConfigLine] = set()\n        self.same_line_children: t.Set[ConfigLine] = set()\n        super(ASAConfigParser, self).__init__(config)\n\n    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.startswith(banner_start):\n                return True\n        return False\n\n    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        In addition to adding entries to config_lines, this also updates:\n          * self.same_line_children\n          * self.unique_config_lines\n\n        Args:\n            config_line (str): The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        super(ASAConfigParser, self)._update_config_lines(config_line)\n        entry = self.config_lines[-1]\n        if entry in self.unique_config_lines:\n            self.same_line_children.add(entry)\n        self.unique_config_lines.add(entry)\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import ASAConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''\n            ... interface Management0/0\n            ...  management-only\n            ...  nameif Management\n            ...  security-level 100\n            ...  ip address 10.1.1.10 255.255.255.0'''\n            &gt;&gt;&gt; config_tree = ASAConfigParser(str(config))\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line=\"interface Management0/0\", parents=()),\n            ...     ConfigLine(config_line=\" management-only\", parents=(\"interface Management0/0\",)),\n            ...     ConfigLine(config_line=\" nameif Management\", parents=(\"interface Management0/0\",)),\n            ...     ConfigLine(config_line=\" security-level 100\", parents=(\"interface Management0/0\",)),\n            ...     ConfigLine(config_line=\" ip address 10.1.1.10 255.255.255.0\", parents=(\"interface Management0/0\",)),\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if line is not None and line[0].isspace():\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    self._current_parents = ()\n\n            if line is None:\n                break\n\n            self._update_config_lines(line)\n\n        return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ASAConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config: The config text to parse.\n    \"\"\"\n    self.unique_config_lines: t.Set[ConfigLine] = set()\n    self.same_line_children: t.Set[ConfigLine] = set()\n    super(ASAConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ASAConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import ASAConfigParser, ConfigLine\n&gt;&gt;&gt; config = '''\n... interface Management0/0\n...  management-only\n...  nameif Management\n...  security-level 100\n...  ip address 10.1.1.10 255.255.255.0'''\n&gt;&gt;&gt; config_tree = ASAConfigParser(str(config))\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line=\"interface Management0/0\", parents=()),\n...     ConfigLine(config_line=\" management-only\", parents=(\"interface Management0/0\",)),\n...     ConfigLine(config_line=\" nameif Management\", parents=(\"interface Management0/0\",)),\n...     ConfigLine(config_line=\" security-level 100\", parents=(\"interface Management0/0\",)),\n...     ConfigLine(config_line=\" ip address 10.1.1.10 255.255.255.0\", parents=(\"interface Management0/0\",)),\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text tree of config lines and their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import ASAConfigParser, ConfigLine\n        &gt;&gt;&gt; config = '''\n        ... interface Management0/0\n        ...  management-only\n        ...  nameif Management\n        ...  security-level 100\n        ...  ip address 10.1.1.10 255.255.255.0'''\n        &gt;&gt;&gt; config_tree = ASAConfigParser(str(config))\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line=\"interface Management0/0\", parents=()),\n        ...     ConfigLine(config_line=\" management-only\", parents=(\"interface Management0/0\",)),\n        ...     ConfigLine(config_line=\" nameif Management\", parents=(\"interface Management0/0\",)),\n        ...     ConfigLine(config_line=\" security-level 100\", parents=(\"interface Management0/0\",)),\n        ...     ConfigLine(config_line=\" ip address 10.1.1.10 255.255.255.0\", parents=(\"interface Management0/0\",)),\n        ... ]\n        True\n    \"\"\"\n    for index, line in enumerate(self.generator_config):\n        current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n        if index == 0 and line[0].isspace():\n            self._current_parents = self._remove_parents(line, current_spaces)\n        elif not line[0].isspace():\n            self._current_parents = ()\n        else:\n            previous_config = self.config_lines[-1]\n            self._current_parents = (previous_config.config_line,)\n            self.indent_level = self.get_leading_space_count(line)\n            if line is not None and line[0].isspace():\n                line = self._build_nested_config(line)  # type: ignore\n            else:\n                self._current_parents = ()\n\n        if line is None:\n            break\n\n        self._update_config_lines(line)\n\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ASAConfigParser.is_banner_start","title":"<code>is_banner_start(line)</code>","text":"<p>Determine if the line starts a banner config.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The current config line in iteration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if line starts banner, else False.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_start(self, line: str) -&gt; bool:\n    \"\"\"Determine if the line starts a banner config.\n\n    Args:\n        line: The current config line in iteration.\n\n    Returns:\n        True if line starts banner, else False.\n    \"\"\"\n    for banner_start in self.banner_start:\n        if not line:\n            return False\n        if line.startswith(banner_start):\n            return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ArubaConfigCXParser","title":"<code>ArubaConfigCXParser</code>","text":"<p>               Bases: <code>_ArubaBaseConfigParser</code></p> <p>Aruba AOS-CX implementation fo ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class ArubaConfigCXParser(_ArubaBaseConfigParser):\n    \"\"\"Aruba AOS-CX implementation fo ConfigParser Class.\"\"\"\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ArubaConfigOSParser","title":"<code>ArubaConfigOSParser</code>","text":"<p>               Bases: <code>_ArubaBaseConfigParser</code></p> <p>Aruba OS / OSSWITCH implementation fo ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class ArubaConfigOSParser(_ArubaBaseConfigParser):\n    \"\"\"Aruba OS / OSSWITCH implementation fo ConfigParser Class.\"\"\"\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.ArubaConfigParser","title":"<code>ArubaConfigParser</code>","text":"<p>               Bases: <code>_ArubaBaseConfigParser</code></p> <p>Aruba Config implementation fo ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class ArubaConfigParser(_ArubaBaseConfigParser):\n    \"\"\"Aruba Config implementation fo ConfigParser Class.\"\"\"\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseBraceConfigParser","title":"<code>BaseBraceConfigParser</code>","text":"<p>               Bases: <code>BaseConfigParser</code></p> <p>Base parser class for config syntax that demarcates using braces.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class BaseBraceConfigParser(BaseConfigParser):  # pylint: disable=abstract-method\n    \"\"\"Base parser class for config syntax that demarcates using braces.\"\"\"\n\n    multiline_delimiters: t.List[str] = []\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove trailing spaces and empty lines from config lines.\n\n        Returns:\n            The non-space lines from ``config``.\n        \"\"\"\n        config_lines = [line.rstrip() for line in self.config.splitlines() if line and not line.isspace()]\n        return \"\\n\".join(config_lines)\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''auth ldap system-auth {\n            ...         port ldaps\n            ...         servers { ams-lda01.ntc.com }\n            ...     }\n            ...     auth partition Common {\n            ...         description \"Repository for system objects and shared objects.\"\n            ...     }\n            ...     auth password-policy { }'''\n            &gt;&gt;&gt; config_tree = BaseBraceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='auth ldap system-auth {', parents=()),\n            ...     ConfigLine(config_line='        port ldaps', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='        servers { ams-lda01.ntc.com }', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='    }', parents=('auth ldap system-auth {',)),\n            ...     ConfigLine(config_line='    auth partition Common {', parents=()),\n            ...     ConfigLine(config_line='        description \"Repository for system objects and shared objects.\"', parents=('    auth partition Common {',)), ConfigLine(config_line='    }', parents=('    auth partition Common {',)),\n            ...     ConfigLine(config_line='    auth password-policy { }', parents=())\n            ... ]\n            True\n        \"\"\"\n        for line in self.generator_config:\n            self.config_lines.append(ConfigLine(line, self._current_parents))\n            line_end = line[-1]\n            if line.endswith(\"{\"):\n                self._current_parents += (line,)\n            elif line.lstrip() == \"}\":\n                self._current_parents = self._current_parents[:-1]\n            elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n                self._current_parents += (line,)\n                self._build_multiline_config(line_end)\n\n        return self.config_lines\n\n    def _build_multiline_config(self, delimiter: str) -&gt; t.Optional[ConfigLine]:\n        r\"\"\"Build config sections between characters demarcating multiline strings.\n\n        Args:\n            delimiter: The text to look for to end multiline config.\n\n        Returns:\n            The multiline string text that was added to ``self.config_lines``.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     'sys syslog {\\n'\n            ...     '    include \"\\n'\n            ...     '        filter f_local0 {\\n'\n            ...     '        facility(local0) and not match(\\\"DEBUG\");\\n'\n            ...     '    \"\\n'\n            ...     '}'\n            ... )\n            &gt;&gt;&gt; parser = BaseBraceConfigParser(config)\n            &gt;&gt;&gt; # '    include \"' started a multiline config\n            &gt;&gt;&gt; parser.config_lines == \\\n            ... [\n            ...     ConfigLine(config_line='sys syslog {', parents=()),\n            ...     ConfigLine(config_line='    include \"', parents=('sys syslog {',)),\n            ...     ConfigLine(config_line='        filter f_local0 {', parents=('sys syslog {',)),\n            ...     ConfigLine(config_line='        facility(local0) and not match(\"DEBUG\");', parents=('sys syslog {', '        filter f_local0 {')),\n            ...     ConfigLine(config_line='    \"', parents=('sys syslog {', '        filter f_local0 {')),\n            ...     ConfigLine(config_line='}', parents=('sys syslog {', '        filter f_local0 {'))\n            ... ]\n            True\n        \"\"\"\n        multiline_config = []\n        for line in self.generator_config:\n            multiline_config.append(line)\n            if line.lstrip() == delimiter:\n                multiline_entry = ConfigLine(\"\\n\".join(multiline_config), self._current_parents)\n                self.config_lines.append(multiline_entry)\n                self._current_parents = self._current_parents[:-1]\n                return multiline_entry\n        return None\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseBraceConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove trailing spaces and empty lines from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space lines from <code>config</code>.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseBraceConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n&gt;&gt;&gt; config = '''auth ldap system-auth {\n...         port ldaps\n...         servers { ams-lda01.ntc.com }\n...     }\n...     auth partition Common {\n...         description \"Repository for system objects and shared objects.\"\n...     }\n...     auth password-policy { }'''\n&gt;&gt;&gt; config_tree = BaseBraceConfigParser(config)\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line='auth ldap system-auth {', parents=()),\n...     ConfigLine(config_line='        port ldaps', parents=('auth ldap system-auth {',)),\n...     ConfigLine(config_line='        servers { ams-lda01.ntc.com }', parents=('auth ldap system-auth {',)),\n...     ConfigLine(config_line='    }', parents=('auth ldap system-auth {',)),\n...     ConfigLine(config_line='    auth partition Common {', parents=()),\n...     ConfigLine(config_line='        description \"Repository for system objects and shared objects.\"', parents=('    auth partition Common {',)), ConfigLine(config_line='    }', parents=('    auth partition Common {',)),\n...     ConfigLine(config_line='    auth password-policy { }', parents=())\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text tree of config lines and their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n        &gt;&gt;&gt; config = '''auth ldap system-auth {\n        ...         port ldaps\n        ...         servers { ams-lda01.ntc.com }\n        ...     }\n        ...     auth partition Common {\n        ...         description \"Repository for system objects and shared objects.\"\n        ...     }\n        ...     auth password-policy { }'''\n        &gt;&gt;&gt; config_tree = BaseBraceConfigParser(config)\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line='auth ldap system-auth {', parents=()),\n        ...     ConfigLine(config_line='        port ldaps', parents=('auth ldap system-auth {',)),\n        ...     ConfigLine(config_line='        servers { ams-lda01.ntc.com }', parents=('auth ldap system-auth {',)),\n        ...     ConfigLine(config_line='    }', parents=('auth ldap system-auth {',)),\n        ...     ConfigLine(config_line='    auth partition Common {', parents=()),\n        ...     ConfigLine(config_line='        description \"Repository for system objects and shared objects.\"', parents=('    auth partition Common {',)), ConfigLine(config_line='    }', parents=('    auth partition Common {',)),\n        ...     ConfigLine(config_line='    auth password-policy { }', parents=())\n        ... ]\n        True\n    \"\"\"\n    for line in self.generator_config:\n        self.config_lines.append(ConfigLine(line, self._current_parents))\n        line_end = line[-1]\n        if line.endswith(\"{\"):\n            self._current_parents += (line,)\n        elif line.lstrip() == \"}\":\n            self._current_parents = self._current_parents[:-1]\n        elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n            self._current_parents += (line,)\n            self._build_multiline_config(line_end)\n\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseConfigParser","title":"<code>BaseConfigParser</code>","text":"<p>Base class for parsers.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class BaseConfigParser:\n    \"\"\"Base class for parsers.\"\"\"\n\n    comment_chars = [\"!\"]\n    banner_start = [\"banner\", \"vacant-message\"]\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in self.config_lines_only.splitlines())\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove lines not related to config.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError()\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        \"\"\"Parse text tree of config lines and their parents.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove lines not related to config.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config: The config text to parse.\n    \"\"\"\n    self.config = config\n    self._config: t.Optional[str] = None\n    self._current_parents: t.Tuple[str, ...] = ()\n    self.generator_config = (line for line in self.config_lines_only.splitlines())\n    self.config_lines: t.List[ConfigLine] = []\n    self.build_config_relationship()\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    \"\"\"Parse text tree of config lines and their parents.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser","title":"<code>BaseSpaceConfigParser</code>","text":"<p>               Bases: <code>BaseConfigParser</code></p> <p>Base parser class for config syntax that demarcates using spaces/indentation.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class BaseSpaceConfigParser(BaseConfigParser):\n    \"\"\"Base parser class for config syntax that demarcates using spaces/indentation.\"\"\"\n\n    # TODO: Review if this can be removed\n    # pylint: disable=abstract-method\n\n    comment_chars = [\"!\"]\n    banner_start = [\"banner\", \"vacant-message\"]\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._indent_level = 0\n        super(BaseSpaceConfigParser, self).__init__(config)\n\n    @property\n    def indent_level(self) -&gt; int:\n        \"\"\"Count the number of spaces a config line is indented.\"\"\"\n        return self._indent_level\n\n    @indent_level.setter\n    def indent_level(self, value: int) -&gt; None:\n        self._indent_level = value\n\n    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if line ends the banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line ends banner, else False.\n        \"\"\"\n        if self.banner_end in line:\n            return True\n        return False\n\n    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\n\n        Args:\n            line: The current config line in iteration.\n\n        Returns:\n            True if line starts banner, else False.\n        \"\"\"\n        for banner_start in self.banner_start:\n            if not line:\n                return False\n            if line.lstrip().startswith(banner_start):\n                return True\n        return False\n\n    def is_comment(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a comment.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a comment, else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n            False\n            &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for comment_char in self.comment_chars:\n            if line.lstrip().startswith(comment_char):\n                return True\n        return False\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove spaces and comments from config lines.\n\n        Returns:\n            The non-space and non-comment lines from ``config``.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''!\n            ... aaa group server tacacs+ auth\n            ...  server 10.1.1.1\n            ...  server 10.2.2.2\n            ...\n            ... !\n            ... '''\n            &gt;&gt;&gt; config_parser = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; print(config_parser.config_lines_only)\n            aaa group server tacacs+ auth\n             server 10.1.1.1\n             server 10.2.2.2\n            &gt;&gt;&gt;\n        \"\"\"\n        if self._config is None:\n            config_lines = (\n                line.rstrip()\n                for line in self.config.splitlines()\n                if line and not self.is_comment(line) and not line.isspace()\n            )\n            self._config = \"\\n\".join(config_lines)\n        return self._config\n\n    @staticmethod\n    def get_leading_space_count(config_line: str) -&gt; int:\n        r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n        Args:\n           config_line: A line of text in the config.\n\n        Returns:\n            The number of leading spaces.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n            &gt;&gt;&gt; config_line = \" description link to ISP\"\n            &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n            &gt;&gt;&gt; indent_level\n            1\n            &gt;&gt;&gt;\n        \"\"\"\n        return len(config_line) - len(config_line.lstrip())\n\n    def _remove_parents(self, line: str, current_spaces: int) -&gt; t.Tuple[str, ...]:\n        \"\"\"Remove parents from ``self._curent_parents`` based on indent levels.\n\n        Args:\n            line: A line of text in the config.\n            current_spaces: The number of spaces the current line is indented.\n\n        Returns:\n            The config lines parent config lines.\n        \"\"\"\n        deindent_level = 1\n        try:\n            previous_parent = self._current_parents[-1]\n            previous_indent = self.get_leading_space_count(previous_parent)\n            while previous_indent &gt; current_spaces:\n                deindent_level += 1\n                previous_parent = self._current_parents[-deindent_level]\n                previous_indent = self.get_leading_space_count(previous_parent)\n        except IndexError:\n            raise IndexError(f\"\\nValidate the first line does not begin with a space\\n{line}\\n\")\n        parents = self._current_parents[:-deindent_level] or (self._current_parents[0],)\n        return parents\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n\n    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            if self.is_banner_start(line):\n                banner_line = self._build_banner(line)\n                if banner_line is None or not banner_line[0].isspace():\n                    self._current_parents = ()\n                    self.indent_level = 0\n                    return banner_line\n                line = banner_line\n\n            self._update_config_lines(line)\n        return None\n\n    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        entry = ConfigLine(config_line, self._current_parents)\n        self.config_lines.append(entry)\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\\n\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            elif not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n                # line can potentially be another banner start therefore we do a secondary check.\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n\n    @staticmethod\n    def _match_type_check(line: str, pattern: str, match_type: str) -&gt; bool:\n        \"\"\"Checks pattern for exact match or regex.\"\"\"\n        if match_type == \"exact\" and line == pattern:\n            return True\n        if match_type == \"startswith\" and line.startswith(pattern):\n            return True\n        if match_type == \"endswith\" and line.endswith(pattern):\n            return True\n        if match_type == \"regex\" and re.match(pattern, line):\n            return True\n        return False\n\n    def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern not including parents.\n\n        Args:\n            pattern: pattern that describes parent.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if (\n                parents\n                and self._match_type_check(parents, pattern, match_type)\n                or self._match_type_check(cfg_line.config_line, pattern, match_type)\n            ):\n                config.append(cfg_line.config_line)\n        return config\n\n    def find_children_w_parents(\n        self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n    ) -&gt; t.List[str]:\n        \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n        Args:\n            parent_pattern: pattern that describes parent.\n            child_pattern: pattern that describes child.\n            match_type (optional): Exact or regex. Defaults to \"exact\".\n\n        Returns:\n            configuration under that parent pattern.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n            &gt;&gt;&gt; config = '''\n            ... router bgp 45000\n            ...   address-family ipv4 unicast\n            ...    neighbor 192.168.1.2 activate\n            ...    network 172.17.1.0 mask'''\n            &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n            &gt;&gt;&gt; print(bgp_conf)\n            ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n        \"\"\"\n        config = []\n        potential_parents = [\n            elem.parents[0]\n            for elem in self.build_config_relationship()\n            if self._match_type_check(elem.config_line, child_pattern, match_type)\n        ]\n        for cfg_line in self.build_config_relationship():\n            parents = cfg_line.parents[0] if cfg_line.parents else None\n            if parents in potential_parents and self._match_type_check(\n                parents,  # type: ignore[arg-type]\n                parent_pattern,\n                match_type,\n            ):\n                config.append(cfg_line.config_line)\n        return config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove spaces and comments from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space and non-comment lines from <code>config</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n&gt;&gt;&gt; config = '''!\n... aaa group server tacacs+ auth\n...  server 10.1.1.1\n...  server 10.2.2.2\n...\n... !\n... '''\n&gt;&gt;&gt; config_parser = BaseSpaceConfigParser(config)\n&gt;&gt;&gt; print(config_parser.config_lines_only)\naaa group server tacacs+ auth\n server 10.1.1.1\n server 10.2.2.2\n&gt;&gt;&gt;\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.indent_level","title":"<code>indent_level</code>  <code>property</code> <code>writable</code>","text":"<p>Count the number of spaces a config line is indented.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    self._indent_level = 0\n    super(BaseSpaceConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n&gt;&gt;&gt; config = (\n...     \"interface Ethernet1/1\\n\"\n...     \"  vlan 10\\n\"\n...     \"  no shutdown\\n\"\n...     \"interface Ethernet1/2\\n\"\n...     \"  shutdown\\n\"\n... )\n&gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text tree of config lines and their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n        &gt;&gt;&gt; config = (\n        ...     \"interface Ethernet1/1\\n\"\n        ...     \"  vlan 10\\n\"\n        ...     \"  no shutdown\\n\"\n        ...     \"interface Ethernet1/2\\n\"\n        ...     \"  shutdown\\n\"\n        ... )\n        &gt;&gt;&gt; config_tree = BaseSpaceConfigParser(config)\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n        ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n        ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n        ...     ConfigLine(config_line='interface Ethernet1/2', parents=(),),\n        ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n        ... ]\n        True\n    \"\"\"\n    for index, line in enumerate(self.generator_config):\n        current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n        if index == 0 and line[0].isspace():\n            self._current_parents = self._remove_parents(line, current_spaces)\n        elif not line[0].isspace():\n            self._current_parents = ()\n            if self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n        else:\n            previous_config = self.config_lines[-1]\n            self._current_parents = (previous_config.config_line,)\n            self.indent_level = self.get_leading_space_count(line)\n            if not self.is_banner_start(line):\n                line = self._build_nested_config(line)  # type: ignore\n            else:\n                line = self._build_banner(line)  # type: ignore\n                if line is not None and line[0].isspace():\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    self._current_parents = ()\n\n        if line is None:\n            break\n        elif self.is_banner_start(line):\n            line = self._build_banner(line)  # type: ignore\n            # line can potentially be another banner start therefore we do a secondary check.\n            if self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n\n        self._update_config_lines(line)\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.find_all_children","title":"<code>find_all_children(pattern, match_type='exact')</code>","text":"<p>Returns configuration part for a specific pattern not including parents.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern that describes parent.</p> required <code>match_type</code> <code>optional</code> <p>Exact or regex. Defaults to \"exact\".</p> <code>'exact'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>configuration under that parent pattern.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n&gt;&gt;&gt; config = '''\n... router bgp 45000\n...   address-family ipv4 unicast\n...    neighbor 192.168.1.2 activate\n...    network 172.17.1.0 mask'''\n&gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n&gt;&gt;&gt; print(bgp_conf)\n['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def find_all_children(self, pattern: str, match_type: str = \"exact\") -&gt; t.List[str]:\n    \"\"\"Returns configuration part for a specific pattern not including parents.\n\n    Args:\n        pattern: pattern that describes parent.\n        match_type (optional): Exact or regex. Defaults to \"exact\".\n\n    Returns:\n        configuration under that parent pattern.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n        &gt;&gt;&gt; config = '''\n        ... router bgp 45000\n        ...   address-family ipv4 unicast\n        ...    neighbor 192.168.1.2 activate\n        ...    network 172.17.1.0 mask'''\n        &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_all_children(pattern=\"router bgp\", match_type=\"startswith\")\n        &gt;&gt;&gt; print(bgp_conf)\n        ['router bgp 45000', '  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n    \"\"\"\n    config = []\n    for cfg_line in self.build_config_relationship():\n        parents = cfg_line.parents[0] if cfg_line.parents else None\n        if (\n            parents\n            and self._match_type_check(parents, pattern, match_type)\n            or self._match_type_check(cfg_line.config_line, pattern, match_type)\n        ):\n            config.append(cfg_line.config_line)\n    return config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.find_children_w_parents","title":"<code>find_children_w_parents(parent_pattern, child_pattern, match_type='exact')</code>","text":"<p>Returns configuration part for a specific pattern including parents and children.</p> <p>Parameters:</p> Name Type Description Default <code>parent_pattern</code> <code>str</code> <p>pattern that describes parent.</p> required <code>child_pattern</code> <code>str</code> <p>pattern that describes child.</p> required <code>match_type</code> <code>optional</code> <p>Exact or regex. Defaults to \"exact\".</p> <code>'exact'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>configuration under that parent pattern.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n&gt;&gt;&gt; config = '''\n... router bgp 45000\n...   address-family ipv4 unicast\n...    neighbor 192.168.1.2 activate\n...    network 172.17.1.0 mask'''\n&gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n&gt;&gt;&gt; print(bgp_conf)\n['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def find_children_w_parents(\n    self, parent_pattern: str, child_pattern: str, match_type: str = \"exact\"\n) -&gt; t.List[str]:\n    \"\"\"Returns configuration part for a specific pattern including parents and children.\n\n    Args:\n        parent_pattern: pattern that describes parent.\n        child_pattern: pattern that describes child.\n        match_type (optional): Exact or regex. Defaults to \"exact\".\n\n    Returns:\n        configuration under that parent pattern.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n        &gt;&gt;&gt; config = '''\n        ... router bgp 45000\n        ...   address-family ipv4 unicast\n        ...    neighbor 192.168.1.2 activate\n        ...    network 172.17.1.0 mask'''\n        &gt;&gt;&gt; bgp_conf = BaseSpaceConfigParser(str(config)).find_children_w_parents(parent_pattern=\"router bgp\", child_pattern=\"  address-family\", match_type=\"regex\")\n        &gt;&gt;&gt; print(bgp_conf)\n        ['  address-family ipv4 unicast', '   neighbor 192.168.1.2 activate', '   network 172.17.1.0 mask']\n    \"\"\"\n    config = []\n    potential_parents = [\n        elem.parents[0]\n        for elem in self.build_config_relationship()\n        if self._match_type_check(elem.config_line, child_pattern, match_type)\n    ]\n    for cfg_line in self.build_config_relationship():\n        parents = cfg_line.parents[0] if cfg_line.parents else None\n        if parents in potential_parents and self._match_type_check(\n            parents,  # type: ignore[arg-type]\n            parent_pattern,\n            match_type,\n        ):\n            config.append(cfg_line.config_line)\n    return config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.get_leading_space_count","title":"<code>get_leading_space_count(config_line)</code>  <code>staticmethod</code>","text":"<p>Determine how many spaces the <code>config_line</code> is indented.</p> <p>Parameters:</p> Name Type Description Default <code>config_line</code> <code>str</code> <p>A line of text in the config.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of leading spaces.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n&gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n&gt;&gt;&gt; config_line = \" description link to ISP\"\n&gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n&gt;&gt;&gt; indent_level\n1\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>@staticmethod\ndef get_leading_space_count(config_line: str) -&gt; int:\n    r\"\"\"Determine how many spaces the ``config_line`` is indented.\n\n    Args:\n       config_line: A line of text in the config.\n\n    Returns:\n        The number of leading spaces.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n        &gt;&gt;&gt; config = '''interface GigabitEthernet1\\n description link to ISP'''\n        &gt;&gt;&gt; config_line = \" description link to ISP\"\n        &gt;&gt;&gt; indent_level = BaseSpaceConfigParser(config).get_leading_space_count(config_line)\n        &gt;&gt;&gt; indent_level\n        1\n        &gt;&gt;&gt;\n    \"\"\"\n    return len(config_line) - len(config_line.lstrip())\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.is_banner_end","title":"<code>is_banner_end(line)</code>","text":"<p>Determine if line ends the banner config.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The current config line in iteration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if line ends banner, else False.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_end(self, line: str) -&gt; bool:\n    \"\"\"Determine if line ends the banner config.\n\n    Args:\n        line: The current config line in iteration.\n\n    Returns:\n        True if line ends banner, else False.\n    \"\"\"\n    if self.banner_end in line:\n        return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.is_banner_start","title":"<code>is_banner_start(line)</code>","text":"<p>Determine if the line starts a banner config.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The current config line in iteration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if line starts banner, else False.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_start(self, line: str) -&gt; bool:\n    \"\"\"Determine if the line starts a banner config.\n\n    Args:\n        line: The current config line in iteration.\n\n    Returns:\n        True if line starts banner, else False.\n    \"\"\"\n    for banner_start in self.banner_start:\n        if not line:\n            return False\n        if line.lstrip().startswith(banner_start):\n            return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.BaseSpaceConfigParser.is_comment","title":"<code>is_comment(line)</code>","text":"<p>Determine if line is a comment.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A config line from the device.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if line is a comment, else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n&gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\nFalse\n&gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\nTrue\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_comment(self, line: str) -&gt; bool:\n    \"\"\"Determine if line is a comment.\n\n    Args:\n        line: A config line from the device.\n\n    Returns:\n        True if line is a comment, else False.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser\n        &gt;&gt;&gt; BaseSpaceConfigParser(\"interface Ethernet1/1\").is_comment(\"interface Ethernet1/1\")\n        False\n        &gt;&gt;&gt; BaseSpaceConfigParser(\"!\").is_comment(\"!\")\n        True\n        &gt;&gt;&gt;\n    \"\"\"\n    for comment_char in self.comment_chars:\n        if line.lstrip().startswith(comment_char):\n            return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.CiscoConfigParser","title":"<code>CiscoConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Cisco Implementation of ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class CiscoConfigParser(BaseSpaceConfigParser):\n    \"\"\"Cisco Implementation of ConfigParser Class.\"\"\"\n\n    regex_banner = re.compile(r\"^(banner\\s+\\S+|\\s*vacant-message)\\s+(?P&lt;banner_delimiter&gt;\\^C|.)\")\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self._banner_end: t.Optional[str] = None\n        super(CiscoConfigParser, self).__init__(config)\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        return super(CiscoConfigParser, self)._build_banner(config_line)\n\n    @staticmethod\n    def is_banner_one_line(config_line: str) -&gt; bool:\n        \"\"\"Determine if all banner config is on one line.\"\"\"\n        _, delimeter, banner = config_line.partition(\"^C\")\n        # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n        if banner == \"^C\":\n            return True\n        # Based on NXOS configs, the banner delimeter is ignored until another char is used\n        banner_config_start = banner.lstrip(delimeter)\n        if delimeter not in banner_config_start:\n            return False\n        return True\n\n    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Determine if the line starts a banner config.\"\"\"\n        state = super(CiscoConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        if self._banner_end is None:\n            raise RuntimeError(\"Banner end not yet set.\")\n        return self._banner_end\n\n    @banner_end.setter\n    def banner_end(self, banner_start_line: str) -&gt; None:\n        banner_parsed = self.regex_banner.match(banner_start_line)\n        if not banner_parsed:\n            raise ValueError(\"There was an error parsing your banner, the end of the banner could not be found\")\n        self._banner_end = banner_parsed.groupdict()[\"banner_delimiter\"]\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.CiscoConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code> <code>writable</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.CiscoConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    self._banner_end: t.Optional[str] = None\n    super(CiscoConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.CiscoConfigParser.is_banner_one_line","title":"<code>is_banner_one_line(config_line)</code>  <code>staticmethod</code>","text":"<p>Determine if all banner config is on one line.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>@staticmethod\ndef is_banner_one_line(config_line: str) -&gt; bool:\n    \"\"\"Determine if all banner config is on one line.\"\"\"\n    _, delimeter, banner = config_line.partition(\"^C\")\n    # if the banner is the delimeter is a single line empty banner. e.g banner motd ^C^C which ios allows.\n    if banner == \"^C\":\n        return True\n    # Based on NXOS configs, the banner delimeter is ignored until another char is used\n    banner_config_start = banner.lstrip(delimeter)\n    if delimeter not in banner_config_start:\n        return False\n    return True\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.CiscoConfigParser.is_banner_start","title":"<code>is_banner_start(line)</code>","text":"<p>Determine if the line starts a banner config.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_start(self, line: str) -&gt; bool:\n    \"\"\"Determine if the line starts a banner config.\"\"\"\n    state = super(CiscoConfigParser, self).is_banner_start(line)\n    if state:\n        self.banner_end = line\n    return state\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.EOSConfigParser","title":"<code>EOSConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>EOSConfigParser implementation fo ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class EOSConfigParser(BaseSpaceConfigParser):\n    \"\"\"EOSConfigParser implementation fo ConfigParser Class.\"\"\"\n\n    banner_end = \"EOF\"\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.F5ConfigParser","title":"<code>F5ConfigParser</code>","text":"<p>               Bases: <code>BaseBraceConfigParser</code></p> <p>F5ConfigParser implementation for ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class F5ConfigParser(BaseBraceConfigParser):\n    \"\"\"F5ConfigParser implementation for ConfigParser Class.\"\"\"\n\n    multiline_delimiters: t.List[str] = ['\"']\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"F5 platform doesn't have a banner.\")\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        super().__init__(self._clean_config_f5(config))\n\n    def _clean_config_f5(self, config_text: str) -&gt; str:\n        \"\"\"Removes all configuration items with 'ltm rule'.\n\n        iRules are essentially impossible to parse with the lack of uniformity,\n        therefore, this method ensures they are not included in ``self.config``.\n\n        Args:\n            config_text: The entire config as a string.\n\n        Returns:\n            The sanitized config with all iRules (ltm rule) stanzas removed.\n        \"\"\"\n        config_split = config_text.split(\"ltm rule\")\n        if len(config_split) &gt; 1:\n            start_config = config_split[0]\n            end_config = config_split[-1]\n            _, ltm, clean_config = end_config.partition(\"ltm\")\n            final_config = start_config + ltm + clean_config\n        else:\n            final_config = config_text\n        return final_config\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import F5ConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''apm resource webtop-link aShare {\n            ...     application-uri http://funshare.example.com\n            ...     customization-group a_customization_group\n            ... }\n            ... apm sso form-based portal_ext_sso_form_based {\n            ...     form-action /Citrix/Example/ExplicitAuth/LoginAttempt\n            ...     form-field \"LoginBtn Log+On\n            ... StateContext \"\n            ...     form-password password\n            ...     form-username username\n            ...     passthru true\n            ...     start-uri /Citrix/Example/ExplicitAuth/Login*\n            ...     success-match-type cookie\n            ...     success-match-value CtxsAuthId\n            ... }\n            ... '''\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; config_tree = F5ConfigParser(config)\n            &gt;&gt;&gt; print(config_tree.build_config_relationship())\n            [ConfigLine(config_line='apm resource webtop-link aShare {', parents=()), ConfigLine(config_line='    application-uri http://funshare.example.com', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='    customization-group a_customization_group', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='}', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='apm sso form-based portal_ext_sso_form_based {', parents=()), ConfigLine(config_line='    form-action /Citrix/Example/ExplicitAuth/LoginAttempt', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-field \"LoginBtn Log+On\\nStateContext \"', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-password password', parents=()), ConfigLine(config_line='    form-username username', parents=()), ConfigLine(config_line='    passthru true', parents=()), ConfigLine(config_line='    start-uri /Citrix/Example/ExplicitAuth/Login*', parents=()), ConfigLine(config_line='    success-match-type cookie', parents=()), ConfigLine(config_line='    success-match-value CtxsAuthId', parents=()), ConfigLine(config_line='}', parents=())]\n        \"\"\"\n        for line in self.generator_config:\n            self.config_lines.append(ConfigLine(line, self._current_parents))\n            line_end = line[-1]\n            if line.endswith(\"{\"):\n                self._current_parents += (line,)\n            elif line.lstrip() == \"}\":\n                self._current_parents = self._current_parents[:-1]\n            elif any(\n                delimiters in self.multiline_delimiters and line.count(delimiters) == 1\n                for delimiters in self.multiline_delimiters\n            ):\n                for delimiter in self.multiline_delimiters:\n                    if line.count(delimiter) == 1:\n                        self._build_multiline_single_configuration_line(delimiter, line)\n            elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n                self._current_parents += (line,)\n                self._build_multiline_config(line_end)\n\n        return self.config_lines\n\n    def _build_multiline_single_configuration_line(self, delimiter: str, prev_line: str) -&gt; t.Optional[ConfigLine]:\n        r\"\"\"Concatenate Multiline strings between delimiter when newlines causes string to traverse multiple lines.\n\n        Args:\n            delimiter: The text to look for to end multiline config.\n            prev_line: The text from the previously analyzed line.\n\n        Returns:\n            The multiline string text that was added to ``self.config_lines``.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import F5ConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''apm resource webtop-link aShare {\n            ...     application-uri http://funshare.example.com\n            ...     customization-group a_customization_group\n            ... }\n            ... apm sso form-based portal_ext_sso_form_based {\n            ...     form-action /Citrix/Example/ExplicitAuth/LoginAttempt\n            ...     form-field \"LoginBtn Log+On\n            ... StateContext \"\n            ...     form-password password\n            ...     form-username username\n            ...     passthru true\n            ...     start-uri /Citrix/Example/ExplicitAuth/Login*\n            ...     success-match-type cookie\n            ...     success-match-value CtxsAuthId\n            ... }\n            ... '''\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; config_tree = F5ConfigParser(str(config))\n            &gt;&gt;&gt; print(config_tree.build_config_relationship())\n            [ConfigLine(config_line='apm resource webtop-link aShare {', parents=()), ConfigLine(config_line='    application-uri http://funshare.example.com', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='    customization-group a_customization_group', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='}', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='apm sso form-based portal_ext_sso_form_based {', parents=()), ConfigLine(config_line='    form-action /Citrix/Example/ExplicitAuth/LoginAttempt', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-field \"LoginBtn Log+On\\nStateContext \"', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-password password', parents=()), ConfigLine(config_line='    form-username username', parents=()), ConfigLine(config_line='    passthru true', parents=()), ConfigLine(config_line='    start-uri /Citrix/Example/ExplicitAuth/Login*', parents=()), ConfigLine(config_line='    success-match-type cookie', parents=()), ConfigLine(config_line='    success-match-value CtxsAuthId', parents=()), ConfigLine(config_line='}', parents=())]\n        \"\"\"\n        multiline_config = [prev_line]\n        for line in self.generator_config:\n            multiline_config.append(line)\n            if line.endswith(delimiter):\n                multiline_entry = ConfigLine(\"\\n\".join(multiline_config), self._current_parents)\n                self.config_lines[-1] = multiline_entry\n                self._current_parents = self._current_parents[:-1]\n                return multiline_entry\n        return None\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.F5ConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.F5ConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config: The config text to parse.\n    \"\"\"\n    super().__init__(self._clean_config_f5(config))\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.F5ConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import F5ConfigParser, ConfigLine\n&gt;&gt;&gt; config = '''apm resource webtop-link aShare {\n...     application-uri http://funshare.example.com\n...     customization-group a_customization_group\n... }\n... apm sso form-based portal_ext_sso_form_based {\n...     form-action /Citrix/Example/ExplicitAuth/LoginAttempt\n...     form-field \"LoginBtn Log+On\n... StateContext \"\n...     form-password password\n...     form-username username\n...     passthru true\n...     start-uri /Citrix/Example/ExplicitAuth/Login*\n...     success-match-type cookie\n...     success-match-value CtxsAuthId\n... }\n... '''\n&gt;&gt;&gt;\n&gt;&gt;&gt; config_tree = F5ConfigParser(config)\n&gt;&gt;&gt; print(config_tree.build_config_relationship())\n[ConfigLine(config_line='apm resource webtop-link aShare {', parents=()), ConfigLine(config_line='    application-uri http://funshare.example.com', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='    customization-group a_customization_group', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='}', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='apm sso form-based portal_ext_sso_form_based {', parents=()), ConfigLine(config_line='    form-action /Citrix/Example/ExplicitAuth/LoginAttempt', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-field \"LoginBtn Log+On\\nStateContext \"', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-password password', parents=()), ConfigLine(config_line='    form-username username', parents=()), ConfigLine(config_line='    passthru true', parents=()), ConfigLine(config_line='    start-uri /Citrix/Example/ExplicitAuth/Login*', parents=()), ConfigLine(config_line='    success-match-type cookie', parents=()), ConfigLine(config_line='    success-match-value CtxsAuthId', parents=()), ConfigLine(config_line='}', parents=())]\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text tree of config lines and their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import F5ConfigParser, ConfigLine\n        &gt;&gt;&gt; config = '''apm resource webtop-link aShare {\n        ...     application-uri http://funshare.example.com\n        ...     customization-group a_customization_group\n        ... }\n        ... apm sso form-based portal_ext_sso_form_based {\n        ...     form-action /Citrix/Example/ExplicitAuth/LoginAttempt\n        ...     form-field \"LoginBtn Log+On\n        ... StateContext \"\n        ...     form-password password\n        ...     form-username username\n        ...     passthru true\n        ...     start-uri /Citrix/Example/ExplicitAuth/Login*\n        ...     success-match-type cookie\n        ...     success-match-value CtxsAuthId\n        ... }\n        ... '''\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; config_tree = F5ConfigParser(config)\n        &gt;&gt;&gt; print(config_tree.build_config_relationship())\n        [ConfigLine(config_line='apm resource webtop-link aShare {', parents=()), ConfigLine(config_line='    application-uri http://funshare.example.com', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='    customization-group a_customization_group', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='}', parents=('apm resource webtop-link aShare {',)), ConfigLine(config_line='apm sso form-based portal_ext_sso_form_based {', parents=()), ConfigLine(config_line='    form-action /Citrix/Example/ExplicitAuth/LoginAttempt', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-field \"LoginBtn Log+On\\nStateContext \"', parents=('apm sso form-based portal_ext_sso_form_based {',)), ConfigLine(config_line='    form-password password', parents=()), ConfigLine(config_line='    form-username username', parents=()), ConfigLine(config_line='    passthru true', parents=()), ConfigLine(config_line='    start-uri /Citrix/Example/ExplicitAuth/Login*', parents=()), ConfigLine(config_line='    success-match-type cookie', parents=()), ConfigLine(config_line='    success-match-value CtxsAuthId', parents=()), ConfigLine(config_line='}', parents=())]\n    \"\"\"\n    for line in self.generator_config:\n        self.config_lines.append(ConfigLine(line, self._current_parents))\n        line_end = line[-1]\n        if line.endswith(\"{\"):\n            self._current_parents += (line,)\n        elif line.lstrip() == \"}\":\n            self._current_parents = self._current_parents[:-1]\n        elif any(\n            delimiters in self.multiline_delimiters and line.count(delimiters) == 1\n            for delimiters in self.multiline_delimiters\n        ):\n            for delimiter in self.multiline_delimiters:\n                if line.count(delimiter) == 1:\n                    self._build_multiline_single_configuration_line(delimiter, line)\n        elif line_end in self.multiline_delimiters and line.count(line_end) == 1:\n            self._current_parents += (line,)\n            self._build_multiline_config(line_end)\n\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FastironConfigParser","title":"<code>FastironConfigParser</code>","text":"<p>               Bases: <code>CiscoConfigParser</code></p> <p>Ruckus FastIron ICX config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class FastironConfigParser(CiscoConfigParser):\n    \"\"\"Ruckus FastIron ICX config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"!\"]\n    banner_start: t.List[str] = [\"banner motd\", \"banner\"]\n    regex_banner = re.compile(r\"^banner(\\smotd)?\\s+(?P&lt;banner_delimiter&gt;\\S)\")\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        super(FastironConfigParser, self).__init__(config)\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.banner_end):\n                    banner, end, _ = line.rpartition(self.banner_end)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FastironConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    super(FastironConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FortinetConfigParser","title":"<code>FortinetConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Fortinet Fortios config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class FortinetConfigParser(BaseSpaceConfigParser):\n    \"\"\"Fortinet Fortios config parser.\"\"\"\n\n    comment_chars: t.List[str] = []\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Fortinet FortiOS platform doesn't have a banner.\")\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.uncommon_data = self._get_uncommon_lines(config)\n        super(FortinetConfigParser, self).__init__(config)\n\n    def is_end_next(self, line: str) -&gt; bool:\n        \"\"\"Determine if line has 'end' or 'next' in it.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line has 'end' or 'next', else False.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import FortinetConfigParser\n            &gt;&gt;&gt; FortinetConfigParser(\"config system virtual-switch\").is_end_next(\"config system virtual-switch\")\n            False\n            &gt;&gt;&gt; FortinetConfigParser(\"end\").is_end_next(\"end\")\n            True\n            &gt;&gt;&gt;\n        \"\"\"\n        for end_next in [\"end\", \"next\"]:\n            if line.lstrip() == end_next:\n                return True\n        return False\n\n    def _parse_out_offending(self, config: str) -&gt; str:\n        \"\"\"Preprocess out strings that offend the normal spaced configuration syntax.\n\n        Args:\n            config (str): full config as a string.\n        \"\"\"\n        # This will grab everything between quotes after the 'set buffer' sub-command.\n        # Its explicitly looking for \"\\n to end the captured data.  This is to support html\n        # data that is supported in Fortinet config with double quotes within the html.\n        pattern = r\"(config system replacemsg.*(\\\".*\\\")\\n)(\\s{4}set\\sbuffer\\s\\\"[\\S\\s]*?\\\"\\n)\"\n        return re.sub(pattern, r\"\\1    [\\2]\\n\", config)\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove spaces and comments from config lines.\n\n        Returns:\n            The non-space and non-comment lines from ``config``.\n        \"\"\"\n        # Specific to fortinet to remove uncommon data patterns for use later in _build_nested_config.\n        self.config = self._parse_out_offending(self.config)\n        if self._config is None:\n            config_lines = (\n                line.rstrip()\n                for line in self.config.splitlines()\n                if line and not self.is_comment(line) and not line.isspace() and not self.is_end_next(line)\n            )\n            self._config = \"\\n\".join(config_lines)\n        return self._config\n\n    def _get_uncommon_lines(self, config: str) -&gt; t.Dict[str, str]:\n        \"\"\"Regex to find replacemsg lines which can contain html/css data.\n\n        Args:\n            config: Original config before parsing.\n\n        Returns:\n            dict: dictionary with replace message name as key, html/css data as value.\n        \"\"\"\n        pattern = r\"(config system replacemsg.*\\n)(\\s{4}set\\sbuffer\\s\\\"[\\S\\s]*?\\\"\\n)\"\n        regex_result = re.findall(pattern, config)\n        result = {}\n        for group_match in regex_result:\n            result.update({group_match[0].split('\"')[1]: group_match[1]})\n        return result\n\n    def _build_nested_config(self, line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle building child config sections.\n\n        Args:\n            line: A configuration line from the configuration text.\n\n        Returns:\n            The next top-level configuration line in the configuration text or None when the last line of configuration\n            text is a nested configuration line.\n\n        Raises:\n            IndexError: When the number of parents does not match the expected deindent level.\n        \"\"\"\n        if \"[\" in line:\n            updated_line = self.uncommon_data.get(line.split('\"')[1], None)\n            if not updated_line:\n                raise ValueError(\"Input line is malformed.\")\n            line = updated_line\n        self._update_config_lines(line)\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                self.indent_level = 0\n                return line\n\n            spaces = self.get_leading_space_count(line)\n            if spaces == self.indent_level:\n                pass\n            elif spaces &gt; self.indent_level:\n                previous_config = self.config_lines[-1]\n                self._current_parents += (previous_config.config_line,)\n            else:\n                self._current_parents = self._remove_parents(line, spaces)\n\n            if spaces != self.indent_level:\n                self.indent_level = spaces\n\n            self._update_config_lines(line)\n        return None\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FortinetConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FortinetConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove spaces and comments from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space and non-comment lines from <code>config</code>.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FortinetConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    self.uncommon_data = self._get_uncommon_lines(config)\n    super(FortinetConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.FortinetConfigParser.is_end_next","title":"<code>is_end_next(line)</code>","text":"<p>Determine if line has 'end' or 'next' in it.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A config line from the device.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if line has 'end' or 'next', else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import FortinetConfigParser\n&gt;&gt;&gt; FortinetConfigParser(\"config system virtual-switch\").is_end_next(\"config system virtual-switch\")\nFalse\n&gt;&gt;&gt; FortinetConfigParser(\"end\").is_end_next(\"end\")\nTrue\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_end_next(self, line: str) -&gt; bool:\n    \"\"\"Determine if line has 'end' or 'next' in it.\n\n    Args:\n        line: A config line from the device.\n\n    Returns:\n        True if line has 'end' or 'next', else False.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import FortinetConfigParser\n        &gt;&gt;&gt; FortinetConfigParser(\"config system virtual-switch\").is_end_next(\"config system virtual-switch\")\n        False\n        &gt;&gt;&gt; FortinetConfigParser(\"end\").is_end_next(\"end\")\n        True\n        &gt;&gt;&gt;\n    \"\"\"\n    for end_next in [\"end\", \"next\"]:\n        if line.lstrip() == end_next:\n            return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPComwareConfigParser","title":"<code>HPComwareConfigParser</code>","text":"<p>               Bases: <code>HPEConfigParser</code>, <code>BaseSpaceConfigParser</code></p> <p>HP Comware Implementation of ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class HPComwareConfigParser(HPEConfigParser, BaseSpaceConfigParser):\n    \"\"\"HP Comware Implementation of ConfigParser Class.\"\"\"\n\n    banner_start: t.List[str] = [\"header \"]\n    comment_chars: t.List[str] = [\"#\"]\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Build a banner from the given config line.\"\"\"\n        return super(HPComwareConfigParser, self)._build_banner(config_line)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPEConfigParser","title":"<code>HPEConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>HPE Implementation of ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class HPEConfigParser(BaseSpaceConfigParser):\n    \"\"\"HPE Implementation of ConfigParser Class.\"\"\"\n\n    regex_banner = re.compile(r\"^header\\s(\\w+)\\s+(?P&lt;banner_delimiter&gt;\\^C|\\S?)\")\n\n    def __init__(self, config: str):\n        \"\"\"Initialize the HPEConfigParser object.\"\"\"\n        self.delimiter = \"\"\n        self._banner_end: t.Optional[str] = None\n        super(HPEConfigParser, self).__init__(config)\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"\n        Builds a banner configuration based on the given config_line.\n\n        Args:\n            config_line (str): The configuration line to process.\n\n        Returns:\n            Optional[str]: The next configuration line, or None if there are no more lines.\n\n        Raises:\n            ValueError: If the banner end cannot be parsed.\n        \"\"\"\n        if self.is_banner_one_line(config_line):\n            self._update_config_lines(config_line)\n            try:\n                return next(self.generator_config)\n            except StopIteration:\n                return None\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.delimiter):\n                    banner, end, _ = line.rpartition(self.delimiter)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner end.\")\n\n    def set_delimiter(self, config_line: str) -&gt; None:\n        \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n        banner_parsed = self.regex_banner.match(config_line)\n        if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n            self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n            return None\n        raise ValueError(\"Unable to find banner delimiter.\")\n\n    def is_banner_one_line(self, config_line: str) -&gt; bool:\n        \"\"\"Checks if the given configuration line represents a one-line banner.\"\"\"\n        self.set_delimiter(config_line.strip())\n        _, _delimeter, banner = config_line.partition(self.delimiter)\n        banner_config_start = banner.lstrip(_delimeter)\n        if _delimeter not in banner_config_start:\n            return False\n        return True\n\n    def is_banner_start(self, line: str) -&gt; bool:\n        \"\"\"Checks if the given line is the start of a banner.\"\"\"\n        state = super(HPEConfigParser, self).is_banner_start(line)\n        if state:\n            self.banner_end = line\n        return state\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Get the banner end.\"\"\"\n        if self._banner_end is None:\n            raise RuntimeError(\"Banner end not yet set.\")\n        return self._banner_end\n\n    @banner_end.setter\n    def banner_end(self, banner_start_line: str) -&gt; None:\n        \"\"\"Sets the delimiter for the end of the banner.\"\"\"\n        self.set_delimiter(banner_start_line.strip())\n        self._banner_end = self.delimiter\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPEConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code> <code>writable</code>","text":"<p>Get the banner end.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPEConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the HPEConfigParser object.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Initialize the HPEConfigParser object.\"\"\"\n    self.delimiter = \"\"\n    self._banner_end: t.Optional[str] = None\n    super(HPEConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPEConfigParser.is_banner_one_line","title":"<code>is_banner_one_line(config_line)</code>","text":"<p>Checks if the given configuration line represents a one-line banner.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_one_line(self, config_line: str) -&gt; bool:\n    \"\"\"Checks if the given configuration line represents a one-line banner.\"\"\"\n    self.set_delimiter(config_line.strip())\n    _, _delimeter, banner = config_line.partition(self.delimiter)\n    banner_config_start = banner.lstrip(_delimeter)\n    if _delimeter not in banner_config_start:\n        return False\n    return True\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPEConfigParser.is_banner_start","title":"<code>is_banner_start(line)</code>","text":"<p>Checks if the given line is the start of a banner.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_start(self, line: str) -&gt; bool:\n    \"\"\"Checks if the given line is the start of a banner.\"\"\"\n    state = super(HPEConfigParser, self).is_banner_start(line)\n    if state:\n        self.banner_end = line\n    return state\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.HPEConfigParser.set_delimiter","title":"<code>set_delimiter(config_line)</code>","text":"<p>Find delimiter character in banner and set self.delimiter to be it.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def set_delimiter(self, config_line: str) -&gt; None:\n    \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n    banner_parsed = self.regex_banner.match(config_line)\n    if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n        self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n        return None\n    raise ValueError(\"Unable to find banner delimiter.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSConfigParser","title":"<code>IOSConfigParser</code>","text":"<p>               Bases: <code>CiscoConfigParser</code>, <code>BaseSpaceConfigParser</code></p> <p>Cisco IOS implementation of ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class IOSConfigParser(CiscoConfigParser, BaseSpaceConfigParser):\n    \"\"\"Cisco IOS implementation of ConfigParser Class.\"\"\"\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.unique_config_lines: t.Set[ConfigLine] = set()\n        self.same_line_children: t.Set[ConfigLine] = set()\n        super(IOSConfigParser, self).__init__(config)\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        config_line = normalise_delimiter_caret_c(self.banner_end, config_line)\n        return super(IOSConfigParser, self)._build_banner(config_line)\n\n    def _update_same_line_children_configs(self) -&gt; None:\n        \"\"\"Update parents in ``self.config_lines`` per ``self.same_line_children``.\"\"\"\n        new_config_lines: t.List[ConfigLine] = []\n        for line in self.config_lines:\n            if line in self.same_line_children:\n                try:\n                    previous_line = new_config_lines[-1]\n                except IndexError as error:\n                    raise IndexError(\n                        f\"This error is likely from a duplicate line detected at the line `{line.config_line}`, \"\n                        \"see https://netutils.readthedocs.io/en/latest/dev/dev_config/#duplicate-line-detection \"\n                        f\"for more details.\\nOriginal Error: {error}\"\n                    )\n                previous_config_line = previous_line.config_line\n                current_parents = previous_line.parents + (previous_config_line,)\n                line = ConfigLine(line.config_line, current_parents)\n            new_config_lines.append(line)\n        self.config_lines = new_config_lines\n\n    def _update_config_lines(self, config_line: str) -&gt; None:\n        \"\"\"Add a ``ConfigLine`` object to ``self.config_lines``.\n\n        In addition to adding entries to config_lines, this also updates:\n          * self.same_line_children\n          * self.unique_config_lines\n\n        Args:\n            config_line: The current config line being evaluated.\n\n        Returns:\n            None\n        \"\"\"\n        super(IOSConfigParser, self)._update_config_lines(config_line)\n        entry = self.config_lines[-1]\n        if entry in self.unique_config_lines:\n            self.same_line_children.add(entry)\n        self.unique_config_lines.add(entry)\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import IOSConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''\n            ... interface Ethernet1/1\n            ...   vlan 10\n            ...   no shutdown\n            ... interface Ethernet1/2\n            ...   shutdown'''\n            &gt;&gt;&gt; config_tree = IOSConfigParser(str(config))\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='interface Ethernet1/2', parents=()),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n            ... ]\n            True\n        \"\"\"\n        super(IOSConfigParser, self).build_config_relationship()\n        self._update_same_line_children_configs()\n        return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    self.unique_config_lines: t.Set[ConfigLine] = set()\n    self.same_line_children: t.Set[ConfigLine] = set()\n    super(IOSConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import IOSConfigParser, ConfigLine\n&gt;&gt;&gt; config = '''\n... interface Ethernet1/1\n...   vlan 10\n...   no shutdown\n... interface Ethernet1/2\n...   shutdown'''\n&gt;&gt;&gt; config_tree = IOSConfigParser(str(config))\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n...     ConfigLine(config_line='interface Ethernet1/2', parents=()),\n...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text tree of config lines and their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import IOSConfigParser, ConfigLine\n        &gt;&gt;&gt; config = '''\n        ... interface Ethernet1/1\n        ...   vlan 10\n        ...   no shutdown\n        ... interface Ethernet1/2\n        ...   shutdown'''\n        &gt;&gt;&gt; config_tree = IOSConfigParser(str(config))\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n        ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n        ...     ConfigLine(config_line='  no shutdown', parents=('interface Ethernet1/1',)),\n        ...     ConfigLine(config_line='interface Ethernet1/2', parents=()),\n        ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/2',))\n        ... ]\n        True\n    \"\"\"\n    super(IOSConfigParser, self).build_config_relationship()\n    self._update_same_line_children_configs()\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSXRConfigParser","title":"<code>IOSXRConfigParser</code>","text":"<p>               Bases: <code>CiscoConfigParser</code></p> <p>IOS-XR config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class IOSXRConfigParser(CiscoConfigParser):\n    \"\"\"IOS-XR config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"!\"]\n    banner_start: t.List[str] = [\"banner \"]\n\n    regex_banner = re.compile(r\"^banner\\s+\\S+\\s+(?P&lt;banner_delimiter&gt;\\S)\")\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.delimiter = \"\"\n        super(IOSXRConfigParser, self).__init__(config)\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                if line.endswith(self.delimiter):\n                    banner, end, _ = line.rpartition(self.delimiter)\n                    line = banner + end\n                self._update_config_lines(line)\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n\n    def set_delimiter(self, config_line: str) -&gt; None:\n        \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n        banner_parsed = self.regex_banner.match(config_line)\n        if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n            self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n            return None\n        raise ValueError(\"Unable to find banner delimiter.\")\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text tree of config lines and their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import IOSXRConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"interface Ethernet1/1\\n\"\n            ...     \"  vlan 10\\n\"\n            ...     \"  no shutdown\"\n            ...     \"interface Ethernet1/2\\n\"\n            ...     \"  shutdown\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = IOSXRConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n            ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  no shutdowninterface Ethernet1/2', parents=('interface Ethernet1/1',)),\n            ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/1',))\n            ... ]\n            True\n        \"\"\"\n        for index, line in enumerate(self.generator_config):\n            current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n\n            if index == 0 and line[0].isspace():\n                self._current_parents = self._remove_parents(line, current_spaces)\n            if not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    if not self.delimiter:\n                        self.set_delimiter(line)\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                line = self._build_nested_config(line)  # type: ignore\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSXRConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    self.delimiter = \"\"\n    super(IOSXRConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSXRConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text tree of config lines and their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import IOSXRConfigParser, ConfigLine\n&gt;&gt;&gt; config = (\n...     \"interface Ethernet1/1\\n\"\n...     \"  vlan 10\\n\"\n...     \"  no shutdown\"\n...     \"interface Ethernet1/2\\n\"\n...     \"  shutdown\\n\"\n... )\n&gt;&gt;&gt; config_tree = IOSXRConfigParser(config)\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n...     ConfigLine(config_line='  no shutdowninterface Ethernet1/2', parents=('interface Ethernet1/1',)),\n...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/1',))\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text tree of config lines and their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import IOSXRConfigParser, ConfigLine\n        &gt;&gt;&gt; config = (\n        ...     \"interface Ethernet1/1\\n\"\n        ...     \"  vlan 10\\n\"\n        ...     \"  no shutdown\"\n        ...     \"interface Ethernet1/2\\n\"\n        ...     \"  shutdown\\n\"\n        ... )\n        &gt;&gt;&gt; config_tree = IOSXRConfigParser(config)\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line='interface Ethernet1/1', parents=()),\n        ...     ConfigLine(config_line='  vlan 10', parents=('interface Ethernet1/1',)),\n        ...     ConfigLine(config_line='  no shutdowninterface Ethernet1/2', parents=('interface Ethernet1/1',)),\n        ...     ConfigLine(config_line='  shutdown', parents=('interface Ethernet1/1',))\n        ... ]\n        True\n    \"\"\"\n    for index, line in enumerate(self.generator_config):\n        current_spaces = self.get_leading_space_count(line) if line[0].isspace() else 0\n\n        if index == 0 and line[0].isspace():\n            self._current_parents = self._remove_parents(line, current_spaces)\n        if not line[0].isspace():\n            self._current_parents = ()\n            if self.is_banner_start(line):\n                if not self.delimiter:\n                    self.set_delimiter(line)\n                line = self._build_banner(line)  # type: ignore\n        else:\n            previous_config = self.config_lines[-1]\n            self._current_parents = (previous_config.config_line,)\n            self.indent_level = self.get_leading_space_count(line)\n            line = self._build_nested_config(line)  # type: ignore\n\n        if line is None:\n            break\n        elif self.is_banner_start(line):\n            line = self._build_banner(line)  # type: ignore\n\n        self._update_config_lines(line)\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.IOSXRConfigParser.set_delimiter","title":"<code>set_delimiter(config_line)</code>","text":"<p>Find delimiter character in banner and set self.delimiter to be it.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def set_delimiter(self, config_line: str) -&gt; None:\n    \"\"\"Find delimiter character in banner and set self.delimiter to be it.\"\"\"\n    banner_parsed = self.regex_banner.match(config_line)\n    if banner_parsed and \"banner_delimiter\" in banner_parsed.groupdict():\n        self.delimiter = banner_parsed.groupdict()[\"banner_delimiter\"]\n        return None\n    raise ValueError(\"Unable to find banner delimiter.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.JunosConfigParser","title":"<code>JunosConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Junos config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class JunosConfigParser(BaseSpaceConfigParser):\n    \"\"\"Junos config parser.\"\"\"\n\n    comment_chars: t.List[str] = []\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Junos platform doesn't have a banner.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.JunosConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.LINUXConfigParser","title":"<code>LINUXConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Linux config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class LINUXConfigParser(BaseSpaceConfigParser):\n    \"\"\"Linux config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\"]\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Linux platform doesn't have a banner.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.LINUXConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NXOSConfigParser","title":"<code>NXOSConfigParser</code>","text":"<p>               Bases: <code>CiscoConfigParser</code>, <code>BaseSpaceConfigParser</code></p> <p>NXOS implementation of ConfigParser Class.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class NXOSConfigParser(CiscoConfigParser, BaseSpaceConfigParser):\n    \"\"\"NXOS implementation of ConfigParser Class.\"\"\"\n\n    regex_banner = re.compile(r\"^banner\\s+\\S+\\s+(?P&lt;banner_delimiter&gt;\\S)\")\n\n    def __init__(self, config: str):\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config (str): The config text to parse.\n        \"\"\"\n        self.unique_config_lines: t.Set[ConfigLine] = set()\n        self.same_line_children: t.Set[ConfigLine] = set()\n        super(NXOSConfigParser, self).__init__(config)\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        config_line = normalise_delimiter_caret_c(self.banner_end, config_line)\n        return super(NXOSConfigParser, self)._build_banner(config_line)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NXOSConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config (str): The config text to parse.\n    \"\"\"\n    self.unique_config_lines: t.Set[ConfigLine] = set()\n    self.same_line_children: t.Set[ConfigLine] = set()\n    super(NXOSConfigParser, self).__init__(config)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NetironConfigParser","title":"<code>NetironConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Extreme Netiron config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class NetironConfigParser(BaseSpaceConfigParser):\n    \"\"\"Extreme Netiron config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\", \"!\"]\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Extreme Netiron platform doesn't have a banner.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NetironConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NetscalerConfigParser","title":"<code>NetscalerConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Netscaler config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class NetscalerConfigParser(BaseSpaceConfigParser):\n    \"\"\"Netscaler config parser.\"\"\"\n\n    comment_chars: t.List[str] = []\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Netscaler platform doesn't have a banner.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NetscalerConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NokiaConfigParser","title":"<code>NokiaConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Nokia SrOS config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class NokiaConfigParser(BaseSpaceConfigParser):\n    \"\"\"Nokia SrOS config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\"]\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Nokia SROS platform doesn't have a banner.\")\n\n    def _is_section_title(self, line: str) -&gt; bool:\n        \"\"\"Determine if line is a section title in banner.\n\n        Args:\n            line: A config line from the device.\n\n        Returns:\n            True if line is a section, else False.\n        \"\"\"\n        if re.match(r\"^echo\\s\\\".+\\\"\", string=line):\n            return True\n        return False\n\n    def _get_section_title(self, line: str) -&gt; t.Union[str, bool]:\n        \"\"\"Determine section title from banner.\n\n        Args:\n            line: A config line from the device that has been found to be a section title.\n\n        Returns:\n            The section's title from the section banner, else False.\n        \"\"\"\n        section_title = re.match(r\"^echo\\s\\\"(?P&lt;section_name&gt;.+)\\\"\", string=line)\n        if section_title:\n            return section_title.group(\"section_name\")\n        return False\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove spaces and comments from config lines.\n\n        Returns:\n            The non-space and non-comment lines from ``config``.\n        \"\"\"\n        if self._config is None:\n            config_lines = []\n            for line in self.config.splitlines():\n                if line and not self.is_comment(line) and not line.isspace():\n                    if self._is_section_title(line):\n                        section_title = self._get_section_title(line)\n                        # At this point it is safe to assume that self._get_section_title returns a string, not a bool.\n                        # The following line passes this assumption to Mypy.\n                        assert isinstance(section_title, str)  # noqa: S101\n                        config_lines.append(section_title)\n                    else:\n                        config_lines.append(line.rstrip())\n            self._config = \"\\n\".join(config_lines)\n        return self._config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NokiaConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NokiaConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove spaces and comments from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space and non-comment lines from <code>config</code>.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NvidiaOnyxConfigParser","title":"<code>NvidiaOnyxConfigParser</code>","text":"<p>               Bases: <code>BaseConfigParser</code></p> <p>Nvidia Onyx config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class NvidiaOnyxConfigParser(BaseConfigParser):  # pylint: disable=abstract-method\n    \"\"\"Nvidia Onyx config parser.\"\"\"\n\n    comment_char = \"#\"\n    section_char = \"##\"\n\n    def __init__(self, config: str):  # pylint: disable=super-init-not-called\n        \"\"\"Create ConfigParser Object.\n\n        Args:\n            config: The config text to parse.\n        \"\"\"\n        self.config = config\n        self._config: t.Optional[str] = None\n        self._current_parents: t.Tuple[str, ...] = ()\n        self.generator_config = (line for line in (self._config_lines_only()))\n        self.config_lines: t.List[ConfigLine] = []\n        self.build_config_relationship()\n\n    def _config_lines_only(self) -&gt; t.List[str]:\n        \"\"\"Remove spaces and unwanted lines from config lines.\n\n        Returns:\n            An array with non-space and non-comment lines from ``config``.\n        \"\"\"\n        banner_text = \"\"\n        config_lines = []\n        for line in self.config.splitlines():\n            if line.startswith(self.section_char):\n                continue\n            stripped = line.strip()\n            if re.match(r\"banner \\w+ (?!\\\".+\\\")\", stripped):\n                banner_text += line.lstrip()\n            elif banner_text and not stripped.endswith('\"'):\n                banner_text += \"\\n\" + line\n            elif banner_text and stripped.endswith('\"'):\n                banner_text += \"\\n\" + line\n                config_lines.append(banner_text)\n                banner_text = \"\"\n            elif stripped:\n                config_lines.append(stripped)\n\n        return config_lines\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove spaces and unwanted lines from config lines.\n\n        Returns:\n            The non-space and non-comment lines from ``config``.\n        \"\"\"\n        return \"\\n\".join(self._config_lines_only())\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n        r\"\"\"Parse text config lines and banners.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n            &gt;&gt;&gt; config = '''\n            ...     ##\n            ...     ## VLAN configuration\n            ...     ##\n            ...        vlan 1\n            ...        vlan 2\n            ...        vlan 3\n            ...\n            ...     ##\n            ...     ## Network management configuration\n            ...     ##\n            ...        banner login \"\n            ...\n            ...        MULTILINE BANNER\"'''\n            &gt;&gt;&gt; config_tree = NvidiaOnyxConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line='vlan 1', parents=()),\n            ...     ConfigLine(config_line='vlan 2', parents=()),\n            ...     ConfigLine(config_line='vlan 3', parents=()),\n            ...     ConfigLine(config_line='banner login \"\\n\\n       MULTILINE BANNER\"', parents=()),\n            ... ]\n            True\n        \"\"\"\n        for line in self.generator_config:\n            if not line.startswith(self.comment_char):\n                self.config_lines.append(ConfigLine(line, ()))\n\n        return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NvidiaOnyxConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove spaces and unwanted lines from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space and non-comment lines from <code>config</code>.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NvidiaOnyxConfigParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Create ConfigParser Object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The config text to parse.</p> required Source code in <code>netutils/config/parser.py</code> <pre><code>def __init__(self, config: str):  # pylint: disable=super-init-not-called\n    \"\"\"Create ConfigParser Object.\n\n    Args:\n        config: The config text to parse.\n    \"\"\"\n    self.config = config\n    self._config: t.Optional[str] = None\n    self._current_parents: t.Tuple[str, ...] = ()\n    self.generator_config = (line for line in (self._config_lines_only()))\n    self.config_lines: t.List[ConfigLine] = []\n    self.build_config_relationship()\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.NvidiaOnyxConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text config lines and banners.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n&gt;&gt;&gt; config = '''\n...     ##\n...     ## VLAN configuration\n...     ##\n...        vlan 1\n...        vlan 2\n...        vlan 3\n...\n...     ##\n...     ## Network management configuration\n...     ##\n...        banner login \"\n...\n...        MULTILINE BANNER\"'''\n&gt;&gt;&gt; config_tree = NvidiaOnyxConfigParser(config)\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line='vlan 1', parents=()),\n...     ConfigLine(config_line='vlan 2', parents=()),\n...     ConfigLine(config_line='vlan 3', parents=()),\n...     ConfigLine(config_line='banner login \"\\n\\n       MULTILINE BANNER\"', parents=()),\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:\n    r\"\"\"Parse text config lines and banners.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import BaseSpaceConfigParser, ConfigLine\n        &gt;&gt;&gt; config = '''\n        ...     ##\n        ...     ## VLAN configuration\n        ...     ##\n        ...        vlan 1\n        ...        vlan 2\n        ...        vlan 3\n        ...\n        ...     ##\n        ...     ## Network management configuration\n        ...     ##\n        ...        banner login \"\n        ...\n        ...        MULTILINE BANNER\"'''\n        &gt;&gt;&gt; config_tree = NvidiaOnyxConfigParser(config)\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line='vlan 1', parents=()),\n        ...     ConfigLine(config_line='vlan 2', parents=()),\n        ...     ConfigLine(config_line='vlan 3', parents=()),\n        ...     ConfigLine(config_line='banner login \"\\n\\n       MULTILINE BANNER\"', parents=()),\n        ... ]\n        True\n    \"\"\"\n    for line in self.generator_config:\n        if not line.startswith(self.comment_char):\n            self.config_lines.append(ConfigLine(line, ()))\n\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.OptiswitchConfigParser","title":"<code>OptiswitchConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>MRV Optiswitch config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class OptiswitchConfigParser(BaseSpaceConfigParser):\n    \"\"\"MRV Optiswitch config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\", \"!\"]\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"MRV Optiswitch platform doesn't have a banner.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.OptiswitchConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.PaloAltoNetworksConfigParser","title":"<code>PaloAltoNetworksConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Palo Alto Networks config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class PaloAltoNetworksConfigParser(BaseSpaceConfigParser):\n    \"\"\"Palo Alto Networks config parser.\"\"\"\n\n    comment_chars: t.List[str] = []\n    banner_start: t.List[str] = [\n        'set system login-banner \"',\n        'login-banner \"',\n        'set deviceconfig system login-banner \"',\n    ]\n    banner_end = '\"'\n\n    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if end of banner.\"\"\"\n        if line.endswith('\"') or line.startswith('\";') or line.startswith(\"set\") or line.endswith(self.banner_end):\n            return True\n        return False\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner config.\n\n        Returns:\n            The next configuration line in the configuration text or None\n\n        Raises:\n            ValueError: When the parser is unable to identify the end of the Banner.\n        \"\"\"\n        self._update_config_lines(config_line)\n        self._current_parents += (config_line,)\n        banner_config = []\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                line = normalise_delimiter_caret_c(self.banner_end, line)\n                banner_config.append(line.strip())\n                line = \"\\n\".join(banner_config)\n                if line.endswith(\"^C\"):\n                    banner, end, _ = line.rpartition(\"^C\")\n                    line = banner + end\n                self._update_config_lines(line.strip())\n                self._current_parents = self._current_parents[:-1]\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n\n        raise ValueError(\"Unable to parse banner end.\")\n\n    def build_config_relationship(self) -&gt; t.List[ConfigLine]:  # pylint: disable=too-many-branches\n        r\"\"\"Parse text of config lines and find their parents.\n\n        Examples:\n            &gt;&gt;&gt; from netutils.config.parser import PaloAltoNetworksConfigParser, ConfigLine\n            &gt;&gt;&gt; config = (\n            ...     \"set deviceconfig system hostname firewall1\\n\"\n            ...     \"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\\n\"\n            ...     \"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\\n\"\n            ...     \"set deviceconfig setting config rematch yes\\n\"\n            ... )\n            &gt;&gt;&gt; config_tree = PaloAltoNetworksConfigParser(config)\n            &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n            ... [\n            ...     ConfigLine(config_line=\"set deviceconfig system hostname firewall1\", parents=()),\n            ...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\", parents=()),\n            ...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\", parents=()),\n            ...     ConfigLine(config_line=\"set deviceconfig setting config rematch yes\", parents=()),\n            ... ]\n            True\n        \"\"\"\n        # assume configuration does not need conversion\n        _needs_conversion = False\n\n        # if config is in palo brace format, convert to set\n        if self.config_lines_only is not None:\n            for line in self.config_lines_only.splitlines():\n                if line.endswith(\"{\"):\n                    _needs_conversion = True\n        if _needs_conversion:\n            converted_config = paloalto_panos_brace_to_set(cfg=self.config, cfg_type=\"string\")\n            list_config = converted_config.splitlines()\n            self.generator_config = (line for line in list_config)\n\n        # build config relationships\n        for line in self.generator_config:\n            if not line[0].isspace():\n                self._current_parents = ()\n                if self.is_banner_start(line):\n                    line = self._build_banner(line)  # type: ignore\n            else:\n                previous_config = self.config_lines[-1]\n                self._current_parents = (previous_config.config_line,)\n                self.indent_level = self.get_leading_space_count(line)\n                if not self.is_banner_start(line):\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    line = self._build_banner(line)  # type: ignore\n                    if line is not None and line[0].isspace():\n                        line = self._build_nested_config(line)  # type: ignore\n                    else:\n                        self._current_parents = ()\n\n            if line is None:\n                break\n            elif self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n\n            self._update_config_lines(line)\n        return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.PaloAltoNetworksConfigParser.build_config_relationship","title":"<code>build_config_relationship()</code>","text":"<p>Parse text of config lines and find their parents.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.config.parser import PaloAltoNetworksConfigParser, ConfigLine\n&gt;&gt;&gt; config = (\n...     \"set deviceconfig system hostname firewall1\\n\"\n...     \"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\\n\"\n...     \"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\\n\"\n...     \"set deviceconfig setting config rematch yes\\n\"\n... )\n&gt;&gt;&gt; config_tree = PaloAltoNetworksConfigParser(config)\n&gt;&gt;&gt; config_tree.build_config_relationship() == \\\n... [\n...     ConfigLine(config_line=\"set deviceconfig system hostname firewall1\", parents=()),\n...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\", parents=()),\n...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\", parents=()),\n...     ConfigLine(config_line=\"set deviceconfig setting config rematch yes\", parents=()),\n... ]\nTrue\n</code></pre> Source code in <code>netutils/config/parser.py</code> <pre><code>def build_config_relationship(self) -&gt; t.List[ConfigLine]:  # pylint: disable=too-many-branches\n    r\"\"\"Parse text of config lines and find their parents.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.config.parser import PaloAltoNetworksConfigParser, ConfigLine\n        &gt;&gt;&gt; config = (\n        ...     \"set deviceconfig system hostname firewall1\\n\"\n        ...     \"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\\n\"\n        ...     \"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\\n\"\n        ...     \"set deviceconfig setting config rematch yes\\n\"\n        ... )\n        &gt;&gt;&gt; config_tree = PaloAltoNetworksConfigParser(config)\n        &gt;&gt;&gt; config_tree.build_config_relationship() == \\\n        ... [\n        ...     ConfigLine(config_line=\"set deviceconfig system hostname firewall1\", parents=()),\n        ...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server 10.0.0.1\", parents=()),\n        ...     ConfigLine(config_line=\"set deviceconfig system panorama local-panorama panorama-server-2 10.0.0.2\", parents=()),\n        ...     ConfigLine(config_line=\"set deviceconfig setting config rematch yes\", parents=()),\n        ... ]\n        True\n    \"\"\"\n    # assume configuration does not need conversion\n    _needs_conversion = False\n\n    # if config is in palo brace format, convert to set\n    if self.config_lines_only is not None:\n        for line in self.config_lines_only.splitlines():\n            if line.endswith(\"{\"):\n                _needs_conversion = True\n    if _needs_conversion:\n        converted_config = paloalto_panos_brace_to_set(cfg=self.config, cfg_type=\"string\")\n        list_config = converted_config.splitlines()\n        self.generator_config = (line for line in list_config)\n\n    # build config relationships\n    for line in self.generator_config:\n        if not line[0].isspace():\n            self._current_parents = ()\n            if self.is_banner_start(line):\n                line = self._build_banner(line)  # type: ignore\n        else:\n            previous_config = self.config_lines[-1]\n            self._current_parents = (previous_config.config_line,)\n            self.indent_level = self.get_leading_space_count(line)\n            if not self.is_banner_start(line):\n                line = self._build_nested_config(line)  # type: ignore\n            else:\n                line = self._build_banner(line)  # type: ignore\n                if line is not None and line[0].isspace():\n                    line = self._build_nested_config(line)  # type: ignore\n                else:\n                    self._current_parents = ()\n\n        if line is None:\n            break\n        elif self.is_banner_start(line):\n            line = self._build_banner(line)  # type: ignore\n\n        self._update_config_lines(line)\n    return self.config_lines\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.PaloAltoNetworksConfigParser.is_banner_end","title":"<code>is_banner_end(line)</code>","text":"<p>Determine if end of banner.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_end(self, line: str) -&gt; bool:\n    \"\"\"Determine if end of banner.\"\"\"\n    if line.endswith('\"') or line.startswith('\";') or line.startswith(\"set\") or line.endswith(self.banner_end):\n        return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.RadEtxConfigParser","title":"<code>RadEtxConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Rad ETX config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class RadEtxConfigParser(BaseSpaceConfigParser):\n    \"\"\"Rad ETX config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\", \"configure\", \"admin\", \"file\"]\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Rad ETX platform doesn't have a banner.\")\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove spaces and comments from config lines.\n\n        Returns:\n            The non-space and non-comment lines from ``config``.\n        \"\"\"\n        if self._config is None:\n            config_lines = (\n                line.removeprefix(\"        \")  # Rad ETX uses 8 spaces for initial indentation\n                for line in self.config.splitlines()\n                # if line and not self.is_comment(line) and not line.isspace() and not self.is_exit_or_exit_all(line)\n                if line and not self.is_comment(line) and not line.isspace()\n            )\n            self._config = \"\\n\".join(config_lines)\n        return self._config\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.RadEtxConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.RadEtxConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove spaces and comments from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space and non-comment lines from <code>config</code>.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.RouterOSConfigParser","title":"<code>RouterOSConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Mikrotik RouterOS config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class RouterOSConfigParser(BaseSpaceConfigParser):\n    \"\"\"Mikrotik RouterOS config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\"]\n    banner_start: t.List[str] = [\"/system note set note=\", \"set note=\"]\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Mikrotik platform uses system note as a banner.\")\n\n    def is_banner_end(self, line: str) -&gt; bool:\n        \"\"\"Determine if end of banner.\"\"\"\n        if line.endswith('\"') or line.startswith(\"/\"):\n            return True\n        return False\n\n    def _build_banner(self, config_line: str) -&gt; t.Optional[str]:\n        \"\"\"Handle banner config lines.\n\n        Args:\n            config_line: The start of the banner (system note) config.\n\n        Returns:\n            The next configuration line in the configuration text or None when banner end is the end of the config text.\n\n        Raises:\n            ValueError: When the parser is unable to identify the End of the Banner.\n        \"\"\"\n        banner_config = [config_line]\n        for line in self.generator_config:\n            if not self.is_banner_end(line):\n                banner_config.append(line)\n            else:\n                banner_config.append(line)\n                line = \"\\n\".join(banner_config)\n                self._update_config_lines(line)\n                try:\n                    return next(self.generator_config)\n                except StopIteration:\n                    return None\n        raise ValueError(\"Unable to parse banner (system note) end.\")\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.RouterOSConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.RouterOSConfigParser.is_banner_end","title":"<code>is_banner_end(line)</code>","text":"<p>Determine if end of banner.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>def is_banner_end(self, line: str) -&gt; bool:\n    \"\"\"Determine if end of banner.\"\"\"\n    if line.endswith('\"') or line.startswith(\"/\"):\n        return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.UbiquitiAirOSConfigParser","title":"<code>UbiquitiAirOSConfigParser</code>","text":"<p>               Bases: <code>BaseSpaceConfigParser</code></p> <p>Ubiquiti airOS config parser.</p> Source code in <code>netutils/config/parser.py</code> <pre><code>class UbiquitiAirOSConfigParser(BaseSpaceConfigParser):\n    \"\"\"Ubiquiti airOS config parser.\"\"\"\n\n    comment_chars: t.List[str] = [\"#\", \"###\"]\n    banner_start: t.List[str] = []\n\n    @property\n    def banner_end(self) -&gt; str:\n        \"\"\"Demarcate End of Banner char(s).\"\"\"\n        raise NotImplementedError(\"Ubiquiti airOS platform doesn't have a banner.\")\n\n    @property\n    def config_lines_only(self) -&gt; str:\n        \"\"\"Remove spaces and unwanted lines from config lines.\n\n        Returns:\n            The non-space and non-comment lines from ``config``.\n        \"\"\"\n        config_lines = []\n        config = self.config.strip()\n        for line in config.splitlines():\n            if line.startswith(\"##A\"):\n                config_lines.append(line)\n            if line and line != \"##\" and not self.is_comment(line):\n                config_lines.append(line)\n\n        return \"\\n\".join(config_lines)\n</code></pre>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.UbiquitiAirOSConfigParser.banner_end","title":"<code>banner_end</code>  <code>property</code>","text":"<p>Demarcate End of Banner char(s).</p>"},{"location":"dev/code_reference/configs.html#netutils.config.parser.UbiquitiAirOSConfigParser.config_lines_only","title":"<code>config_lines_only</code>  <code>property</code>","text":"<p>Remove spaces and unwanted lines from config lines.</p> <p>Returns:</p> Type Description <code>str</code> <p>The non-space and non-comment lines from <code>config</code>.</p>"},{"location":"dev/code_reference/configs.html#netutils.config.utils","title":"<code>utils</code>","text":"<p>Utility functions for working with device configurations.</p>"},{"location":"dev/code_reference/dns.html","title":"DNS","text":""},{"location":"dev/code_reference/dns.html#netutils.dns","title":"<code>netutils.dns</code>","text":"<p>Functions for working with DNS.</p>"},{"location":"dev/code_reference/dns.html#netutils.dns.fqdn_to_ip","title":"<code>fqdn_to_ip(hostname)</code>","text":"<p>Provides the IP address(es) of a resolvable name on the machine it is running from.</p> <p>There are many reasons that a valid FQDN may not be resolvable, such as a network error    from your machine to the DNS server, an upstream DNS issue, etc.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>An FQDN that may or may not be resolvable.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The IP Address as a string if only one is found, or a list of IP addresses if multiple are found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.dns import fqdn_to_ip\n&gt;&gt;&gt; from netutils.ip import is_ip\n&gt;&gt;&gt; is_ip(fqdn_to_ip(\"google.com\"))\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Raises:</p> Type Description <code>gaierror</code> <p>If FQDN is not resolvable, leverage is_fqdn_resolvable to check first.</p> Source code in <code>netutils/dns.py</code> <pre><code>def fqdn_to_ip(hostname: str) -&gt; str:\n    \"\"\"Provides the IP address(es) of a resolvable name on the machine it is running from.\n\n       There are many reasons that a valid FQDN may not be resolvable, such as a network error\n       from your machine to the DNS server, an upstream DNS issue, etc.\n\n    Args:\n        hostname: An FQDN that may or may not be resolvable.\n\n    Returns:\n        The IP Address as a string if only one is found, or a list of IP addresses if multiple are found.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.dns import fqdn_to_ip\n        &gt;&gt;&gt; from netutils.ip import is_ip\n        &gt;&gt;&gt; is_ip(fqdn_to_ip(\"google.com\"))\n        True\n        &gt;&gt;&gt;\n\n    Raises:\n        socket.gaierror: If FQDN is not resolvable, leverage is_fqdn_resolvable to check first.\n    \"\"\"\n    # The data structure is complex, only require the first item, and drill down from there.\n    return socket.getaddrinfo(hostname, 0)[0][4][0]  # type: ignore\n</code></pre>"},{"location":"dev/code_reference/dns.html#netutils.dns.is_fqdn_resolvable","title":"<code>is_fqdn_resolvable(hostname)</code>","text":"<p>Verifies whether a hostname is resolvable on the machine it is running from.</p> <p>There are many reasons that a valid FQDN may not be resolvable, such as a network error    from your machine to the DNS server, an upstream DNS issue, etc.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>A FQDN that may or may not be resolvable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The result as to whether or not the domain was valid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.dns import is_fqdn_resolvable\n&gt;&gt;&gt; is_fqdn_resolvable(\"google.com\")\nTrue\n&gt;&gt;&gt; is_fqdn_resolvable(\"nevergonnagiveyouup.pizza\")\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/dns.py</code> <pre><code>def is_fqdn_resolvable(hostname: str) -&gt; bool:\n    \"\"\"Verifies whether a hostname is resolvable on the machine it is running from.\n\n       There are many reasons that a valid FQDN may not be resolvable, such as a network error\n       from your machine to the DNS server, an upstream DNS issue, etc.\n\n    Args:\n        hostname: A FQDN that may or may not be resolvable.\n\n    Returns:\n        The result as to whether or not the domain was valid.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.dns import is_fqdn_resolvable\n        &gt;&gt;&gt; is_fqdn_resolvable(\"google.com\")\n        True\n        &gt;&gt;&gt; is_fqdn_resolvable(\"nevergonnagiveyouup.pizza\")\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    try:\n        socket.getaddrinfo(hostname, 0)\n        return True\n    except socket.error:\n        return False\n</code></pre>"},{"location":"dev/code_reference/hash.html","title":"Hash","text":""},{"location":"dev/code_reference/hash.html#netutils.hash","title":"<code>netutils.hash</code>","text":"<p>Functions for hashing data.</p>"},{"location":"dev/code_reference/hash.html#netutils.hash.hash_data","title":"<code>hash_data(data, algorithm)</code>","text":"<p>Convenience function primarily built to expose hashlib to Jinja.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Data to hash.</p> required <code>algorithm</code> <code>str</code> <p>Hashing algorithm to use.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>Any</code> <p>Hashed data.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Invalid algorithm specified.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.hash import hash_data\n&gt;&gt;&gt; hash_data(\"test\", \"md5\")\n'098f6bcd4621d373cade4e832627b4f6'\n</code></pre> <pre><code>&gt;&gt;&gt; from jinja2 import Environment\n&gt;&gt;&gt; from netutils.utils import jinja2_convenience_function\n&gt;&gt;&gt;\n&gt;&gt;&gt; env = Environment(trim_blocks=True, lstrip_blocks=True)\n&gt;&gt;&gt; env.filters.update(jinja2_convenience_function())\n&gt;&gt;&gt; template_str = \"{{ 'test' | hash_data('md5') }}\"\n&gt;&gt;&gt; template = env.from_string(template_str)\n&gt;&gt;&gt; result = template.render()\n&gt;&gt;&gt; print(result)\n098f6bcd4621d373cade4e832627b4f6\n</code></pre> Source code in <code>netutils/hash.py</code> <pre><code>def hash_data(data: bytes, algorithm: str) -&gt; t.Any:\n    \"\"\"Convenience function primarily built to expose hashlib to Jinja.\n\n    Args:\n        data (bytes): Data to hash.\n        algorithm (str): Hashing algorithm to use.\n\n    Returns:\n        bytes: Hashed data.\n\n    Raises:\n        AttributeError: Invalid algorithm specified.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.hash import hash_data\n        &gt;&gt;&gt; hash_data(\"test\", \"md5\")\n        '098f6bcd4621d373cade4e832627b4f6'\n\n        &gt;&gt;&gt; from jinja2 import Environment\n        &gt;&gt;&gt; from netutils.utils import jinja2_convenience_function\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; env = Environment(trim_blocks=True, lstrip_blocks=True)\n        &gt;&gt;&gt; env.filters.update(jinja2_convenience_function())\n        &gt;&gt;&gt; template_str = \"{{ 'test' | hash_data('md5') }}\"\n        &gt;&gt;&gt; template = env.from_string(template_str)\n        &gt;&gt;&gt; result = template.render()\n        &gt;&gt;&gt; print(result)\n        098f6bcd4621d373cade4e832627b4f6\n    \"\"\"\n    if not isinstance(data, bytes):\n        data = str(data).encode()\n    algorithm = algorithm.lower()\n    hasher = getattr(hashlib, algorithm)\n    return hasher(data).hexdigest()\n</code></pre>"},{"location":"dev/code_reference/interface.html","title":"Interface","text":""},{"location":"dev/code_reference/interface.html#netutils.interface","title":"<code>netutils.interface</code>","text":"<p>Functions for working with interface.</p>"},{"location":"dev/code_reference/interface.html#netutils.interface.CCInt","title":"<code>CCInt</code>","text":"<p>               Bases: <code>CharacterClass</code></p> <p>Ints must be sorted canonically because '11' &lt; '5'.</p> Source code in <code>netutils/interface.py</code> <pre><code>class CCInt(CharacterClass):\n    \"\"\"Ints must be sorted canonically because '11' &lt; '5'.\"\"\"\n\n    def __lt__(self, other: \"CharacterClass\") -&gt; bool:  # noqa: D105\n        return self.weight &lt; other.weight or int(self.val) &lt; int(other.val)\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return f\"CCInt({self.val}, {self.terminal})\"\n\n    @property\n    def weight(self) -&gt; int:  # noqa: D107,D102\n        return 20\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.CCSeparator","title":"<code>CCSeparator</code>","text":"<p>               Bases: <code>CharacterClass</code></p> <p>Separators require custom logic, so we sort them by arbitrary weight.</p> Source code in <code>netutils/interface.py</code> <pre><code>class CCSeparator(CharacterClass):\n    \"\"\"Separators require custom logic, so we sort them by arbitrary weight.\"\"\"\n\n    weights: t.Dict[str, int] = {\".\": 10, \"/\": 20}\n\n    def __lt__(self, other: \"CharacterClass\") -&gt; bool:  # noqa: D105\n        return self.weight &lt; other.weight or self.weights.get(self.val, 0) &lt; self.weights.get(other.val, 0)\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return f'CCSeparator(\"{self.val}\", {self.terminal})'\n\n    @property\n    def weight(self) -&gt; int:  # noqa: D102\n        return 30\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.CCString","title":"<code>CCString</code>","text":"<p>               Bases: <code>CharacterClass</code></p> <p>Strings are sorted lexicographically.</p> Source code in <code>netutils/interface.py</code> <pre><code>class CCString(CharacterClass):\n    \"\"\"Strings are sorted lexicographically.\"\"\"\n\n    def __lt__(self, other: \"CharacterClass\") -&gt; bool:  # noqa: D105\n        return self.weight &lt; other.weight or self.val &lt; other.val\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return f'CCString(\"{self.val}\", {self.terminal})'\n\n    @property\n    def weight(self) -&gt; int:  # noqa: D107,D102\n        return 10\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.CharacterClass","title":"<code>CharacterClass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>CharacterClass embodies the state needed to sort interfaces.</p> Source code in <code>netutils/interface.py</code> <pre><code>@total_ordering\nclass CharacterClass(ABC):\n    \"\"\"CharacterClass embodies the state needed to sort interfaces.\"\"\"\n\n    def __init__(self, val: str, terminal: bool = False) -&gt; None:  # noqa: D107\n        self.val = val\n        self._terminal = terminal\n        super().__init__()\n\n    @abstractmethod\n    def __lt__(self, other: \"CharacterClass\") -&gt; bool:  # noqa: D105\n        ...\n\n    def __eq__(self, other: t.Any) -&gt; t.Any:  # noqa: D105\n        return self.weight == other.weight and self.val == other.val\n\n    @property\n    @abstractmethod\n    def weight(self) -&gt; int:\n        \"\"\"Weight property.\"\"\"\n\n    @property\n    def terminal(self) -&gt; bool:\n        \"\"\"Flag whether a node is terminal.\"\"\"\n        return self._terminal\n\n    @terminal.setter\n    def terminal(self, val: bool) -&gt; None:\n        \"\"\"This is a one-way switch to prevent overwriting a terminal node.\"\"\"\n        if not self._terminal:\n            self._terminal = val\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return str(self.val)\n\n    def __hash__(self) -&gt; int:  # noqa: D105\n        return self.val.__hash__()\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.CharacterClass.terminal","title":"<code>terminal</code>  <code>property</code> <code>writable</code>","text":"<p>Flag whether a node is terminal.</p>"},{"location":"dev/code_reference/interface.html#netutils.interface.CharacterClass.weight","title":"<code>weight</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Weight property.</p>"},{"location":"dev/code_reference/interface.html#netutils.interface.abbreviated_interface_name","title":"<code>abbreviated_interface_name(interface, addl_name_map=None, addl_reverse_map=None, verify=False)</code>","text":"<p>Function to return an abbreviated representation of the interface name.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>The interface you are attempting to shorten.</p> required <code>addl_name_map</code> <code>Optional[Dict[str, str]]</code> <p>A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.</p> <code>None</code> <code>addl_reverse_map</code> <code>Optional[Dict[str, str]]</code> <p>A dict containing key/value pairs that updates the abbreviated mapping. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether or not to verify the interface matches a known interface standard. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The name of the interface in the abbreviated form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import abbreviated_interface_name\n&gt;&gt;&gt; abbreviated_interface_name(\"GigabitEthernet1/0/1\")\n'Gi1/0/1'\n&gt;&gt;&gt; abbreviated_interface_name(\"Eth1\")\n'Et1'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def abbreviated_interface_name(\n    interface: str,\n    addl_name_map: t.Optional[t.Dict[str, str]] = None,\n    addl_reverse_map: t.Optional[t.Dict[str, str]] = None,\n    verify: bool = False,\n) -&gt; str:\n    \"\"\"Function to return an abbreviated representation of the interface name.\n\n    Args:\n        interface: The interface you are attempting to shorten.\n        addl_name_map: A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.\n        addl_reverse_map: A dict containing key/value pairs that updates the abbreviated mapping. Defaults to None.\n        verify: Whether or not to verify the interface matches a known interface standard. Defaults to False.\n\n    Returns:\n        The name of the interface in the abbreviated form.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import abbreviated_interface_name\n        &gt;&gt;&gt; abbreviated_interface_name(\"GigabitEthernet1/0/1\")\n        'Gi1/0/1'\n        &gt;&gt;&gt; abbreviated_interface_name(\"Eth1\")\n        'Et1'\n        &gt;&gt;&gt;\n    \"\"\"\n    name_map = {}\n    name_map.update(BASE_INTERFACES)\n    interface_type, interface_number = split_interface(interface)\n\n    if isinstance(addl_name_map, dict):\n        name_map.update(addl_name_map)\n\n    rev_name_map = {}\n    rev_name_map.update(REVERSE_MAPPING)\n\n    if isinstance(addl_reverse_map, dict):\n        rev_name_map.update(addl_reverse_map)\n\n    # Try to ensure canonical type.\n    canonical_type = name_map.get(interface_type, None)\n    if not canonical_type:\n        canonical_type = interface_type\n\n    try:\n        abbreviated_name = rev_name_map[canonical_type] + str(interface_number)\n        return abbreviated_name\n\n    except KeyError:\n        pass\n\n    if verify:\n        raise ValueError(f\"Verify interface on and no match found for {interface}\")\n    # If abbreviated name lookup fails, return original name\n    return interface\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.abbreviated_interface_name_list","title":"<code>abbreviated_interface_name_list(interfaces, addl_name_map=None, addl_reverse_map=None, verify=False, order=None, reverse=False)</code>","text":"<p>Function to return a list of interface's abbreviated name.</p> <p>Parameters:</p> Name Type Description Default <code>interfaces</code> <code>List[str]</code> <p>List of interface names you are attempting to abbreviate.</p> required <code>addl_name_map</code> <code>Optional[Dict[str, str]]</code> <p>A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.</p> <code>None</code> <code>addl_reverse_map</code> <code>Optional[Dict[str, str]]</code> <p>A dict containing key/value pairs that updates the abbreviated mapping. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether or not to verify the interface matches a known interface standard. Defaults to False.</p> <code>False</code> <code>order</code> <code>Optional[str]</code> <p>Determines what order the list of interfaces should be returned in. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Specify if the order of the list should be reversed when setting an order. Defaults to None.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of the interfaces in their abbreviated form.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if any interface name in list cannot be converted to its abbreviated form and verify parameter is set to true.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import abbreviated_interface_name_list\n&gt;&gt;&gt; abbreviated_interface_name_list([\"GigabitEthernet1/0/1\", \"GigabitEthernet1/0/2\", \"Ethernet1\"])\n['Gi1/0/1', 'Gi1/0/2', 'Et1']\n&gt;&gt;&gt; abbreviated_interface_name_list(['GigabitEthernet1/0/1', 'Port-channel40', 'Loopback10'])\n['Gi1/0/1', 'Po40', 'Lo10']\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def abbreviated_interface_name_list(  # pylint: disable=R0913, R0914\n    interfaces: t.List[str],\n    addl_name_map: t.Optional[t.Dict[str, str]] = None,\n    addl_reverse_map: t.Optional[t.Dict[str, str]] = None,\n    verify: bool = False,\n    order: t.Optional[str] = None,\n    reverse: bool = False,\n) -&gt; t.List[str]:\n    \"\"\"Function to return a list of interface's abbreviated name.\n\n    Args:\n        interfaces: List of interface names you are attempting to abbreviate.\n        addl_name_map: A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.\n        addl_reverse_map: A dict containing key/value pairs that updates the abbreviated mapping. Defaults to None.\n        verify: Whether or not to verify the interface matches a known interface standard. Defaults to False.\n        order: Determines what order the list of interfaces should be returned in. Defaults to None.\n        reverse: Specify if the order of the list should be reversed when setting an order. Defaults to None.\n\n    Returns:\n        List of the interfaces in their abbreviated form.\n\n    Raises:\n        ValueError: Raised if any interface name in list cannot be converted to its abbreviated form and verify parameter is set to true.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import abbreviated_interface_name_list\n        &gt;&gt;&gt; abbreviated_interface_name_list([\"GigabitEthernet1/0/1\", \"GigabitEthernet1/0/2\", \"Ethernet1\"])\n        ['Gi1/0/1', 'Gi1/0/2', 'Et1']\n        &gt;&gt;&gt; abbreviated_interface_name_list(['GigabitEthernet1/0/1', 'Port-channel40', 'Loopback10'])\n        ['Gi1/0/1', 'Po40', 'Lo10']\n        &gt;&gt;&gt;\n    \"\"\"\n    name_map = {}\n    name_map.update(BASE_INTERFACES)\n    abbreviated_interface_list = []\n    no_match_list = []\n\n    if reverse and not order:\n        raise ValueError(\"Order must be set to use reverse.\")\n\n    if order:\n        _check_order_option_exists(order)\n\n    if isinstance(addl_name_map, dict):\n        name_map.update(addl_name_map)\n\n    rev_name_map = {}\n    rev_name_map.update(REVERSE_MAPPING)\n\n    if isinstance(addl_reverse_map, dict):\n        rev_name_map.update(addl_reverse_map)\n\n    for interface in interfaces:\n        interface_type, interface_number = split_interface(interface)\n        # Try to ensure canonical type.\n        canonical_type = name_map.get(interface_type, None)\n        if not canonical_type:\n            canonical_type = interface_type\n\n        try:\n            abbreviated_name = rev_name_map[canonical_type] + str(interface_number)\n            abbreviated_interface_list.append(abbreviated_name)\n        except KeyError:\n            abbreviated_interface_list.append(interface)\n            no_match_list.append(interface)\n\n    if verify:\n        no_match_string = \", \".join(no_match_list)\n        raise ValueError(f\"Verify interface on and no match found for {no_match_string}\")\n\n    if order:\n        order_function = INTERFACE_LIST_ORDERING_OPTIONS.get(order, None)\n        if not order_function:\n            raise ValueError(f\"No order function available called {order}\")\n        abbreviated_interface_list = order_function(abbreviated_interface_list)\n\n    if reverse:\n        abbreviated_interface_list = _reverse_list(abbreviated_interface_list)\n\n    return abbreviated_interface_list\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.canonical_interface_name","title":"<code>canonical_interface_name(interface, addl_name_map=None, verify=False)</code>","text":"<p>Function to return an interface's canonical name (fully expanded name).</p> <p>Use of explicit matches used to indicate a clear understanding on any potential match. Regex and other looser matching methods were not implemented to avoid false positive matches. As an example, it would make sense to do <code>[P|p][O|o]</code> which would incorrectly match PO = POS and Po = Port-channel, leading to a false positive, not easily troubleshot, found, or known.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>The interface you are attempting to expand.</p> required <code>addl_name_map</code> <code>Optional[Dict[str, str]]</code> <p>A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether or not to verify the interface matches a known interface standard. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The name of the interface in the long form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import canonical_interface_name\n&gt;&gt;&gt; canonical_interface_name(\"Gi1/0/1\")\n'GigabitEthernet1/0/1'\n&gt;&gt;&gt; canonical_interface_name(\"Eth1\")\n'Ethernet1'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def canonical_interface_name(\n    interface: str, addl_name_map: t.Optional[t.Dict[str, str]] = None, verify: bool = False\n) -&gt; str:\n    \"\"\"Function to return an interface's canonical name (fully expanded name).\n\n    Use of explicit matches used to indicate a clear understanding on any potential\n    match. Regex and other looser matching methods were not implemented to avoid false\n    positive matches. As an example, it would make sense to do `[P|p][O|o]` which would\n    incorrectly match PO = POS and Po = Port-channel, leading to a false positive, not\n    easily troubleshot, found, or known.\n\n    Args:\n        interface: The interface you are attempting to expand.\n        addl_name_map: A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.\n        verify: Whether or not to verify the interface matches a known interface standard. Defaults to False.\n\n    Returns:\n        The name of the interface in the long form.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import canonical_interface_name\n        &gt;&gt;&gt; canonical_interface_name(\"Gi1/0/1\")\n        'GigabitEthernet1/0/1'\n        &gt;&gt;&gt; canonical_interface_name(\"Eth1\")\n        'Ethernet1'\n        &gt;&gt;&gt;\n    \"\"\"\n    name_map = {}\n    name_map.update(BASE_INTERFACES)\n    interface_type, interface_number = split_interface(interface)\n\n    if isinstance(addl_name_map, dict):\n        name_map.update(addl_name_map)\n    # check in dict for mapping\n    if interface_type in name_map:\n        long_int = name_map[interface_type]\n        return long_int + str(interface_number)\n    if verify:\n        raise ValueError(f\"Verify interface on and no match found for {interface}\")\n    # if nothing matched, return the original name\n    return interface\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.canonical_interface_name_list","title":"<code>canonical_interface_name_list(interfaces, addl_name_map=None, verify=False, order=None, reverse=False)</code>","text":"<p>Function to return a list of interface's canonical name (fully expanded name).</p> <p>Use of explicit matches used to indicate a clear understanding on any potential match. Regex and other looser matching methods were not implemented to avoid false positive matches. As an example, it would make sense to do <code>[P|p][O|o]</code> which would incorrectly match PO = POS and Po = Port-channel, leading to a false positive, not easily troubleshot, found, or known.</p> <p>Parameters:</p> Name Type Description Default <code>interfaces</code> <code>List[str]</code> <p>List of interfaces you are attempting to expand.</p> required <code>addl_name_map</code> <code>Optional[Dict[str, str]]</code> <p>A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether or not to verify the interface matches a known interface standard. Defaults to False.</p> <code>False</code> <code>order</code> <code>Optional[str]</code> <p>Determines what order the list of interfaces should be returned in. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Specify if the order of the list should be reversed when setting an order. Defaults to None.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of the interfaces in their long form.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if any interface name in list cannot be converted to its long form and verify parameter is set to true.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import canonical_interface_name_list\n&gt;&gt;&gt; canonical_interface_name_list([\"Gi1/0/1\", \"Gi1/0/2\", \"Eth1\"])\n['GigabitEthernet1/0/1', 'GigabitEthernet1/0/2', 'Ethernet1']\n&gt;&gt;&gt; canonical_interface_name_list([\"Gi1/0/1\", \"Po40\", \"Lo10\"])\n['GigabitEthernet1/0/1', 'Port-channel40', 'Loopback10']\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def canonical_interface_name_list(\n    interfaces: t.List[str],\n    addl_name_map: t.Optional[t.Dict[str, str]] = None,\n    verify: bool = False,\n    order: t.Optional[str] = None,\n    reverse: bool = False,\n) -&gt; t.List[str]:\n    \"\"\"Function to return a list of interface's canonical name (fully expanded name).\n\n    Use of explicit matches used to indicate a clear understanding on any potential\n    match. Regex and other looser matching methods were not implemented to avoid false\n    positive matches. As an example, it would make sense to do `[P|p][O|o]` which would\n    incorrectly match PO = POS and Po = Port-channel, leading to a false positive, not\n    easily troubleshot, found, or known.\n\n    Args:\n        interfaces: List of interfaces you are attempting to expand.\n        addl_name_map: A dict containing key/value pairs that updates the base mapping. Used if an OS has specific differences. e.g. {\"Po\": \"PortChannel\"} vs {\"Po\": \"Port-Channel\"}. Defaults to None.\n        verify: Whether or not to verify the interface matches a known interface standard. Defaults to False.\n        order: Determines what order the list of interfaces should be returned in. Defaults to None.\n        reverse: Specify if the order of the list should be reversed when setting an order. Defaults to None.\n\n    Returns:\n        List of the interfaces in their long form.\n\n    Raises:\n        ValueError: Raised if any interface name in list cannot be converted to its long form and verify parameter is set to true.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import canonical_interface_name_list\n        &gt;&gt;&gt; canonical_interface_name_list([\"Gi1/0/1\", \"Gi1/0/2\", \"Eth1\"])\n        ['GigabitEthernet1/0/1', 'GigabitEthernet1/0/2', 'Ethernet1']\n        &gt;&gt;&gt; canonical_interface_name_list([\"Gi1/0/1\", \"Po40\", \"Lo10\"])\n        ['GigabitEthernet1/0/1', 'Port-channel40', 'Loopback10']\n        &gt;&gt;&gt;\n    \"\"\"\n    name_map = {}\n    name_map.update(BASE_INTERFACES)\n    canonical_interface_list = []\n    no_match_list = []\n\n    if reverse and not order:\n        raise ValueError(\"Order must be set to use reverse.\")\n\n    if order:\n        _check_order_option_exists(order)\n\n    for interface in interfaces:\n        canonical_interface_list.append(canonical_interface_name(interface, addl_name_map=addl_name_map))\n        if interface == canonical_interface_name(interface):\n            no_match_list.append(interface)\n\n    if verify:\n        no_match_string = \", \".join(no_match_list)\n        raise ValueError(f\"Verify interface on and no match found for {no_match_string}\")\n\n    if order:\n        order_function = INTERFACE_LIST_ORDERING_OPTIONS.get(order, None)\n        if not order_function:\n            raise ValueError(f\"No order function available called {order}\")\n        canonical_interface_list = order_function(canonical_interface_list)\n\n    if reverse:\n        canonical_interface_list = _reverse_list(canonical_interface_list)\n\n    return canonical_interface_list\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.interface_range_compress","title":"<code>interface_range_compress(interface_list)</code>","text":"<p>Function which takes interfaces and return interface ranges.</p> <p>Whitespace and special characters are ignored in the input. Input must contain only interfaces, there is no check against correct interface names! Also interface names must use the same abbreviation! E.g. Gi =! GigabitEthernet</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import interface_range_compress\n&gt;&gt;&gt; interface_range_compress([\"Gi1/0/1\", \"Gi1/0/2\", \"Gi1/0/3\", \"Gi1/0/5\"])\n['Gi1/0/1-3', 'Gi1/0/5']\n&gt;&gt;&gt; interface_range_compress([\"Gi0/1\", \"Gi0/2\", \"Gi0/4\", \"Gi1/0\", \"Gi1/1\"])\n['Gi0/1-2', 'Gi0/4', 'Gi1/0-1']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>interface_list</code> <code>List[str]</code> <p>list of interfaces</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list of interface ranges</p> Source code in <code>netutils/interface.py</code> <pre><code>def interface_range_compress(interface_list: t.List[str]) -&gt; t.List[str]:\n    \"\"\"Function which takes interfaces and return interface ranges.\n\n    Whitespace and special characters are ignored in the input. Input must contain only interfaces,\n    there is no check against correct interface names! Also interface names must use the same abbreviation!\n    E.g. Gi =! GigabitEthernet\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import interface_range_compress\n        &gt;&gt;&gt; interface_range_compress([\"Gi1/0/1\", \"Gi1/0/2\", \"Gi1/0/3\", \"Gi1/0/5\"])\n        ['Gi1/0/1-3', 'Gi1/0/5']\n        &gt;&gt;&gt; interface_range_compress([\"Gi0/1\", \"Gi0/2\", \"Gi0/4\", \"Gi1/0\", \"Gi1/1\"])\n        ['Gi0/1-2', 'Gi0/4', 'Gi1/0-1']\n\n    Args:\n        interface_list: list of interfaces\n\n    Returns:\n        list of interface ranges\n    \"\"\"\n    result_dict: t.Dict[str, t.List[int]] = {}\n    final_result_list = []\n    sorted_ints = [_split_interface_tuple(x) for x in sort_interface_list(interface_list)]\n    if not sorted_ints:\n        return []\n    current_match = sorted_ints[0][0:-1]\n    for interface in sorted_ints:\n        if interface[0:-1] == current_match:\n            module = \"\".join([x.val for x in current_match])\n            if result_dict.get(module):\n                result_dict[module] += [int(interface[-1].val)]\n            else:\n                result_dict[module] = [int(interface[-1].val)]\n        else:\n            current_match = interface[0:-1]\n            result_dict[\"\".join([x.val for x in current_match])] = [int(interface[-1].val)]\n    for module, ports in result_dict.items():\n        # find ranges in this port list\n        ranges = _ranges_in_list(ports)\n        # assemble module and port ranges\n        for range_group in ranges:\n            if len(range_group) &gt; 1:\n                final_result_list.append(f\"{module}{range_group[0]}-{range_group[-1]}\")\n            else:\n                final_result_list.append(f\"{module}{range_group[0]}\")\n    return final_result_list\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.interface_range_expansion","title":"<code>interface_range_expansion(interface_pattern)</code>","text":"<p>Expand interface pattern into a list of interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>interface_pattern</code> <code>str</code> <p>The string pattern that will be parsed to create the list of interfaces.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Contains the expanded list of interfaces.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import interface_range_expansion\n&gt;&gt;&gt; interface_range_expansion(\"Gi0/[1-4]\")\n['Gi0/1', 'Gi0/2', 'Gi0/3', 'Gi0/4']\n&gt;&gt;&gt; interface_range_expansion(\"FastEthernet[1-2]/0/[10-15]\")\n['FastEthernet1/0/10', 'FastEthernet1/0/11', 'FastEthernet1/0/12', 'FastEthernet1/0/13', 'FastEthernet1/0/14', 'FastEthernet1/0/15', 'FastEthernet2/0/10', 'FastEthernet2/0/11', 'FastEthernet2/0/12', 'FastEthernet2/0/13', 'FastEthernet2/0/14', 'FastEthernet2/0/15']\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def interface_range_expansion(interface_pattern: str) -&gt; t.List[str]:\n    \"\"\"Expand interface pattern into a list of interfaces.\n\n    Args:\n        interface_pattern: The string pattern that will be parsed to create the list of interfaces.\n\n    Returns:\n        Contains the expanded list of interfaces.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import interface_range_expansion\n        &gt;&gt;&gt; interface_range_expansion(\"Gi0/[1-4]\")\n        ['Gi0/1', 'Gi0/2', 'Gi0/3', 'Gi0/4']\n        &gt;&gt;&gt; interface_range_expansion(\"FastEthernet[1-2]/0/[10-15]\")\n        ['FastEthernet1/0/10', 'FastEthernet1/0/11', 'FastEthernet1/0/12', 'FastEthernet1/0/13', 'FastEthernet1/0/14', 'FastEthernet1/0/15', 'FastEthernet2/0/10', 'FastEthernet2/0/11', 'FastEthernet2/0/12', 'FastEthernet2/0/13', 'FastEthernet2/0/14', 'FastEthernet2/0/15']\n    \"\"\"\n\n    def _range_expand(regex_match: str) -&gt; t.List[int]:\n        number_range: t.List[int] = []\n        for value in regex_match.split(\",\"):\n            if \"-\" in value[1:]:\n                first_number, second_number = value[1:].split(\"-\", 1)\n                number_range += range(int(value[0] + first_number), int(second_number) + 1)\n            else:\n                number_range.append(int(value))\n        return number_range\n\n    def _pairwise(interface_constant: t.List[int]) -&gt; t.List[t.Tuple[int, int]]:\n        interface_constant_it = iter(interface_constant)\n        return list(zip(interface_constant_it, interface_constant_it))\n\n    match_pattern = r\"(\\[(?:\\d|,|-)+\\])\"\n    re_compiled = re.compile(match_pattern)\n    # Use case when sent without an actual range, e.g. Gi1\n    if not re_compiled.search(interface_pattern):\n        return [interface_pattern]\n\n    cartesian_list = []\n    interface_constant = [0]\n    for match in re_compiled.finditer(interface_pattern):\n        interface_constant.append(match.start())\n        interface_constant.append(match.end())\n        cartesian_list.append(_range_expand(match.group()[1:-1]))\n\n    # accommodate trailing constants\n    if interface_constant[-1] &lt; len(interface_pattern):\n        interface_constant.append(len(interface_pattern))\n\n    interface_constant_out = _pairwise(interface_constant)\n    expanded_interfaces = []\n    for element in itertools.product(*cartesian_list):\n        current_interface = \"\"\n        for count, item in enumerate(interface_constant_out):\n            current_interface += interface_pattern[item[0] : item[1]]  # noqa: E203\n            # only append the next item if the current constant\n            # doesn't fall at the end of the line\n            if count &lt; len(element):\n                current_interface += str(element[count])\n        expanded_interfaces.append(current_interface)\n\n    return expanded_interfaces\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.sort_interface_list","title":"<code>sort_interface_list(interfaces)</code>","text":"<p>This function sorts and cleans a list of interfaces.</p> <p>Note that a new list of interfaces is returned and that duplicates nodes are removed.</p> <p>Parameters:</p> Name Type Description Default <code>interfaces</code> <code>List[str]</code> <p>A list of interfaces to be sorted.  The input list is not mutated by this function.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A new sorted, unique list elements from the input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import sort_interface_list\n&gt;&gt;&gt; sort_interface_list([\"Gi1/0/1\", \"Gi1/0/3\", \"Gi1/0/3.100\", \"Gi1/0/2\", \"Gi1/0/2.50\", \"Gi2/0/2\", \"Po40\", \"Po160\", \"Lo10\"])\n['Gi1/0/1', 'Gi1/0/2', 'Gi1/0/2.50', 'Gi1/0/3', 'Gi1/0/3.100', 'Gi2/0/2', 'Lo10', 'Po40', 'Po160']\n&gt;&gt;&gt; sort_interface_list(['GigabitEthernet1/0/1', 'GigabitEthernet1/0/3', 'GigabitEthernet1/0/2', \"GigabitEthernet3/0/5\", 'GigabitEthernet3/0/7', 'GigabitEthernet2/0/8.5',  'Port-channel40', 'Vlan20', 'Loopback10'])\n['GigabitEthernet1/0/1', 'GigabitEthernet1/0/2', 'GigabitEthernet1/0/3', 'GigabitEthernet2/0/8.5', 'GigabitEthernet3/0/5', 'GigabitEthernet3/0/7', 'Loopback10', 'Port-channel40', 'Vlan20']\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def sort_interface_list(interfaces: t.List[str]) -&gt; t.List[str]:\n    \"\"\"This function sorts and cleans a list of interfaces.\n\n    Note that a new list of interfaces is returned and that duplicates\n    nodes are removed.\n\n    Args:\n        interfaces: A list of interfaces to be sorted.  The input list is not mutated by this function.\n\n    Returns:\n        A **new** sorted, unique list elements from the input.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import sort_interface_list\n        &gt;&gt;&gt; sort_interface_list([\"Gi1/0/1\", \"Gi1/0/3\", \"Gi1/0/3.100\", \"Gi1/0/2\", \"Gi1/0/2.50\", \"Gi2/0/2\", \"Po40\", \"Po160\", \"Lo10\"])\n        ['Gi1/0/1', 'Gi1/0/2', 'Gi1/0/2.50', 'Gi1/0/3', 'Gi1/0/3.100', 'Gi2/0/2', 'Lo10', 'Po40', 'Po160']\n        &gt;&gt;&gt; sort_interface_list(['GigabitEthernet1/0/1', 'GigabitEthernet1/0/3', 'GigabitEthernet1/0/2', \"GigabitEthernet3/0/5\", 'GigabitEthernet3/0/7', 'GigabitEthernet2/0/8.5',  'Port-channel40', 'Vlan20', 'Loopback10'])\n        ['GigabitEthernet1/0/1', 'GigabitEthernet1/0/2', 'GigabitEthernet1/0/3', 'GigabitEthernet2/0/8.5', 'GigabitEthernet3/0/5', 'GigabitEthernet3/0/7', 'Loopback10', 'Port-channel40', 'Vlan20']\n    \"\"\"\n    root: t.Dict[CharacterClass, t.Any] = {}\n    for ifname in interfaces:\n        _insert_nodes(root, _split_interface_tuple(ifname))\n    return list(_iter_tree(root, []))\n</code></pre>"},{"location":"dev/code_reference/interface.html#netutils.interface.split_interface","title":"<code>split_interface(interface)</code>","text":"<p>Split an interface name based on first digit, slash, or space match.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>The interface you are attempting to split.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>The split between the name of the interface the value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.interface import split_interface\n&gt;&gt;&gt; split_interface(\"GigabitEthernet1/0/1\")\n('GigabitEthernet', '1/0/1')\n&gt;&gt;&gt; split_interface(\"Eth1\")\n('Eth', '1')\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/interface.py</code> <pre><code>def split_interface(interface: str) -&gt; t.Tuple[str, str]:\n    \"\"\"Split an interface name based on first digit, slash, or space match.\n\n    Args:\n        interface: The interface you are attempting to split.\n\n    Returns:\n        The split between the name of the interface the value.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.interface import split_interface\n        &gt;&gt;&gt; split_interface(\"GigabitEthernet1/0/1\")\n        ('GigabitEthernet', '1/0/1')\n        &gt;&gt;&gt; split_interface(\"Eth1\")\n        ('Eth', '1')\n        &gt;&gt;&gt;\n    \"\"\"\n    head = interface.rstrip(r\"/\\0123456789.: \")\n    tail = interface[len(head) :].lstrip()  # noqa: E203\n    return (head, tail)\n</code></pre>"},{"location":"dev/code_reference/ip.html","title":"IP Address","text":""},{"location":"dev/code_reference/ip.html#netutils.ip","title":"<code>netutils.ip</code>","text":"<p>Functions for working with IP addresses.</p>"},{"location":"dev/code_reference/ip.html#netutils.ip.cidr_to_netmask","title":"<code>cidr_to_netmask(cidr)</code>","text":"<p>Creates a decimal format of a CIDR value.</p> <p>IPv4 only.  For IPv6, please use <code>cidr_to_netmaskv6</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cidr</code> <code>int</code> <p>A CIDR value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decimal format representation of CIDR value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import cidr_to_netmask\n&gt;&gt;&gt; cidr_to_netmask(24)\n'255.255.255.0'\n&gt;&gt;&gt; cidr_to_netmask(17)\n'255.255.128.0'\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def cidr_to_netmask(cidr: int) -&gt; str:\n    \"\"\"Creates a decimal format of a CIDR value.\n\n    **IPv4** only.  For IPv6, please use `cidr_to_netmaskv6`.\n\n    Args:\n        cidr: A CIDR value.\n\n    Returns:\n        Decimal format representation of CIDR value.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import cidr_to_netmask\n        &gt;&gt;&gt; cidr_to_netmask(24)\n        '255.255.255.0'\n        &gt;&gt;&gt; cidr_to_netmask(17)\n        '255.255.128.0'\n    \"\"\"\n    if isinstance(cidr, int) and 0 &lt;= cidr &lt;= 32:\n        return \".\".join([str((0xFFFFFFFF &lt;&lt; (32 - cidr) &gt;&gt; i) &amp; 0xFF) for i in [24, 16, 8, 0]])\n    raise ValueError(\"Parameter must be an integer between 0 and 32.\")\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.cidr_to_netmaskv6","title":"<code>cidr_to_netmaskv6(cidr)</code>","text":"<p>Creates a decimal format of a CIDR value.</p> <p>Parameters:</p> Name Type Description Default <code>cidr</code> <code>int</code> <p>A CIDR value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decimal format (IPv6) representation of CIDR value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import cidr_to_netmaskv6\n&gt;&gt;&gt; cidr_to_netmaskv6(24)\n'ffff:ff00::'\n&gt;&gt;&gt; cidr_to_netmaskv6(17)\n'ffff:8000::'\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def cidr_to_netmaskv6(cidr: int) -&gt; str:\n    \"\"\"Creates a decimal format of a CIDR value.\n\n    Args:\n        cidr: A CIDR value.\n\n    Returns:\n        Decimal format (IPv6) representation of CIDR value.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import cidr_to_netmaskv6\n        &gt;&gt;&gt; cidr_to_netmaskv6(24)\n        'ffff:ff00::'\n        &gt;&gt;&gt; cidr_to_netmaskv6(17)\n        'ffff:8000::'\n    \"\"\"\n    if isinstance(cidr, int) and 0 &lt;= cidr &lt;= 128:\n        return str(ipaddress.IPv6Address(((1 &lt;&lt; cidr) - 1) &lt;&lt; (128 - cidr)))\n    raise ValueError(\"Parameter must be an integer between 0 and 128.\")\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_all_host","title":"<code>get_all_host(ip_network)</code>","text":"<p>Given a network, return the list of usable IP addresses.</p> <p>Parameters:</p> Name Type Description Default <code>ip_network</code> <code>str</code> <p>An IP network in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>Generator[str, None, None]</code> <p>Generator of usable IP Addresses within network.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_all_host\n&gt;&gt;&gt; print(list(get_all_host(\"10.100.100.0/29\")))\n['10.100.100.1', '10.100.100.2', '10.100.100.3', '10.100.100.4', '10.100.100.5', '10.100.100.6']\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def get_all_host(ip_network: str) -&gt; t.Generator[str, None, None]:\n    \"\"\"Given a network, return the list of usable IP addresses.\n\n    Args:\n        ip_network: An IP network in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        Generator of usable IP Addresses within network.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_all_host\n        &gt;&gt;&gt; print(list(get_all_host(\"10.100.100.0/29\")))\n        ['10.100.100.1', '10.100.100.2', '10.100.100.3', '10.100.100.4', '10.100.100.5', '10.100.100.6']\n        &gt;&gt;&gt;\n    \"\"\"\n    return (str(ip) for ip in ipaddress.ip_network(ip_network).hosts())\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_broadcast_address","title":"<code>get_broadcast_address(ip_network)</code>","text":"<p>Given a network, determine the broadcast IP address.</p> <p>Parameters:</p> Name Type Description Default <code>ip_network</code> <code>str</code> <p>An IP network in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>str</code> <p>IP address formatted string with the broadcast IP address in the network.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_broadcast_address\n&gt;&gt;&gt; get_broadcast_address(\"10.100.0.0/16\")\n'10.100.255.255'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def get_broadcast_address(ip_network: str) -&gt; str:\n    \"\"\"Given a network, determine the broadcast IP address.\n\n    Args:\n        ip_network: An IP network in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        IP address formatted string with the broadcast IP address in the network.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_broadcast_address\n        &gt;&gt;&gt; get_broadcast_address(\"10.100.0.0/16\")\n        '10.100.255.255'\n        &gt;&gt;&gt;\n    \"\"\"\n    return str(ipaddress.ip_network(ip_network).broadcast_address)\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_first_usable","title":"<code>get_first_usable(ip_network)</code>","text":"<p>Given a network, determine the first usable IP address.</p> <p>Parameters:</p> Name Type Description Default <code>ip_network</code> <code>str</code> <p>An IP network in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>str</code> <p>IP address formatted string with the first usable IP address in the network.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_first_usable\n&gt;&gt;&gt; get_first_usable(\"10.100.0.0/16\")\n'10.100.0.1'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def get_first_usable(ip_network: str) -&gt; str:\n    \"\"\"Given a network, determine the first usable IP address.\n\n    Args:\n        ip_network: An IP network in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        IP address formatted string with the first usable IP address in the network.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_first_usable\n        &gt;&gt;&gt; get_first_usable(\"10.100.0.0/16\")\n        '10.100.0.1'\n        &gt;&gt;&gt;\n    \"\"\"\n    net = ipaddress.ip_network(ip_network)\n    if net.prefixlen in [31, 127]:\n        return str(net[0])\n    return str(net[1])\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_ips_sorted","title":"<code>get_ips_sorted(ips, sort_type='network')</code>","text":"<p>Given a concatenated list of CIDRs sorts them into the correct order and returns them as a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_ips_sorted\n&gt;&gt;&gt; get_ips_sorted(\"3.3.3.3,2.2.2.2,1.1.1.1\")\n['1.1.1.1/32', '2.2.2.2/32', '3.3.3.3/32']\n&gt;&gt;&gt; get_ips_sorted(\"10.0.20.0/24,10.0.20.0/23,10.0.19.0/24\")\n['10.0.19.0/24', '10.0.20.0/23', '10.0.20.0/24']\n&gt;&gt;&gt; get_ips_sorted(\"10.0.20.0/24,10.0.20.0/23,10.0.19.0/24\", \"interface\")\n['10.0.19.0/24', '10.0.20.0/23', '10.0.20.0/24']\n&gt;&gt;&gt; get_ips_sorted(\"10.0.20.20/24,10.0.20.1/23,10.0.19.5/24\", \"interface\")\n['10.0.19.5/24', '10.0.20.1/23', '10.0.20.20/24']\n&gt;&gt;&gt; get_ips_sorted([\"10.0.20.20\", \"10.0.20.1\", \"10.0.19.5\"], \"address\")\n['10.0.19.5', '10.0.20.1', '10.0.20.20']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ips</code> <code>Union[str, List[str]]</code> <p>Concatenated string list of CIDRs, IPAddresses, or Interfaces or list of the same strings.</p> required <code>sort_type</code> <code>str</code> <p>Whether the passed list are networks, IP addresses, or interfaces, ie \"address\", \"interface\", or \"network\".</p> <code>'network'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>t.List[str]: Sorted list of sort_type IPs.</p> Source code in <code>netutils/ip.py</code> <pre><code>def get_ips_sorted(ips: t.Union[str, t.List[str]], sort_type: str = \"network\") -&gt; t.List[str]:\n    \"\"\"Given a concatenated list of CIDRs sorts them into the correct order and returns them as a list.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_ips_sorted\n        &gt;&gt;&gt; get_ips_sorted(\"3.3.3.3,2.2.2.2,1.1.1.1\")\n        ['1.1.1.1/32', '2.2.2.2/32', '3.3.3.3/32']\n        &gt;&gt;&gt; get_ips_sorted(\"10.0.20.0/24,10.0.20.0/23,10.0.19.0/24\")\n        ['10.0.19.0/24', '10.0.20.0/23', '10.0.20.0/24']\n        &gt;&gt;&gt; get_ips_sorted(\"10.0.20.0/24,10.0.20.0/23,10.0.19.0/24\", \"interface\")\n        ['10.0.19.0/24', '10.0.20.0/23', '10.0.20.0/24']\n        &gt;&gt;&gt; get_ips_sorted(\"10.0.20.20/24,10.0.20.1/23,10.0.19.5/24\", \"interface\")\n        ['10.0.19.5/24', '10.0.20.1/23', '10.0.20.20/24']\n        &gt;&gt;&gt; get_ips_sorted([\"10.0.20.20\", \"10.0.20.1\", \"10.0.19.5\"], \"address\")\n        ['10.0.19.5', '10.0.20.1', '10.0.20.20']\n\n    Args:\n        ips (t.Union[str, t.List[str]]): Concatenated string list of CIDRs, IPAddresses, or Interfaces or list of the same strings.\n        sort_type (str): Whether the passed list are networks, IP addresses, or interfaces, ie \"address\", \"interface\", or \"network\".\n\n    Returns:\n        t.List[str]: Sorted list of sort_type IPs.\n    \"\"\"\n    if sort_type not in [\"address\", \"interface\", \"network\"]:\n        raise ValueError(\"Invalid sort type passed. Must be `address`, `interface`, or `network`.\")\n    if isinstance(ips, list):\n        ips_list = ips\n    elif (isinstance(ips, str) and \",\" not in ips) or not isinstance(ips, str):\n        raise ValueError(\"Not a concatenated list of IPs as expected.\")\n    elif isinstance(ips, str):\n        ips_list = ips.replace(\" \", \"\").split(\",\")\n\n    functions: t.Dict[str, t.Callable[[t.Any], t.Any]] = {\n        \"address\": ipaddress.ip_address,\n        \"interface\": ipaddress.ip_interface,\n        \"network\": ipaddress.ip_network,\n    }\n\n    try:\n        sorted_list = sorted(functions[sort_type](ip) for ip in ips_list)\n        if sort_type in [\"interface\", \"network\"]:\n            return [cidrs.with_prefixlen for cidrs in sorted_list]\n        return [str(ip) for ip in sorted_list]\n    except ValueError as err:\n        raise ValueError(f\"Invalid IP of {sort_type} input: {err}\") from err\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_peer_ip","title":"<code>get_peer_ip(ip_interface)</code>","text":"<p>Given an IP interface (an ip address, with subnet mask) that is on a peer network, return the peer IP.</p> <p>Parameters:</p> Name Type Description Default <code>ip_interface</code> <code>str</code> <p>An IP interface in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>str</code> <p>IP address formatted string with the corresponding peer IP.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_peer_ip\n&gt;&gt;&gt; get_peer_ip('10.0.0.1/255.255.255.252')\n'10.0.0.2'\n&gt;&gt;&gt; get_peer_ip('10.0.0.2/30')\n'10.0.0.1'\n&gt;&gt;&gt; get_peer_ip('10.0.0.1/255.255.255.254')\n'10.0.0.0'\n&gt;&gt;&gt; get_peer_ip('10.0.0.0/31')\n'10.0.0.1'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def get_peer_ip(ip_interface: str) -&gt; str:\n    \"\"\"Given an IP interface (an ip address, with subnet mask) that is on a peer network, return the peer IP.\n\n    Args:\n        ip_interface: An IP interface in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        IP address formatted string with the corresponding peer IP.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_peer_ip\n        &gt;&gt;&gt; get_peer_ip('10.0.0.1/255.255.255.252')\n        '10.0.0.2'\n        &gt;&gt;&gt; get_peer_ip('10.0.0.2/30')\n        '10.0.0.1'\n        &gt;&gt;&gt; get_peer_ip('10.0.0.1/255.255.255.254')\n        '10.0.0.0'\n        &gt;&gt;&gt; get_peer_ip('10.0.0.0/31')\n        '10.0.0.1'\n        &gt;&gt;&gt;\n    \"\"\"\n    ip_obj = ipaddress.ip_interface(ip_interface)\n    if isinstance(ip_obj, ipaddress.IPv4Address) and ip_obj.network.prefixlen not in [30, 31]:\n        raise ValueError(f\"{ip_obj} did not conform to IPv4 acceptable masks of 30 or 31\")\n    if isinstance(ip_obj, ipaddress.IPv6Address) and ip_obj.network.prefixlen not in [126, 127]:\n        raise ValueError(f\"{ip_obj} did not conform to IPv6 acceptable masks of 126 or 127\")\n    if ip_obj.network.prefixlen in [30, 126] and ip_obj.ip in [\n        ip_obj.network.network_address,\n        ip_obj.network.broadcast_address,\n    ]:\n        raise ValueError(f\"{ip_obj} is not an IP in the point-to-point link usable range.\")\n    # The host lists returns all usable IPs, remove the matching one, return the first element. This can be optimized greatly, but left\n    # like this for simplicity. Note: IPv6 technically does not have a broadcast address, but for ptp, this is not considered.\n    val = list(get_all_host(str(ip_obj.network)))\n    val.remove(str(ip_obj.ip))\n    return val[0]\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_range_ips","title":"<code>get_range_ips(ip_range)</code>","text":"<p>Get's the two IPs as a tuple of IPAddress objects.</p> <p>Parameters:</p> Name Type Description Default <code>ip_range</code> <code>str</code> <p>An IP address range in string format that is properly formatted.</p> required <p>Returns:</p> Type Description <code>Tuple[IPAddress, IPAddress]</code> <p>The start and end IP address of the range provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_range_ips\n&gt;&gt;&gt; get_range_ips(\"10.100.100.255-10.100.101.1\")\n(IPv4Address('10.100.100.255'), IPv4Address('10.100.101.1'))\n&gt;&gt;&gt; get_range_ips(\"2001::1-2001::10\")\n(IPv6Address('2001::1'), IPv6Address('2001::10'))\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def get_range_ips(ip_range: str) -&gt; t.Tuple[IPAddress, IPAddress]:\n    \"\"\"Get's the two IPs as a tuple of IPAddress objects.\n\n    Args:\n        ip_range: An IP address range in string format that is properly formatted.\n\n    Returns:\n        The start and end IP address of the range provided.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_range_ips\n        &gt;&gt;&gt; get_range_ips(\"10.100.100.255-10.100.101.1\")\n        (IPv4Address('10.100.100.255'), IPv4Address('10.100.101.1'))\n        &gt;&gt;&gt; get_range_ips(\"2001::1-2001::10\")\n        (IPv6Address('2001::1'), IPv6Address('2001::10'))\n        &gt;&gt;&gt;\n    \"\"\"\n    if not is_ip_range(ip_range):\n        raise ValueError(r\"Not a valid IP range format of `{start_ip}-{end_ip}`\")\n    start_ip, end_ip = ip_range.split(\"-\")\n    start_ip_obj = ipaddress.ip_address(start_ip)\n    end_ip_obj = ipaddress.ip_address(end_ip)\n    return start_ip_obj, end_ip_obj\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.get_usable_range","title":"<code>get_usable_range(ip_network)</code>","text":"<p>Given a network, return the string of usable IP addresses.</p> <p>Parameters:</p> Name Type Description Default <code>ip_network</code> <code>str</code> <p>An IP network in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String of usable IP Addresses within network.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import get_usable_range\n&gt;&gt;&gt; get_usable_range(\"10.100.100.0/29\")\n'10.100.100.1 - 10.100.100.6'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def get_usable_range(ip_network: str) -&gt; str:\n    \"\"\"Given a network, return the string of usable IP addresses.\n\n    Args:\n        ip_network: An IP network in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        String of usable IP Addresses within network.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import get_usable_range\n        &gt;&gt;&gt; get_usable_range(\"10.100.100.0/29\")\n        '10.100.100.1 - 10.100.100.6'\n        &gt;&gt;&gt;\n    \"\"\"\n    net = ipaddress.ip_network(ip_network)\n    if net.prefixlen in [31, 127]:\n        lower_bound = str(net[0])\n        upper_bound = str(net[1])\n    else:\n        lower_bound = str(net[1])\n        upper_bound = str(net[-2])\n    return f\"{lower_bound} - {upper_bound}\"\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ip_addition","title":"<code>ip_addition(ip, val)</code>","text":"<p>Adds an integer to an IP address.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>An IP address in string format that is able to be converted by <code>ipaddress</code> library.</p> required <code>val</code> <code>int</code> <p>An integer of which the IP address should be added by.</p> required <p>Returns:</p> Type Description <code>str</code> <p>IP address formatted string with the newly added IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ip_addition\n&gt;&gt;&gt; ip_addition(\"10.100.100.100\", 200)\n'10.100.101.44'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ip_addition(ip: str, val: int) -&gt; str:\n    \"\"\"Adds an integer to an IP address.\n\n    Args:\n        ip: An IP address in string format that is able to be converted by `ipaddress` library.\n        val: An integer of which the IP address should be added by.\n\n    Returns:\n        IP address formatted string with the newly added IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ip_addition\n        &gt;&gt;&gt; ip_addition(\"10.100.100.100\", 200)\n        '10.100.101.44'\n        &gt;&gt;&gt;\n    \"\"\"\n    return str(ipaddress.ip_address(ip) + val)\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ip_subtract","title":"<code>ip_subtract(ip, val)</code>","text":"<p>Subtract an integer to an IP address.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>An IP address in string format that is able to be converted by <code>ipaddress</code> library.</p> required <code>val</code> <code>int</code> <p>An integer of which the IP address should be subtracted by.</p> required <p>Returns:</p> Type Description <code>str</code> <p>IP address formatted string with the newly subtracted IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ip_subtract\n&gt;&gt;&gt; ip_subtract(\"10.100.100.100\", 200)\n'10.100.99.156'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ip_subtract(ip: str, val: int) -&gt; str:\n    \"\"\"Subtract an integer to an IP address.\n\n    Args:\n        ip: An IP address in string format that is able to be converted by `ipaddress` library.\n        val: An integer of which the IP address should be subtracted by.\n\n    Returns:\n        IP address formatted string with the newly subtracted IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ip_subtract\n        &gt;&gt;&gt; ip_subtract(\"10.100.100.100\", 200)\n        '10.100.99.156'\n        &gt;&gt;&gt;\n    \"\"\"\n    return str(ipaddress.ip_address(ip) - val)\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ip_to_bin","title":"<code>ip_to_bin(ip)</code>","text":"<p>Converts an IP address in string format to a binary string.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>An IP address in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Binary value of the IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ip_to_bin\n&gt;&gt;&gt; ip_to_bin(\"10.100.100.100\")\n'00001010011001000110010001100100'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ip_to_bin(ip: str) -&gt; str:\n    \"\"\"Converts an IP address in string format to a binary string.\n\n    Args:\n        ip: An IP address in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        Binary value of the IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ip_to_bin\n        &gt;&gt;&gt; ip_to_bin(\"10.100.100.100\")\n        '00001010011001000110010001100100'\n        &gt;&gt;&gt;\n    \"\"\"\n    ip_obj = ipaddress.ip_address(ip)\n    return bin(int(ip_obj))[2:].zfill(ip_obj.max_prefixlen)\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ip_to_hex","title":"<code>ip_to_hex(ip)</code>","text":"<p>Converts an IP address in string format to a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>An IP address in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>str</code> <p>HEX value of the IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ip_to_hex\n&gt;&gt;&gt; ip_to_hex(\"10.100.100.100\")\n'0a646464'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ip_to_hex(ip: str) -&gt; str:\n    \"\"\"Converts an IP address in string format to a hex string.\n\n    Args:\n        ip: An IP address in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        HEX value of the IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ip_to_hex\n        &gt;&gt;&gt; ip_to_hex(\"10.100.100.100\")\n        '0a646464'\n        &gt;&gt;&gt;\n    \"\"\"\n    ip_obj = ipaddress.ip_address(ip)\n    return str(hex(int(ip_obj)))[2:].zfill(int(ip_obj.max_prefixlen / 4))\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ipaddress_address","title":"<code>ipaddress_address(ip, attr)</code>","text":"<p>Convenience function primarily built to expose ipaddress.ip_address to Jinja.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP Address str compliant with ipaddress.ip_address inputs.</p> required <code>attr</code> <code>str</code> <p>An attribute in string dotted format.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Returns the value provided by the ipaddress.ip_address attribute provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ipaddress_address\n&gt;&gt;&gt; ipaddress_address('10.1.1.1', 'version')\n4\n&gt;&gt;&gt; ipaddress_address('10.1.1.1', '__int__')\n167837953\n&gt;&gt;&gt; ipaddress_address('10.1.1.1', 'is_loopback')\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ipaddress_address(ip: str, attr: str) -&gt; t.Any:\n    \"\"\"Convenience function primarily built to expose ipaddress.ip_address to Jinja.\n\n    Args:\n        ip: IP Address str compliant with ipaddress.ip_address inputs.\n        attr: An attribute in string dotted format.\n\n    Returns:\n        Returns the value provided by the ipaddress.ip_address attribute provided.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ipaddress_address\n        &gt;&gt;&gt; ipaddress_address('10.1.1.1', 'version')\n        4\n        &gt;&gt;&gt; ipaddress_address('10.1.1.1', '__int__')\n        167837953\n        &gt;&gt;&gt; ipaddress_address('10.1.1.1', 'is_loopback')\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    retriever = attrgetter(attr)\n    retrieved_method = retriever(ipaddress.ip_address(ip))\n    if callable(retrieved_method):\n        return retrieved_method()\n    return retrieved_method\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ipaddress_interface","title":"<code>ipaddress_interface(ip, attr)</code>","text":"<p>Convenience function primarily built to expose ipaddress.ip_interface to Jinja.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP interface str compliant with ipaddress.ip_interface inputs.</p> required <code>attr</code> <code>str</code> <p>An attribute in string dotted format.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Returns the value provided by the ipaddress.ip_interface attribute provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ipaddress_interface\n&gt;&gt;&gt; ipaddress_interface('10.1.1.1/24', 'version')\n4\n&gt;&gt;&gt; ipaddress_interface('10.1.1.1/24', '__int__')\n167837953\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ipaddress_interface(ip: str, attr: str) -&gt; t.Any:\n    \"\"\"Convenience function primarily built to expose ipaddress.ip_interface to Jinja.\n\n    Args:\n        ip: IP interface str compliant with ipaddress.ip_interface inputs.\n        attr: An attribute in string dotted format.\n\n    Returns:\n        Returns the value provided by the ipaddress.ip_interface attribute provided.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ipaddress_interface\n        &gt;&gt;&gt; ipaddress_interface('10.1.1.1/24', 'version')\n        4\n        &gt;&gt;&gt; ipaddress_interface('10.1.1.1/24', '__int__')\n        167837953\n    \"\"\"\n    retriever = attrgetter(attr)\n    retrieved_method = retriever(ipaddress.ip_interface(ip))\n    if callable(retrieved_method):\n        return retrieved_method()\n    return retrieved_method\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.ipaddress_network","title":"<code>ipaddress_network(ip, attr, **kwargs)</code>","text":"<p>Convenience function primarily built to expose ipaddress.ip_network to Jinja.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP network str compliant with ipaddress.ip_network inputs.</p> required <code>attr</code> <code>str</code> <p>An attribute in string dotted format.</p> required <code>kwargs</code> <code>Any</code> <p>Keyword arguments to pass along to the given method of ipaddress.ip_network.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Returns the value provided by the ipaddress.ip_network attribute provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import ipaddress_network\n&gt;&gt;&gt; ipaddress_network('10.1.1.0/24', 'version')\n4\n&gt;&gt;&gt; ipaddress_network('10.1.1.0/24', '__str__')\n'10.1.1.0/24'\n&gt;&gt;&gt; list(ipaddress_network('192.168.1.0/28', 'subnets', new_prefix=30))\n[IPv4Network('192.168.1.0/30'), IPv4Network('192.168.1.4/30'), IPv4Network('192.168.1.8/30'), IPv4Network('192.168.1.12/30')]\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def ipaddress_network(ip: str, attr: str, **kwargs: t.Any) -&gt; t.Any:\n    \"\"\"Convenience function primarily built to expose ipaddress.ip_network to Jinja.\n\n    Args:\n        ip: IP network str compliant with ipaddress.ip_network inputs.\n        attr: An attribute in string dotted format.\n        kwargs: Keyword arguments to pass along to the given method of ipaddress.ip_network.\n\n    Returns:\n        Returns the value provided by the ipaddress.ip_network attribute provided.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import ipaddress_network\n        &gt;&gt;&gt; ipaddress_network('10.1.1.0/24', 'version')\n        4\n        &gt;&gt;&gt; ipaddress_network('10.1.1.0/24', '__str__')\n        '10.1.1.0/24'\n        &gt;&gt;&gt; list(ipaddress_network('192.168.1.0/28', 'subnets', new_prefix=30))\n        [IPv4Network('192.168.1.0/30'), IPv4Network('192.168.1.4/30'), IPv4Network('192.168.1.8/30'), IPv4Network('192.168.1.12/30')]\n    \"\"\"\n    retriever: t.Callable[[t.Union[ipaddress.IPv4Network, ipaddress.IPv6Network]], t.Any]\n    if kwargs:\n        retriever = methodcaller(attr, **kwargs)\n    else:\n        retriever = attrgetter(attr)\n    retrieved_method = retriever(ipaddress.ip_network(ip))\n    if callable(retrieved_method):\n        return retrieved_method()\n    return retrieved_method\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_classful","title":"<code>is_classful(ip_network)</code>","text":"<p>Determines if a CIDR network address is within unicast classful boundaries.</p> <p>The following class boundaries are checked:</p> <ul> <li>Class A: 0.0.0.0/8 -&gt; 127.0.0.0/8</li> <li>Class B: 128.0.0.0/16 -&gt; 191.255.0.0/16</li> <li>Class C: 192.0.0.0/24 -&gt; 223.255.255.0/24</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ip_network</code> <code>str</code> <p>A network string that can be parsed by ipaddress.ip_network.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the network falls within classful boundaries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_classful\n&gt;&gt;&gt; is_classful(\"192.168.0.0/24\")\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; from jinja2 import Environment\n&gt;&gt;&gt; from netutils.utils import jinja2_convenience_function\n&gt;&gt;&gt;\n&gt;&gt;&gt; env = Environment(trim_blocks=True, lstrip_blocks=True)\n&gt;&gt;&gt; env.filters.update(jinja2_convenience_function())\n&gt;&gt;&gt;\n&gt;&gt;&gt; template_str = \"\"\"\n... {%- for net in networks %}\n...   {% if net | is_classful %}\n...   network {{ net | ipaddress_network('network_address') }}\n...   {% else %}\n...   network {{ net | ipaddress_network('network_address') }} mask {{ net | ipaddress_network('netmask') }}\n...   {% endif %}\n... {% endfor -%}\n... \"\"\"\n&gt;&gt;&gt; template = env.from_string(template_str)\n&gt;&gt;&gt; result = template.render({\"networks\": [\"192.168.1.0/24\", \"172.16.1.0/24\"]})\n&gt;&gt;&gt; print(result, end=\"\")\n  network 192.168.1.0\n  network 172.16.1.0 mask 255.255.255.0\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_classful(ip_network: str) -&gt; bool:  # noqa: D300,D301\n    \"\"\"Determines if a CIDR network address is within unicast classful boundaries.\n\n       The following class boundaries are checked:\n\n       * Class A: 0.0.0.0/8 -&gt; 127.0.0.0/8\n       * Class B: 128.0.0.0/16 -&gt; 191.255.0.0/16\n       * Class C: 192.0.0.0/24 -&gt; 223.255.255.0/24\n\n    Args:\n        ip_network: A network string that can be parsed by ipaddress.ip_network.\n\n    Returns:\n        Whether or not the network falls within classful boundaries.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_classful\n        &gt;&gt;&gt; is_classful(\"192.168.0.0/24\")\n        True\n\n        &gt;&gt;&gt; from jinja2 import Environment\n        &gt;&gt;&gt; from netutils.utils import jinja2_convenience_function\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; env = Environment(trim_blocks=True, lstrip_blocks=True)\n        &gt;&gt;&gt; env.filters.update(jinja2_convenience_function())\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; template_str = \\\"\\\"\\\"\n        ... {%- for net in networks %}\n        ...   {% if net | is_classful %}\n        ...   network {{ net | ipaddress_network('network_address') }}\n        ...   {% else %}\n        ...   network {{ net | ipaddress_network('network_address') }} mask {{ net | ipaddress_network('netmask') }}\n        ...   {% endif %}\n        ... {% endfor -%}\n        ... \\\"\\\"\\\"\n        &gt;&gt;&gt; template = env.from_string(template_str)\n        &gt;&gt;&gt; result = template.render({\"networks\": [\"192.168.1.0/24\", \"172.16.1.0/24\"]})\n        &gt;&gt;&gt; print(result, end=\"\")\n          network 192.168.1.0\n          network 172.16.1.0 mask 255.255.255.0\n    \"\"\"\n    net = ipaddress.ip_network(ip_network)\n    # Only IPv4 addresses can be classified as classful\n    if net.version != 4:\n        return False\n    first_octet = net.network_address.packed[0]\n    netmask = int(net.netmask)\n    return (\n        ((first_octet &amp; 0x80 == 0x00) and (netmask == 0xFF000000))  # Class A\n        or ((first_octet &amp; 0xC0 == 0x80) and (netmask == 0xFFFF0000))  # Class B\n        or ((first_octet &amp; 0xE0 == 0xC0) and (netmask == 0xFFFFFF00))  # Class C\n    )\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_ip","title":"<code>is_ip(ip)</code>","text":"<p>Verifies whether or not a string is a valid IP address.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>An IP address in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The result as to whether or not the string is a valid IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_ip\n&gt;&gt;&gt; is_ip(\"10.100.100.256\")\nFalse\n&gt;&gt;&gt; is_ip(\"10.100.100.255\")\nTrue\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_ip(ip: str) -&gt; bool:\n    \"\"\"Verifies whether or not a string is a valid IP address.\n\n    Args:\n        ip: An IP address in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        The result as to whether or not the string is a valid IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_ip\n        &gt;&gt;&gt; is_ip(\"10.100.100.256\")\n        False\n        &gt;&gt;&gt; is_ip(\"10.100.100.255\")\n        True\n        &gt;&gt;&gt;\n    \"\"\"\n    try:\n        ipaddress.ip_address(ip)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_ip_range","title":"<code>is_ip_range(ip_range)</code>","text":"<p>Verifies whether or not a string is a valid IP address range.</p> <p>An <code>ip_range</code> is in the format of <code>{ip_start}-{ip_end}</code>, IPs in str format, same IP version, and ip_start is before ip_end.</p> <p>Parameters:</p> Name Type Description Default <code>ip_range</code> <code>str</code> <p>An IP address range in string format that is properly formatted.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The result as to whether or not the string is a valid IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_ip_range\n&gt;&gt;&gt; is_ip_range(\"10.100.100.255\")\nFalse\n&gt;&gt;&gt; is_ip_range(\"10.100.100.255-10.100.101.1\")\nTrue\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_ip_range(ip_range: str) -&gt; bool:\n    \"\"\"Verifies whether or not a string is a valid IP address range.\n\n    An `ip_range` is in the format of `{ip_start}-{ip_end}`, IPs in str format, same IP version, and\n    ip_start is before ip_end.\n\n    Args:\n        ip_range: An IP address range in string format that is properly formatted.\n\n    Returns:\n        The result as to whether or not the string is a valid IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_ip_range\n        &gt;&gt;&gt; is_ip_range(\"10.100.100.255\")\n        False\n        &gt;&gt;&gt; is_ip_range(\"10.100.100.255-10.100.101.1\")\n        True\n        &gt;&gt;&gt;\n    \"\"\"\n    if \"-\" not in ip_range:\n        return False\n    start_ip, end_ip = ip_range.split(\"-\")\n    if not is_ip(start_ip) or not is_ip(end_ip):\n        return False\n    start_ip_obj = ipaddress.ip_address(start_ip)\n    end_ip_obj = ipaddress.ip_address(end_ip)\n    if not isinstance(start_ip_obj, type(end_ip_obj)):\n        return False\n    # IP version being the same is enforced above, mypy disagrees, can safely ignore\n    if not start_ip_obj &lt; end_ip_obj:  # type: ignore\n        return False\n    return True\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_ip_within","title":"<code>is_ip_within(ip, ip_compare)</code>","text":"<p>Check if an IP address, IP subnet, or IP range is within the range of a list of IP addresses, IP subnets, and IP ranges.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>IP address, IP subnet, or IP range to check.</p> required <code>ip_compare</code> <code>Union[str, List[str]]</code> <p>String or list of IP addresses, IP subnets, and IP ranges to compare against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the IP is in range, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_ip_within\n&gt;&gt;&gt; is_ip_within(\"10.100.100.10\", \"10.100.100.0/24\")\nTrue\n&gt;&gt;&gt; is_ip_within(\"10.100.100.0/25\", [\"10.100.100.0/24\", \"10.100.200.0/24\"])\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; is_ip_within(\"10.100.100.10\", [\"10.100.100.8-10.100.100.20\", \"10.100.200.0/24\"])\nTrue\n&gt;&gt;&gt; is_ip_within(\"10.100.100.8-10.100.100.20\", [\"10.100.100.0/24\"])\nTrue\n&gt;&gt;&gt; is_ip_within(\"1.1.1.1\", [\"2.2.2.2\", \"3.3.3.3\"])\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_ip_within(ip: str, ip_compare: t.Union[str, t.List[str]]) -&gt; bool:\n    \"\"\"\n    Check if an IP address, IP subnet, or IP range is within the range of a list of IP addresses, IP subnets, and IP ranges.\n\n    Args:\n        ip: IP address, IP subnet, or IP range to check.\n        ip_compare: String or list of IP addresses, IP subnets, and IP ranges to compare against.\n\n    Returns:\n        True if the IP is in range, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_ip_within\n        &gt;&gt;&gt; is_ip_within(\"10.100.100.10\", \"10.100.100.0/24\")\n        True\n        &gt;&gt;&gt; is_ip_within(\"10.100.100.0/25\", [\"10.100.100.0/24\", \"10.100.200.0/24\"])\n        True\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; is_ip_within(\"10.100.100.10\", [\"10.100.100.8-10.100.100.20\", \"10.100.200.0/24\"])\n        True\n        &gt;&gt;&gt; is_ip_within(\"10.100.100.8-10.100.100.20\", [\"10.100.100.0/24\"])\n        True\n        &gt;&gt;&gt; is_ip_within(\"1.1.1.1\", [\"2.2.2.2\", \"3.3.3.3\"])\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n\n    def _convert_ip(ip: str) -&gt; str:\n        if is_ip(ip):\n            if \".\" in ip:\n                mask = \"32\"\n            else:\n                mask = \"128\"\n            return f\"{ip}/{mask}\"\n        return ip\n\n    if \"-\" in ip:\n        ip_obj_start, ip_obj_end = get_range_ips(ip)\n    else:\n        ip_obj = ipaddress.ip_network(_convert_ip(ip))\n        ip_obj_start = ip_obj[0]\n        ip_obj_end = ip_obj[-1]\n\n    if isinstance(ip_compare, str):\n        ip_compare = [ip_compare]\n\n    for item in ip_compare:\n        if \"-\" in item:\n            item_obj_start, item_obj_end = get_range_ips(item)\n\n        else:\n            item_obj = ipaddress.ip_network(_convert_ip(item))\n            item_obj_start = item_obj[0]\n            item_obj_end = item_obj[-1]\n        if not isinstance(item_obj_start, type(item_obj_end)):\n            raise ValueError(\n                f\"IP range start `{item_obj_start}` and end `{item_obj_end}` IPs must both be same IPVersion.\"\n            )\n        # Use this validation method, since it is consitent with ranges\n        # vs the `.subnet_of` method which is not.\n        if item_obj_start &lt;= ip_obj_start &lt;= ip_obj_end &lt;= item_obj_end:  # type: ignore\n            return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_netmask","title":"<code>is_netmask(netmask)</code>","text":"<p>Verifies whether or not a string is a valid subnet mask.</p> <p>Parameters:</p> Name Type Description Default <code>netmask</code> <code>str</code> <p>A subnet mask in</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if string is a valid subnet mask. Otherwise, false.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_netmask\n&gt;&gt;&gt; is_netmask('255.255.255.0')\nTrue\n&gt;&gt;&gt; is_netmask('24')\nFalse\n&gt;&gt;&gt; is_netmask('255.255.266.0')\nFalse\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_netmask(netmask: str) -&gt; bool:\n    \"\"\"Verifies whether or not a string is a valid subnet mask.\n\n    Args:\n        netmask: A subnet mask in\n\n    Returns:\n        True if string is a valid subnet mask. Otherwise, false.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_netmask\n        &gt;&gt;&gt; is_netmask('255.255.255.0')\n        True\n        &gt;&gt;&gt; is_netmask('24')\n        False\n        &gt;&gt;&gt; is_netmask('255.255.266.0')\n        False\n    \"\"\"\n    try:\n        return int(ipaddress.ip_address(netmask)) in IPV4_MASKS or int(ipaddress.ip_address(netmask)) in IPV6_MASKS\n    except ValueError:\n        return False\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_network","title":"<code>is_network(ip_network)</code>","text":"<p>Verifies whether or not a string is a valid IP Network with a Mask.</p> <p>Parameters:</p> Name Type Description Default <code>ip_network</code> <code>str</code> <p>An IP network in string format that is able to be converted by <code>ipaddress</code> library.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The result as to whether or not the string is a valid IP network.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_network\n&gt;&gt;&gt; is_network(\"10.100.100.0\")\nFalse\n&gt;&gt;&gt; is_network(\"10.100.100.0/24\")\nTrue\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_network(ip_network: str) -&gt; bool:\n    \"\"\"Verifies whether or not a string is a valid IP Network with a Mask.\n\n    Args:\n        ip_network: An IP network in string format that is able to be converted by `ipaddress` library.\n\n    Returns:\n        The result as to whether or not the string is a valid IP network.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_network\n        &gt;&gt;&gt; is_network(\"10.100.100.0\")\n        False\n        &gt;&gt;&gt; is_network(\"10.100.100.0/24\")\n        True\n        &gt;&gt;&gt;\n    \"\"\"\n    if \"/\" not in ip_network:\n        return False\n    try:\n        ipaddress.ip_network(ip_network)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.is_reversible_wildcardmask","title":"<code>is_reversible_wildcardmask(wildcardmask)</code>","text":"<p>Verifies whether a wildcard mask is valid or not.</p> <p>Parameters:</p> Name Type Description Default <code>wildcardmask</code> <code>str</code> <p>A wildcard mask</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the wildcard mask is valid. Otherwise false.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import is_reversible_wildcardmask\n&gt;&gt;&gt; is_reversible_wildcardmask('0.0.0.255')\nTrue\n&gt;&gt;&gt; is_reversible_wildcardmask('0.0.255.0')\nFalse\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def is_reversible_wildcardmask(wildcardmask: str) -&gt; bool:\n    \"\"\"Verifies whether a wildcard mask is valid or not.\n\n    Args:\n        wildcardmask: A wildcard mask\n\n    Returns:\n        True if the wildcard mask is valid. Otherwise false.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import is_reversible_wildcardmask\n        &gt;&gt;&gt; is_reversible_wildcardmask('0.0.0.255')\n        True\n        &gt;&gt;&gt; is_reversible_wildcardmask('0.0.255.0')\n        False\n    \"\"\"\n    try:\n        parts = wildcardmask.split(\".\")\n        if len(parts) != 4 or any(not p.isdigit() for p in parts):\n            return False\n        octets = [int(p) for p in parts]\n        if any(o &lt; 0 or o &gt; 255 for o in octets):\n            return False\n    except ValueError:\n        return False\n\n    inverted_octets = [255 - o for o in octets]\n    inverted_str = \".\".join(str(i) for i in inverted_octets)\n    return is_netmask(inverted_str)\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.netmask_to_cidr","title":"<code>netmask_to_cidr(netmask)</code>","text":"<p>Creates a CIDR notation of a given subnet mask in decimal format.</p> <p>Parameters:</p> Name Type Description Default <code>netmask</code> <code>str</code> <p>A subnet mask in decimal format.</p> required <p>Returns:</p> Type Description <code>int</code> <p>CIDR representation of subnet mask.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import netmask_to_cidr\n&gt;&gt;&gt; netmask_to_cidr(\"255.255.255.0\")\n24\n&gt;&gt;&gt; netmask_to_cidr(\"255.255.254.0\")\n23\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def netmask_to_cidr(netmask: str) -&gt; int:\n    \"\"\"Creates a CIDR notation of a given subnet mask in decimal format.\n\n    Args:\n        netmask: A subnet mask in decimal format.\n\n    Returns:\n        CIDR representation of subnet mask.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import netmask_to_cidr\n        &gt;&gt;&gt; netmask_to_cidr(\"255.255.255.0\")\n        24\n        &gt;&gt;&gt; netmask_to_cidr(\"255.255.254.0\")\n        23\n    \"\"\"\n    if is_netmask(netmask):\n        return bin(int(ipaddress.ip_address(netmask))).count(\"1\")\n    raise ValueError(\"Subnet mask is not valid.\")\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.netmask_to_wildcardmask","title":"<code>netmask_to_wildcardmask(netmask)</code>","text":"<p>Convert a standard IPv4 netmask to its wildcardmask.</p> <p>Parameters:</p> Name Type Description Default <code>netmask</code> <code>str</code> <p>The IPv4 netmask (e.g. \"255.255.255.0\").</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding wildcardmask (e.g. \"0.0.0.255\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import netmask_to_wildcardmask\n&gt;&gt;&gt; netmask_to_wildcardmask(\"255.255.255.0\")\n'0.0.0.255'\n&gt;&gt;&gt; netmask_to_wildcardmask(\"255.255.0.0\")\n'0.0.255.255'\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def netmask_to_wildcardmask(netmask: str) -&gt; str:\n    \"\"\"\n    Convert a standard IPv4 netmask to its wildcardmask.\n\n    Args:\n        netmask (str): The IPv4 netmask (e.g. \"255.255.255.0\").\n\n    Returns:\n        str: The corresponding wildcardmask (e.g. \"0.0.0.255\").\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import netmask_to_wildcardmask\n        &gt;&gt;&gt; netmask_to_wildcardmask(\"255.255.255.0\")\n        '0.0.0.255'\n        &gt;&gt;&gt; netmask_to_wildcardmask(\"255.255.0.0\")\n        '0.0.255.255'\n    \"\"\"\n    if is_netmask(netmask):\n        octets: t.List[int] = [int(o) for o in netmask.split(\".\")]\n        inverted = [255 - octet for octet in octets]\n        return \".\".join(str(i) for i in inverted)\n    raise ValueError(\"Subnet mask is not valid.\")\n</code></pre>"},{"location":"dev/code_reference/ip.html#netutils.ip.wildcardmask_to_netmask","title":"<code>wildcardmask_to_netmask(wildcardmask)</code>","text":"<p>Convert a wildcardmask to its corresponding IPv4 netmask.</p> <p>Parameters:</p> Name Type Description Default <code>wildcardmask</code> <code>str</code> <p>The IPv4 wildcardmask (e.g. \"0.0.0.255\").</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding netmask (e.g. \"255.255.255.0\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ip import wildcardmask_to_netmask\n&gt;&gt;&gt; wildcardmask_to_netmask(\"0.0.0.255\")\n'255.255.255.0'\n&gt;&gt;&gt; wildcardmask_to_netmask(\"0.0.255.255\")\n'255.255.0.0'\n</code></pre> Source code in <code>netutils/ip.py</code> <pre><code>def wildcardmask_to_netmask(wildcardmask: str) -&gt; str:\n    \"\"\"\n    Convert a wildcardmask to its corresponding IPv4 netmask.\n\n    Args:\n        wildcardmask (str): The IPv4 wildcardmask (e.g. \"0.0.0.255\").\n\n    Returns:\n        str: The corresponding netmask (e.g. \"255.255.255.0\").\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ip import wildcardmask_to_netmask\n        &gt;&gt;&gt; wildcardmask_to_netmask(\"0.0.0.255\")\n        '255.255.255.0'\n        &gt;&gt;&gt; wildcardmask_to_netmask(\"0.0.255.255\")\n        '255.255.0.0'\n    \"\"\"\n    if is_reversible_wildcardmask(wildcardmask):\n        octets: t.List[int] = [int(o) for o in wildcardmask.split(\".\")]\n        inverted = [255 - octet for octet in octets]\n        return \".\".join(str(i) for i in inverted)\n    raise ValueError(\"Wildcard mask is not valid.\")\n</code></pre>"},{"location":"dev/code_reference/lib_helpers.html","title":"Library Helpers","text":""},{"location":"dev/code_reference/lib_helpers.html#netutils.lib_helpers","title":"<code>netutils.lib_helpers</code>","text":"<p>Helpers to expose network automation library functionality support.</p>"},{"location":"dev/code_reference/lib_helpers.html#netutils.lib_helpers.get_napalm_getters","title":"<code>get_napalm_getters()</code>","text":"<p>Utility to return a dictionary of napalm getters based on install napalm version.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, bool]]</code> <p>Keys are OS and values are a dictionary of supported napalm getters.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If optional dependency Napalm is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.lib_helpers import get_napalm_getters\n&gt;&gt;&gt; napalm_getters = get_napalm_getters()\n&gt;&gt;&gt; napalm_getters[\"eos\"][\"get_arp_table\"]\n&gt;&gt;&gt; True\n&gt;&gt;&gt; napalm_getters[\"eos\"][\"get_ipv6_neighbors_table\"]\n&gt;&gt;&gt; False\n</code></pre> Source code in <code>netutils/lib_helpers.py</code> <pre><code>def get_napalm_getters() -&gt; t.Dict[str, t.Dict[str, bool]]:\n    \"\"\"Utility to return a dictionary of napalm getters based on install napalm version.\n\n    Returns:\n        Keys are OS and values are a dictionary of supported napalm getters.\n\n    Raises:\n        ImportError: If optional dependency Napalm is not installed.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.lib_helpers import get_napalm_getters\n        &gt;&gt;&gt; napalm_getters = get_napalm_getters()  # doctest: +SKIP\n        &gt;&gt;&gt; napalm_getters[\"eos\"][\"get_arp_table\"]  # doctest: +SKIP\n        &gt;&gt;&gt; True  # doctest: +SKIP\n        &gt;&gt;&gt; napalm_getters[\"eos\"][\"get_ipv6_neighbors_table\"]  # doctest: +SKIP\n        &gt;&gt;&gt; False  # doctest: +SKIP\n    \"\"\"\n    try:\n        # Import NAPALM here at call time, rather than at import time, as importing NAPALM is rather time consuming\n        # pylint: disable=import-outside-toplevel\n        from napalm import get_network_driver\n        from napalm.base.exceptions import ModuleImportError\n    except ImportError as err:\n        raise ImportError(\"Napalm must be installed for this function to operate.\") from err\n\n    napalm_dict: t.Dict[str, t.Dict[str, bool]] = {}\n    oses = NAPALM_LIB_MAPPER.keys()\n    for my_os in oses:\n        try:\n            get_network_driver(my_os)\n        except ModuleImportError:\n            continue\n        napalm_dict[my_os] = {}\n        for getter in inspect.getmembers(get_network_driver(my_os), predicate=inspect.isfunction):\n            if getter[0].startswith(\"get_\"):\n                # If the module is only in the base class it has not been implemented by the child class.\n                state = bool(getter[1].__module__ == \"napalm.base.base\")\n                napalm_dict[my_os][getter[0]] = state\n    return napalm_dict\n</code></pre>"},{"location":"dev/code_reference/lib_mapping.html","title":"Library Mapping","text":"<p>Review how to use code within the user documentation</p>"},{"location":"dev/code_reference/lib_mapping.html#netutils.lib_mapper","title":"<code>netutils.lib_mapper</code>","text":"<p>Variable definitions to map from network automation library to network automation library.</p>"},{"location":"dev/code_reference/mac.html","title":"Mac Address","text":""},{"location":"dev/code_reference/mac.html#netutils.mac","title":"<code>netutils.mac</code>","text":"<p>Functions for working with MAC addresses.</p>"},{"location":"dev/code_reference/mac.html#netutils.mac.get_oui","title":"<code>get_oui(mac)</code>","text":"<p>Returns the company name for a given mac as defined by the IEEE.</p> <p>Parameters:</p> Name Type Description Default <code>mac</code> <code>str</code> <p>A MAC address in string format that matches one of the defined regex patterns.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the company the mac is related to.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.mac import get_oui\n&gt;&gt;&gt; from netutils.data_files.oui_mappings import OUI_MAPPINGS\n&gt;&gt;&gt; get_oui(\"cc.79.d7.dd.ee.ff\")\n'Cisco Systems, Inc'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/mac.py</code> <pre><code>@_valid_mac\ndef get_oui(mac: str) -&gt; str:\n    \"\"\"Returns the company name for a given mac as defined by the IEEE.\n\n    Args:\n        mac: A MAC address in string format that matches one of the defined regex patterns.\n\n    Returns:\n        The name of the company the mac is related to.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.mac import get_oui\n        &gt;&gt;&gt; from netutils.data_files.oui_mappings import OUI_MAPPINGS\n        &gt;&gt;&gt; get_oui(\"cc.79.d7.dd.ee.ff\")\n        'Cisco Systems, Inc'\n        &gt;&gt;&gt;\n    \"\"\"\n    from netutils.data_files.oui_mappings import OUI_MAPPINGS  # pylint: disable=import-outside-toplevel\n\n    normalized_mac_prefix = mac_normalize(mac)[0:6]\n    oui_company = OUI_MAPPINGS.get(normalized_mac_prefix)\n\n    if not oui_company:\n        raise ValueError(f\"There was no matching entry in OUI_MAPPINGS for {normalized_mac_prefix}.\")\n\n    return oui_company\n</code></pre>"},{"location":"dev/code_reference/mac.html#netutils.mac.is_valid_mac","title":"<code>is_valid_mac(mac)</code>","text":"<p>Verifies whether or not a string is a valid MAC address.</p> <p>Parameters:</p> Name Type Description Default <code>mac</code> <code>str</code> <p>A MAC address in string format that matches one of the defined regex patterns.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The result as to whether or not the string is a valid MAC address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.mac import is_valid_mac\n&gt;&gt;&gt; is_valid_mac(\"aa.bb.cc.dd.ee.ff\")\nTrue\n&gt;&gt;&gt; is_valid_mac(\"aa.bb.cc.dd.ee.gg\")\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/mac.py</code> <pre><code>def is_valid_mac(mac: str) -&gt; bool:\n    \"\"\"Verifies whether or not a string is a valid MAC address.\n\n    Args:\n        mac: A MAC address in string format that matches one of the defined regex patterns.\n\n    Returns:\n        The result as to whether or not the string is a valid MAC address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.mac import is_valid_mac\n        &gt;&gt;&gt; is_valid_mac(\"aa.bb.cc.dd.ee.ff\")\n        True\n        &gt;&gt;&gt; is_valid_mac(\"aa.bb.cc.dd.ee.gg\")\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    for pattern in list(MAC_REGEX.values()):\n        if re.fullmatch(pattern, mac):\n            return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/mac.html#netutils.mac.mac_normalize","title":"<code>mac_normalize(mac)</code>","text":"<p>Return the MAC address with only the address, and no special characters.</p> <p>Parameters:</p> Name Type Description Default <code>mac</code> <code>str</code> <p>A MAC address in string format that matches one of the defined regex patterns.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The MAC address with no special characters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.mac import mac_normalize\n&gt;&gt;&gt; mac_normalize(\"aa.bb.cc.dd.ee.ff\")\n'aabbccddeeff'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/mac.py</code> <pre><code>@_valid_mac\ndef mac_normalize(mac: str) -&gt; str:\n    \"\"\"Return the MAC address with only the address, and no special characters.\n\n    Args:\n        mac: A MAC address in string format that matches one of the defined regex patterns.\n\n    Returns:\n        The MAC address with no special characters.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.mac import mac_normalize\n        &gt;&gt;&gt; mac_normalize(\"aa.bb.cc.dd.ee.ff\")\n        'aabbccddeeff'\n        &gt;&gt;&gt;\n    \"\"\"\n    chars = \":-.\"\n    for char in chars:\n        if char in mac:\n            mac = mac.replace(char, \"\")\n    return mac\n</code></pre>"},{"location":"dev/code_reference/mac.html#netutils.mac.mac_to_format","title":"<code>mac_to_format(mac, frmt='MAC_NO_SPECIAL')</code>","text":"<p>Converts the MAC address to a specific format.</p> <p>The <code>frmt</code> is a combination delimiter (COLON, DASH, DOT) and number of characters (TWO, FOUR), e.g. f'MAC_{delimiter}_{char_num}' or if no special characters as <code>MAC_NO_SPECIAL</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mac</code> <code>str</code> <p>A MAC address in string format that matches one of the defined regex patterns.</p> required <code>frmt</code> <code>str</code> <p>A format in which the MAC address should be returned in, one of MAC_COLON_TWO, MAC_COLON_FOUR, MAC_DASH_TWO, MAC_DASH_FOUR, MAC_DOT_TWO, MAC_DOT_FOUR, MAC_NO_SPECIAL.</p> <code>'MAC_NO_SPECIAL'</code> <p>Returns:</p> Type Description <code>str</code> <p>A MAC address in the specified format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.mac import mac_to_format\n&gt;&gt;&gt; mac_to_format(\"aa.bb.cc.dd.ee.ff\", \"MAC_DASH_FOUR\")\n'aabb-ccdd-eeff'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/mac.py</code> <pre><code>@_valid_mac\ndef mac_to_format(mac: str, frmt: str = \"MAC_NO_SPECIAL\") -&gt; str:\n    \"\"\"Converts the MAC address to a specific format.\n\n    The `frmt` is a combination delimiter (COLON, DASH, DOT) and number\n    of characters (TWO, FOUR), e.g. f'MAC_{delimiter}_{char_num}' or if no\n    special characters as `MAC_NO_SPECIAL`.\n\n    Args:\n        mac: A MAC address in string format that matches one of the defined regex patterns.\n        frmt: A format in which the MAC address should be returned in, one of MAC_COLON_TWO, MAC_COLON_FOUR, MAC_DASH_TWO, MAC_DASH_FOUR, MAC_DOT_TWO, MAC_DOT_FOUR, MAC_NO_SPECIAL.\n\n    Returns:\n        A MAC address in the specified format.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.mac import mac_to_format\n        &gt;&gt;&gt; mac_to_format(\"aa.bb.cc.dd.ee.ff\", \"MAC_DASH_FOUR\")\n        'aabb-ccdd-eeff'\n        &gt;&gt;&gt;\n    \"\"\"\n    if not MAC_CREATE.get(frmt):\n        format_choices = \", \".join(MAC_CREATE)\n        raise ValueError(f\"An invalid mac format was provided in: `{frmt}`, not one of [{format_choices}]\")\n    mac = mac_normalize(mac)\n    count = MAC_CREATE[frmt][\"count\"]\n    char = MAC_CREATE[frmt][\"char\"]\n    return char.join([mac[i : i + count] for i in range(0, len(mac), count)])  # type: ignore # noqa: E203\n</code></pre>"},{"location":"dev/code_reference/mac.html#netutils.mac.mac_to_int","title":"<code>mac_to_int(mac)</code>","text":"<p>Converts the MAC address to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>mac</code> <code>str</code> <p>A MAC address in string format that matches one of the defined regex patterns.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The valid MAC address converted to an integer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.mac import mac_to_int\n&gt;&gt;&gt; mac_to_int(\"aa.bb.cc.dd.ee.ff\")\n187723572702975\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/mac.py</code> <pre><code>@_valid_mac\ndef mac_to_int(mac: str) -&gt; int:\n    \"\"\"Converts the MAC address to an integer.\n\n    Args:\n        mac: A MAC address in string format that matches one of the defined regex patterns.\n\n    Returns:\n        The valid MAC address converted to an integer.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.mac import mac_to_int\n        &gt;&gt;&gt; mac_to_int(\"aa.bb.cc.dd.ee.ff\")\n        187723572702975\n        &gt;&gt;&gt;\n    \"\"\"\n    return int(mac_normalize(mac), 16)\n</code></pre>"},{"location":"dev/code_reference/mac.html#netutils.mac.mac_type","title":"<code>mac_type(mac)</code>","text":"<p>Retuns the \"type\" of MAC address, as defined by the regex pattern names.</p> <p>Parameters:</p> Name Type Description Default <code>mac</code> <code>str</code> <p>A MAC address in string format that matches one of the defined regex patterns.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The regex pattern type of the MAC address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.mac import mac_type\n&gt;&gt;&gt; mac_type(\"aa.bb.cc.dd.ee.ff\")\n'MAC_DOT_TWO'\n&gt;&gt;&gt; mac_type(\"aabb.ccdd.eeff\")\n'MAC_DOT_FOUR'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/mac.py</code> <pre><code>@_valid_mac\ndef mac_type(mac: str) -&gt; t.Optional[str]:\n    \"\"\"Retuns the \"type\" of MAC address, as defined by the regex pattern names.\n\n    Args:\n        mac: A MAC address in string format that matches one of the defined regex patterns.\n\n    Returns:\n        The regex pattern type of the MAC address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.mac import mac_type\n        &gt;&gt;&gt; mac_type(\"aa.bb.cc.dd.ee.ff\")\n        'MAC_DOT_TWO'\n        &gt;&gt;&gt; mac_type(\"aabb.ccdd.eeff\")\n        'MAC_DOT_FOUR'\n        &gt;&gt;&gt;\n    \"\"\"\n    for name, pattern in MAC_REGEX.items():\n        if re.fullmatch(pattern, mac):\n            return name\n    return None\n</code></pre>"},{"location":"dev/code_reference/nist.html","title":"NIST URLs","text":""},{"location":"dev/code_reference/nist.html#netutils.nist","title":"<code>netutils.nist</code>","text":"<p>Classes and functions used for building NIST URLs from the os platform values.</p>"},{"location":"dev/code_reference/nist.html#netutils.nist.OsPlatform","title":"<code>OsPlatform</code>","text":"<p>Base class for dynamically generated vendor specific platform data classes.</p> Source code in <code>netutils/nist.py</code> <pre><code>class OsPlatform(metaclass=abc.ABCMeta):\n    \"\"\"Base class for dynamically generated vendor specific platform data classes.\"\"\"\n\n    def asdict(self) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Returns dictionary representation of the class attributes.\"\"\"\n        return dataclasses.asdict(self)  # type: ignore\n\n    @abc.abstractmethod\n    def get_nist_urls(self) -&gt; t.List[str]:\n        \"\"\"Returns list of NIST URLs for the platform.\"\"\"\n\n    def get(self, key: str) -&gt; t.Any:\n        \"\"\"Return value of the attribute matching provided name or None if no attribute is found.\"\"\"\n        return getattr(self, key, None)\n\n    def keys(self) -&gt; t.KeysView[t.Any]:\n        \"\"\"Return attributes and their values as dict keys.\"\"\"\n        # Disabling pylint no-member due to BUG: https://github.com/pylint-dev/pylint/issues/7126\n        return self.__annotations__.keys()  # pylint: disable=no-member\n\n    def __getitem__(self, key: str) -&gt; t.Any:\n        \"\"\"Allow retrieving attributes using subscript notation.\"\"\"\n        return getattr(self, key)\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.OsPlatform.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allow retrieving attributes using subscript notation.</p> Source code in <code>netutils/nist.py</code> <pre><code>def __getitem__(self, key: str) -&gt; t.Any:\n    \"\"\"Allow retrieving attributes using subscript notation.\"\"\"\n    return getattr(self, key)\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.OsPlatform.asdict","title":"<code>asdict()</code>","text":"<p>Returns dictionary representation of the class attributes.</p> Source code in <code>netutils/nist.py</code> <pre><code>def asdict(self) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Returns dictionary representation of the class attributes.\"\"\"\n    return dataclasses.asdict(self)  # type: ignore\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.OsPlatform.get","title":"<code>get(key)</code>","text":"<p>Return value of the attribute matching provided name or None if no attribute is found.</p> Source code in <code>netutils/nist.py</code> <pre><code>def get(self, key: str) -&gt; t.Any:\n    \"\"\"Return value of the attribute matching provided name or None if no attribute is found.\"\"\"\n    return getattr(self, key, None)\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.OsPlatform.get_nist_urls","title":"<code>get_nist_urls()</code>  <code>abstractmethod</code>","text":"<p>Returns list of NIST URLs for the platform.</p> Source code in <code>netutils/nist.py</code> <pre><code>@abc.abstractmethod\ndef get_nist_urls(self) -&gt; t.List[str]:\n    \"\"\"Returns list of NIST URLs for the platform.\"\"\"\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.OsPlatform.keys","title":"<code>keys()</code>","text":"<p>Return attributes and their values as dict keys.</p> Source code in <code>netutils/nist.py</code> <pre><code>def keys(self) -&gt; t.KeysView[t.Any]:\n    \"\"\"Return attributes and their values as dict keys.\"\"\"\n    # Disabling pylint no-member due to BUG: https://github.com/pylint-dev/pylint/issues/7126\n    return self.__annotations__.keys()  # pylint: disable=no-member\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.get_nist_urls","title":"<code>get_nist_urls(network_driver, version)</code>","text":"<p>Generate list of possible NIST URLs for the Network Driver, and Version.</p> <p>Parameters:</p> Name Type Description Default <code>network_driver</code> <code>str</code> <p>Value of device network_driver (Ex: cisco_ios, arista_eos)</p> required <code>version</code> <code>str</code> <p>OS Software Platform Version</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>t.List[str]: NIST URLs to search for possible CVE matches</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.nist import get_nist_urls\n&gt;&gt;&gt; get_nist_urls('cisco_ios', '15.3')\n['https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:o:cisco:ios:15.3:*']\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/nist.py</code> <pre><code>def get_nist_urls(network_driver: str, version: str) -&gt; t.List[str]:\n    \"\"\"Generate list of possible NIST URLs for the Network Driver, and Version.\n\n    Args:\n        network_driver (str): Value of device network_driver (Ex: cisco_ios, arista_eos)\n        version (str): OS Software Platform Version\n\n    Returns:\n        t.List[str]: NIST URLs to search for possible CVE matches\n\n    Examples:\n        &gt;&gt;&gt; from netutils.nist import get_nist_urls\n        &gt;&gt;&gt; get_nist_urls('cisco_ios', '15.3')\n        ['https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:o:cisco:ios:15.3:*']\n        &gt;&gt;&gt;\n    \"\"\"\n    # DICTIONARY FOR VENDOR/PLATFORM TO NETWORK_DRIVER; UPDATE AS NEEDED\n    vendor_os: str = NIST_LIB_MAPPER_REVERSE.get(network_driver, \"\")\n    if not vendor_os:\n        raise ValueError(\n            f\"The network driver `{network_driver}` has no associated mapping, the supported drivers are {list(NIST_LIB_MAPPER_REVERSE.keys())}.\"\n        )\n    vendor, os_name = vendor_os.split(\":\")\n\n    return get_nist_vendor_platform_urls(vendor, os_name, version)\n</code></pre>"},{"location":"dev/code_reference/nist.html#netutils.nist.get_nist_vendor_platform_urls","title":"<code>get_nist_vendor_platform_urls(vendor, platform, version)</code>","text":"<p>Generate list of possible NIST URLs for the Vendor, OS Platform, and Version.</p> <p>Parameters:</p> Name Type Description Default <code>vendor</code> <code>str</code> <p>OS Software Platform Vendor/Manufacturer</p> required <code>platform</code> <code>str</code> <p>OS Software Platform Name</p> required <code>version</code> <code>str</code> <p>OS Software Platform Version</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>t.List[str]: NIST URLs to search for possible CVE matches</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.nist import get_nist_vendor_platform_urls\n&gt;&gt;&gt; get_nist_vendor_platform_urls('cisco', 'ios', '15.3')\n['https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:o:cisco:ios:15.3:*']\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/nist.py</code> <pre><code>def get_nist_vendor_platform_urls(vendor: str, platform: str, version: str) -&gt; t.List[str]:\n    \"\"\"Generate list of possible NIST URLs for the Vendor, OS Platform, and Version.\n\n    Args:\n        vendor (str): OS Software Platform Vendor/Manufacturer\n        platform (str): OS Software Platform Name\n        version (str): OS Software Platform Version\n\n    Returns:\n        t.List[str]: NIST URLs to search for possible CVE matches\n\n    Examples:\n        &gt;&gt;&gt; from netutils.nist import get_nist_vendor_platform_urls\n        &gt;&gt;&gt; get_nist_vendor_platform_urls('cisco', 'ios', '15.3')\n        ['https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:o:cisco:ios:15.3:*']\n        &gt;&gt;&gt;\n    \"\"\"\n    platform_data = _os_platform_object_builder(vendor, platform, version).__dict__\n\n    if vendor.lower() == \"juniper\" and platform.lower() == \"junos\":\n        return _get_nist_urls_juniper_junos(platform_data)\n    return _get_nist_urls_default(platform_data)\n</code></pre>"},{"location":"dev/code_reference/os_version.html","title":"OS Version","text":""},{"location":"dev/code_reference/os_version.html#netutils.os_version","title":"<code>netutils.os_version</code>","text":"<p>Functions for working with OS Versions.</p>"},{"location":"dev/code_reference/os_version.html#netutils.os_version.compare_version_loose","title":"<code>compare_version_loose(current_version, comparison, target_version)</code>","text":"<p>Compares two version strings using the specified comparison operation, based on LooseVersion.</p> <p>Parameters:</p> Name Type Description Default <code>current_version</code> <code>str</code> <p>The current version string to compare.</p> required <code>comparison</code> <code>str</code> <p>The comparison operation as a string (&lt;, &lt;=, ==, !=, &gt;, &gt;=).</p> required <code>target_version</code> <code>str</code> <p>The target version string to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The result of the comparison.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an invalid comparison.</p> <code>TypeError</code> <p>If not a valid version.</p> Example <p>from netutils.os_version import compare_version_loose compare_version_loose(\"3.3.3a\", \"==\", \"3.3.3a\") True compare_version_loose(\"3.3.2\", \"&lt;=\", \"3.3.3\") True compare_version_loose(\"3.3.2\", \"&gt;=\", \"3.3.3\") False </p> Source code in <code>netutils/os_version.py</code> <pre><code>def compare_version_loose(current_version: str, comparison: str, target_version: str) -&gt; bool:\n    \"\"\"\n    Compares two version strings using the specified comparison operation, based on LooseVersion.\n\n    Args:\n        current_version (str): The current version string to compare.\n        comparison (str): The comparison operation as a string (&lt;, &lt;=, ==, !=, &gt;, &gt;=).\n        target_version (str): The target version string to compare against.\n\n    Returns:\n        bool: The result of the comparison.\n\n    Raises:\n        ValueError: If there is an invalid comparison.\n        TypeError: If not a valid version.\n\n    Example:\n        &gt;&gt;&gt; from netutils.os_version import compare_version_loose\n        &gt;&gt;&gt; compare_version_loose(\"3.3.3a\", \"==\", \"3.3.3a\")\n        True\n        &gt;&gt;&gt; compare_version_loose(\"3.3.2\", \"&lt;=\", \"3.3.3\")\n        True\n        &gt;&gt;&gt; compare_version_loose(\"3.3.2\", \"&gt;=\", \"3.3.3\")\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    return _compare_version(current_version, comparison, target_version, \"loose\")\n</code></pre>"},{"location":"dev/code_reference/os_version.html#netutils.os_version.compare_version_strict","title":"<code>compare_version_strict(current_version, comparison, target_version)</code>","text":"<p>Compares two version strings using the specified comparison operation, based on LooseVersion.</p> <p>Parameters:</p> Name Type Description Default <code>current_version</code> <code>str</code> <p>The current version string to compare.</p> required <code>comparison</code> <code>str</code> <p>The comparison operation as a string (&lt;, &lt;=, ==, !=, &gt;, &gt;=).</p> required <code>target_version</code> <code>str</code> <p>The target version string to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The result of the comparison.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an invalid comparison.</p> <code>ValueError</code> <p>If not a valid version.</p> Example <p>from netutils.os_version import compare_version_strict compare_version_strict(\"3.3.3\", \"==\", \"3.3.3\") True compare_version_strict(\"3.3.2\", \"&lt;=\", \"3.3.3\") True compare_version_strict(\"3.3.2\", \"&gt;=\", \"3.3.3\") False </p> Source code in <code>netutils/os_version.py</code> <pre><code>def compare_version_strict(current_version: str, comparison: str, target_version: str) -&gt; bool:\n    \"\"\"\n    Compares two version strings using the specified comparison operation, based on LooseVersion.\n\n    Args:\n        current_version (str): The current version string to compare.\n        comparison (str): The comparison operation as a string (&lt;, &lt;=, ==, !=, &gt;, &gt;=).\n        target_version (str): The target version string to compare against.\n\n    Returns:\n        bool: The result of the comparison.\n\n    Raises:\n        ValueError: If there is an invalid comparison.\n        ValueError: If not a valid version.\n\n    Example:\n        &gt;&gt;&gt; from netutils.os_version import compare_version_strict\n        &gt;&gt;&gt; compare_version_strict(\"3.3.3\", \"==\", \"3.3.3\")\n        True\n        &gt;&gt;&gt; compare_version_strict(\"3.3.2\", \"&lt;=\", \"3.3.3\")\n        True\n        &gt;&gt;&gt; compare_version_strict(\"3.3.2\", \"&gt;=\", \"3.3.3\")\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    return _compare_version(current_version, comparison, target_version, \"strict\")\n</code></pre>"},{"location":"dev/code_reference/os_version.html#netutils.os_version.get_upgrade_path","title":"<code>get_upgrade_path(current_version, target_version, firmware_list)</code>","text":"<p>Utility to return the upgrade path from the current to target firmware version.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of firmware versions to upgrade from current to target.</p> <p>Parameters:</p> Name Type Description Default <code>current_version</code> <code>str</code> <p>Current firmware version.</p> required <code>target_version</code> <code>str</code> <p>Target firmware version.</p> required <code>firmware_list</code> <code>List[str]</code> <p>List of firmware versions to use as the upgrade path.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If target version is older than current version.</p> <code>ValueError</code> <p>If target version equals current version.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.os_version import get_upgrade_path\n&gt;&gt;&gt; get_upgrade_path(\"9.1.6\", \"10.1.9\", [\"9.1.10\", \"9.1.15-h1\", \"10.0.0\", \"10.1.9\"])\n['9.1.10', '9.1.15-h1', '10.0.0', '10.1.9']\n&gt;&gt;&gt; from netutils.constants import UPGRADE_PATHS\n&gt;&gt;&gt; get_upgrade_path(\"9.1.6\", \"10.1.9\", UPGRADE_PATHS[\"PANOS_OFFICIAL_V1\"])\n['9.1.15-h1', '10.0.0', '10.0.12', '10.1.0', '10.1.9']\n</code></pre> Source code in <code>netutils/os_version.py</code> <pre><code>def get_upgrade_path(current_version: str, target_version: str, firmware_list: t.List[str]) -&gt; t.List[str]:\n    \"\"\"Utility to return the upgrade path from the current to target firmware version.\n\n    Returns:\n        List of firmware versions to upgrade from current to target.\n\n    Args:\n        current_version: Current firmware version.\n        target_version: Target firmware version.\n        firmware_list: List of firmware versions to use as the upgrade path.\n\n    Raises:\n        ValueError: If target version is older than current version.\n        ValueError: If target version equals current version.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.os_version import get_upgrade_path\n        &gt;&gt;&gt; get_upgrade_path(\"9.1.6\", \"10.1.9\", [\"9.1.10\", \"9.1.15-h1\", \"10.0.0\", \"10.1.9\"])\n        ['9.1.10', '9.1.15-h1', '10.0.0', '10.1.9']\n        &gt;&gt;&gt; from netutils.constants import UPGRADE_PATHS\n        &gt;&gt;&gt; get_upgrade_path(\"9.1.6\", \"10.1.9\", UPGRADE_PATHS[\"PANOS_OFFICIAL_V1\"])\n        ['9.1.15-h1', '10.0.0', '10.0.12', '10.1.0', '10.1.9']\n    \"\"\"\n    if LooseVersion(current_version) &gt; LooseVersion(target_version):\n        raise ValueError(\"Target version must be newer than current version.\")\n\n    if LooseVersion(current_version) == LooseVersion(target_version):\n        raise ValueError(\"Target version equals current version. No upgrade necessary.\")\n\n    upgrade_path = [\n        version\n        for version in firmware_list\n        if LooseVersion(version) &gt; LooseVersion(current_version)\n        and LooseVersion(version) &lt;= LooseVersion(target_version)\n    ]\n\n    if target_version not in upgrade_path:\n        upgrade_path.append(target_version)\n\n    return upgrade_path\n</code></pre>"},{"location":"dev/code_reference/os_version.html#netutils.os_version.version_metadata","title":"<code>version_metadata(vendor, os_type, version)</code>","text":"<p>If a custom version parser is avaialable, use it.</p> <p>Parameters:</p> Name Type Description Default <code>vendor</code> <code>str</code> <p>Vendor name (Ex: \"Juniper\")</p> required <code>os_type</code> <code>str</code> <p>OS Type (Ex: \"JunOS\")</p> required <code>version</code> <code>str</code> <p>OS Version (Ex: \"12.4R\")</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>Dict of broken down version into vendor standards.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.os_version import version_metadata\n&gt;&gt;&gt; version_metadata(\"Cisco\", \"IOS\", \"15.5\")\n{'major': '15', 'minor': '5', 'vendor_metadata': False}\n&gt;&gt;&gt; version_metadata(\"juniper\", \"junos\", \"12.4R\")\n{'isservice': False, 'ismaintenance': False, 'isfrs': True, 'isspecial': False, 'service': None, 'service_build': None, 'service_respin': None, 'main': '12', 'minor': '4', 'type': 'R', 'build': None, 'major': '12', 'patch': None, 'vendor_metadata': True}\n</code></pre> Source code in <code>netutils/os_version.py</code> <pre><code>def version_metadata(vendor: str, os_type: str, version: str) -&gt; t.Dict[str, t.Any]:\n    \"\"\"If a custom version parser is avaialable, use it.\n\n    Args:\n        vendor (str): Vendor name (Ex: \"Juniper\")\n        os_type (str): OS Type (Ex: \"JunOS\")\n        version (str): OS Version (Ex: \"12.4R\")\n\n    Returns:\n        dict: Dict of broken down version into vendor standards.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.os_version import version_metadata\n        &gt;&gt;&gt; version_metadata(\"Cisco\", \"IOS\", \"15.5\")\n        {'major': '15', 'minor': '5', 'vendor_metadata': False}\n        &gt;&gt;&gt; version_metadata(\"juniper\", \"junos\", \"12.4R\")\n        {'isservice': False, 'ismaintenance': False, 'isfrs': True, 'isspecial': False, 'service': None, 'service_build': None, 'service_respin': None, 'main': '12', 'minor': '4', 'type': 'R', 'build': None, 'major': '12', 'patch': None, 'vendor_metadata': True}\n    \"\"\"\n    parsed_version = {}\n    if vendor in version_metadata_parsers:\n        try:\n            parsed_version = version_metadata_parsers[vendor][os_type](version)  # type:ignore\n            parsed_version.update({\"vendor_metadata\": True})\n        except KeyError:\n            parsed_version = version_metadata_parsers[\"default\"](version)  # type:ignore\n            parsed_version.update({\"vendor_metadata\": False})\n    else:\n        parsed_version = version_metadata_parsers[\"default\"](version)  # type:ignore\n        parsed_version.update({\"vendor_metadata\": False})\n\n    return parsed_version  # type:ignore\n</code></pre>"},{"location":"dev/code_reference/password.html","title":"Passwords","text":""},{"location":"dev/code_reference/password.html#netutils.password","title":"<code>netutils.password</code>","text":"<p>Functions for working with Passwords.</p>"},{"location":"dev/code_reference/password.html#netutils.password.compare_cisco_type5","title":"<code>compare_cisco_type5(unencrypted_password, encrypted_password, return_original=False)</code>","text":"<p>Given an encrypted and unencrypted password of Cisco Type 5 password, compare if they are a match.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>encrypted_password</code> <code>str</code> <p>A password that has been encrypted.</p> required <code>return_original</code> <code>bool</code> <p>Whether or not to return the original, this is helpful when used to populate the configuration. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, bool]</code> <p>Whether or not the password is as compared to.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import compare_cisco_type5\n&gt;&gt;&gt; compare_cisco_type5(\"cisco\",\"$1$nTc1$Z28sUTcWfXlvVe2x.3XAa.\")\nTrue\n&gt;&gt;&gt; compare_cisco_type5(\"not_cisco\",\"$1$nTc1$Z28sUTcWfXlvVe2x.3XAa.\")\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def compare_cisco_type5(\n    unencrypted_password: str, encrypted_password: str, return_original: bool = False\n) -&gt; t.Union[str, bool]:\n    \"\"\"Given an encrypted and unencrypted password of Cisco Type 5 password, compare if they are a match.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        encrypted_password: A password that has been encrypted.\n        return_original: Whether or not to return the original, this is helpful when used to populate the configuration. Defaults to False.\n\n    Returns:\n        Whether or not the password is as compared to.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import compare_cisco_type5\n        &gt;&gt;&gt; compare_cisco_type5(\"cisco\",\"$1$nTc1$Z28sUTcWfXlvVe2x.3XAa.\")  # doctest: +SKIP\n        True\n        &gt;&gt;&gt; compare_cisco_type5(\"not_cisco\",\"$1$nTc1$Z28sUTcWfXlvVe2x.3XAa.\")  # doctest: +SKIP\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    salt = get_hash_salt(encrypted_password)\n    if encrypt_cisco_type5(unencrypted_password, salt) == encrypted_password:\n        if return_original is True:\n            return encrypted_password\n        return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.compare_cisco_type7","title":"<code>compare_cisco_type7(unencrypted_password, encrypted_password, return_original=False)</code>","text":"<p>Given an encrypted and unencrypted password of Cisco Type 7 password, compare if they are a match.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>encrypted_password</code> <code>str</code> <p>A password that has been encrypted.</p> required <code>return_original</code> <code>bool</code> <p>Whether or not to return the original, this is helpful when used to populate the configuration. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, bool]</code> <p>Whether or not the password is as compared to.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import compare_cisco_type7\n&gt;&gt;&gt; compare_cisco_type7(\"cisco\",\"121A0C041104\")\nTrue\n&gt;&gt;&gt; compare_cisco_type7(\"not_cisco\",\"121A0C041104\")\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def compare_cisco_type7(\n    unencrypted_password: str, encrypted_password: str, return_original: bool = False\n) -&gt; t.Union[str, bool]:\n    \"\"\"Given an encrypted and unencrypted password of Cisco Type 7 password, compare if they are a match.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        encrypted_password: A password that has been encrypted.\n        return_original: Whether or not to return the original, this is helpful when used to populate the configuration. Defaults to False.\n\n    Returns:\n        Whether or not the password is as compared to.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import compare_cisco_type7\n        &gt;&gt;&gt; compare_cisco_type7(\"cisco\",\"121A0C041104\")\n        True\n        &gt;&gt;&gt; compare_cisco_type7(\"not_cisco\",\"121A0C041104\")\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    if decrypt_cisco_type7(encrypted_password) == unencrypted_password:\n        if return_original is True:\n            return encrypted_password\n        return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.compare_cisco_type9","title":"<code>compare_cisco_type9(unencrypted_password, encrypted_password, return_original=False)</code>","text":"<p>Given an encrypted and unencrypted password of Cisco Type 9 password, compare if they are a match.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>encrypted_password</code> <code>str</code> <p>A password that has been encrypted.</p> required <code>return_original</code> <code>bool</code> <p>Whether or not to return the original, this is helpful when used to populate the configuration. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, bool]</code> <p>Whether or not the password is as compared to.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import compare_cisco_type9\n&gt;&gt;&gt; compare_cisco_type9(\"cisco\",\"$9$588|P!iWqEx=Wf$nadLmT9snc6V9QAeUuATSOoCAZMQIHqixJfZpQj5EU2\")\nTrue\n&gt;&gt;&gt; compare_cisco_type9(\"not_cisco\",\"$9$588|P!iWqEx=Wf$nadLmT9snc6V9QAeUuATSOoCAZMQIHqixJfZpQj5EU2\")\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def compare_cisco_type9(\n    unencrypted_password: str, encrypted_password: str, return_original: bool = False\n) -&gt; t.Union[str, bool]:\n    \"\"\"Given an encrypted and unencrypted password of Cisco Type 9 password, compare if they are a match.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        encrypted_password: A password that has been encrypted.\n        return_original: Whether or not to return the original, this is helpful when used to populate the configuration. Defaults to False.\n\n    Returns:\n        Whether or not the password is as compared to.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import compare_cisco_type9\n        &gt;&gt;&gt; compare_cisco_type9(\"cisco\",\"$9$588|P!iWqEx=Wf$nadLmT9snc6V9QAeUuATSOoCAZMQIHqixJfZpQj5EU2\")\n        True\n        &gt;&gt;&gt; compare_cisco_type9(\"not_cisco\",\"$9$588|P!iWqEx=Wf$nadLmT9snc6V9QAeUuATSOoCAZMQIHqixJfZpQj5EU2\")\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    salt = get_hash_salt(encrypted_password)\n    if encrypt_cisco_type9(unencrypted_password, salt) == encrypted_password:\n        if return_original is True:\n            return encrypted_password\n        return True\n    return False\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.decrypt_cisco_type7","title":"<code>decrypt_cisco_type7(encrypted_password)</code>","text":"<p>Given an unencrypted password of Cisco Type 7 password decrypt it.</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_password</code> <code>str</code> <p>A password that has been encrypted, and will be decrypted.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The unencrypted_password password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import decrypt_cisco_type7\n&gt;&gt;&gt; decrypt_cisco_type7(\"121A0C041104\")\n'cisco'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def decrypt_cisco_type7(encrypted_password: str) -&gt; str:\n    \"\"\"Given an unencrypted password of Cisco Type 7 password decrypt it.\n\n    Args:\n        encrypted_password: A password that has been encrypted, and will be decrypted.\n\n    Returns:\n        The unencrypted_password password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import decrypt_cisco_type7\n        &gt;&gt;&gt; decrypt_cisco_type7(\"121A0C041104\")\n        'cisco'\n        &gt;&gt;&gt;\n    \"\"\"\n    return \"\".join(\n        [\n            chr(\n                int(encrypted_password[i : i + 2], 16)  # noqa: E203\n                ^ ord(\n                    \"dsfd;kfoA,.iyewrkldJKDHSUBsgvca69834ncxv9873254k;fg87\"[\n                        int((int(encrypted_password[:2]) + i / 2 - 1) % 53)\n                    ]\n                )\n            )\n            for i in range(2, len(encrypted_password), 2)\n        ]\n    )\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.decrypt_juniper_type9","title":"<code>decrypt_juniper_type9(encrypted_password)</code>","text":"<p>Given an encrypted Junos $9$ type password, decrypt it.</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_password</code> <code>str</code> <p>A password that has been encrypted, and will be decrypted.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The unencrypted_password password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import decrypt_juniper_type9\n&gt;&gt;&gt; decrypt_juniper_type9(\"$9$7YdwgGDkTz6oJz69A1INdb\")\n'juniper'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def decrypt_juniper_type9(encrypted_password: str) -&gt; str:\n    \"\"\"Given an encrypted Junos $9$ type password, decrypt it.\n\n    Args:\n        encrypted_password: A password that has been encrypted, and will be decrypted.\n\n    Returns:\n        The unencrypted_password password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import decrypt_juniper_type9\n        &gt;&gt;&gt; decrypt_juniper_type9(\"$9$7YdwgGDkTz6oJz69A1INdb\")\n        'juniper'\n        &gt;&gt;&gt;\n    \"\"\"\n    # Strip $9$ from start of string\n    password_characters = encrypted_password.split(\"$9$\", 1)[1]\n\n    # Get first character and toss extra characters\n    first_character = password_characters[0]\n    stripped_password_characters = password_characters[JUNIPER_CHARACTER_KEYS[first_character] + 1 :]  # noqa: E203\n\n    previous_char = first_character\n    decrypted_password = \"\"\n    while stripped_password_characters:\n        # Get encoding modulus\n        decode = JUNIPER_ENCODING[len(decrypted_password) % len(JUNIPER_ENCODING)]\n\n        # Get nibble we will decode\n        nibble = stripped_password_characters[0 : len(decode)]  # noqa: E203\n        stripped_password_characters = stripped_password_characters[len(decode) :]  # noqa: E203\n\n        # Decode value for nibble and convert to character, append to decrypted password\n        value = 0\n        for index, char in enumerate(nibble):\n            gap = (\n                (JUNIPER_KEYS_STRING.index(char) - JUNIPER_KEYS_STRING.index(previous_char)) % JUNIPER_KEYS_LENGTH\n            ) - 1\n            value += gap * decode[index]\n            previous_char = char\n        decrypted_password += chr(value)\n\n    return decrypted_password\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.encrypt_cisco_type5","title":"<code>encrypt_cisco_type5(unencrypted_password, salt=None, salt_len=4)</code>","text":"<p>Given an unencrypted password of Cisco Type 5 password, encrypt it.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>salt</code> <code>Optional[str]</code> <p>A random set of characters that can be set by the operator. Defaults to random generated one.</p> <code>None</code> <code>salt_len</code> <code>int</code> <p>The number of random set of characters, when not manually set. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>The encrypted password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import encrypt_cisco_type5\n&gt;&gt;&gt; encrypt_cisco_type5(\"cisco\")\n'$1$MHkb$v2MFmDkQX66TTxLkFF50K/'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>@_fail_on_mac\ndef encrypt_cisco_type5(unencrypted_password: str, salt: t.Optional[str] = None, salt_len: int = 4) -&gt; str:\n    \"\"\"Given an unencrypted password of Cisco Type 5 password, encrypt it.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        salt: A random set of characters that can be set by the operator. Defaults to random generated one.\n        salt_len: The number of random set of characters, when not manually set. Defaults to 4.\n\n    Returns:\n        The encrypted password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import encrypt_cisco_type5\n        &gt;&gt;&gt; encrypt_cisco_type5(\"cisco\")  # doctest: +SKIP\n        '$1$MHkb$v2MFmDkQX66TTxLkFF50K/'\n        &gt;&gt;&gt;\n    \"\"\"\n    if not HAS_CRYPT:\n        raise ImportError(\n            \"Your version of Python does not have crypt support built in. \"\n            \"Please install legacycrypt, such as `pip install legacycrypt` when \"\n            \"adding to your install or `pip install netutils[legacycrypt]` when installing fresh.\"\n        )\n\n    if not salt:\n        salt = \"\".join(secrets.choice(ALPHABET) for _ in range(salt_len))\n    elif not set(salt) &lt;= set(ALPHABET):\n        raise ValueError(f\"type5_pw salt used improper characters, must be one of {ALPHABET}\")\n    return str(crypt.crypt(unencrypted_password, f\"$1${salt}$\"))\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.encrypt_cisco_type7","title":"<code>encrypt_cisco_type7(unencrypted_password, salt=None)</code>","text":"<p>Given an unencrypted password of Cisco Type 7 password, encrypt it.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>salt</code> <code>Optional[int]</code> <p>A random number between 0 and 15 that can be set by the operator. Defaults to random generated one.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The encrypted password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import encrypt_cisco_type7\n&gt;&gt;&gt; encrypt_cisco_type7(\"cisco\", 11)\n'110A1016141D'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def encrypt_cisco_type7(unencrypted_password: str, salt: t.Optional[int] = None) -&gt; str:\n    \"\"\"Given an unencrypted password of Cisco Type 7 password, encrypt it.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        salt: A random number between 0 and 15 that can be set by the operator. Defaults to random generated one.\n\n    Returns:\n        The encrypted password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import encrypt_cisco_type7\n        &gt;&gt;&gt; encrypt_cisco_type7(\"cisco\", 11)\n        '110A1016141D'\n        &gt;&gt;&gt;\n    \"\"\"\n    # max length of password for encrypt t7 is 25\n    if len(unencrypted_password) &gt; ENCRYPT_TYPE7_LENGTH:\n        raise ValueError(\"Password must not exceed 25 characters.\")\n\n    if not salt:\n        salt = random.randint(0, 15)  # noqa: S311\n    # Start building the encrypted password - pre-pend the 2 decimal digit offset.\n    encrypted_password = format(salt, \"02d\")\n    for i, _ in enumerate(unencrypted_password):\n        # Get the next of the plaintext character.\n        dec_char = ord(unencrypted_password[i])  # pylint: disable=unnecessary-list-index-lookup\n        # Get the next character of the key.\n        key_char = ast.literal_eval(XLAT[(i + salt) % 53])\n        # XOR the plaintext character with the key character.\n        enc_char = dec_char ^ key_char\n        # Build the encrypted password one character at a time.\n        # The ASCII code of each encrypted character is added as 2 hex digits.\n        encrypted_password += format(enc_char, \"02X\")\n    return encrypted_password\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.encrypt_cisco_type9","title":"<code>encrypt_cisco_type9(unencrypted_password, salt=None)</code>","text":"<p>Given an unencrypted password of Cisco Type 9 password, encrypt it.</p> <p>Note: This uses the built-in Python <code>scrypt</code> function to generate the password hash. However, this function is not available on the default Python installed on MacOS. If MacOS is used, it is recommended to install Python using Homebrew (or similar) which will include <code>scrypt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>salt</code> <code>Optional[str]</code> <p>a 14-character string that can be set by the operator. Defaults to random generated one.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The encrypted password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import encrypt_cisco_type9\n&gt;&gt;&gt; encrypt_cisco_type9(\"123456\", \"cvWdfQlRRDKq/U\")\n'$9$cvWdfQlRRDKq/U$VFTPha5VHTCbSgSUAo.nPoh50ZiXOw1zmljEjXkaq1g'\n</code></pre> <p>Raises:</p> Type Description <code>ImportError</code> <p>If <code>scrypt</code> cannot be imported from the system.</p> Source code in <code>netutils/password.py</code> <pre><code>def encrypt_cisco_type9(unencrypted_password: str, salt: t.Optional[str] = None) -&gt; str:\n    \"\"\"Given an unencrypted password of Cisco Type 9 password, encrypt it.\n\n    Note: This uses the built-in Python `scrypt` function to generate the password\n    hash. However, this function is not available on the default Python installed\n    on MacOS. If MacOS is used, it is recommended to install Python using Homebrew\n    (or similar) which will include `scrypt`.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        salt: a 14-character string that can be set by the operator. Defaults to random generated one.\n\n    Returns:\n        The encrypted password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import encrypt_cisco_type9\n        &gt;&gt;&gt; encrypt_cisco_type9(\"123456\", \"cvWdfQlRRDKq/U\")\n        '$9$cvWdfQlRRDKq/U$VFTPha5VHTCbSgSUAo.nPoh50ZiXOw1zmljEjXkaq1g'\n\n    Raises:\n        ImportError: If `scrypt` cannot be imported from the system.\n    \"\"\"\n    if not HAS_SCRYPT:\n        raise ImportError(\n            \"Your version of python does not have scrypt support built in. \"\n            \"Please install a version of python with scrypt.\"\n        )\n\n    if salt:\n        if len(salt) != 14:\n            raise ValueError(\"Salt must be 14 characters long.\")\n        salt_bytes = salt.encode()\n    else:\n        # salt must always be a 14-byte-long printable string, often includes symbols\n        salt_bytes = \"\".join(secrets.choice(ENCRYPT_TYPE9_ENCODING_CHARS) for _ in range(14)).encode()\n\n    key = scrypt(unencrypted_password.encode(), salt=salt_bytes, n=2**14, r=1, p=1, dklen=32)\n\n    # Cisco type 9 uses a different base64 encoding than the standard one, so we need to translate from\n    # the standard one to the Cisco one.\n    type9_encoding_translation_table = str.maketrans(\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n        ENCRYPT_TYPE9_ENCODING_CHARS,\n    )\n    hashed_password = base64.b64encode(key).decode().translate(type9_encoding_translation_table)\n\n    # and strip off the trailing '='\n    hashed_password = hashed_password[:-1]\n\n    return f\"$9${salt_bytes.decode()}${hashed_password}\"\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.encrypt_juniper_type9","title":"<code>encrypt_juniper_type9(unencrypted_password, salt=None)</code>","text":"<p>Given an unencrypted password, encrypt to Juniper $9$ type password.</p> <p>Parameters:</p> Name Type Description Default <code>unencrypted_password</code> <code>str</code> <p>A password that has not been encrypted, and will be compared against.</p> required <code>salt</code> <code>Optional[int]</code> <p>A integer that can be set by the operator. Defaults to random generated one.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The encrypted password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import encrypt_juniper_type9\n&gt;&gt;&gt; encrypt_juniper_type9(\"juniper\", 35)\n'$9$7YdwgGDkTz6oJz69A1INdb'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def encrypt_juniper_type9(unencrypted_password: str, salt: t.Optional[int] = None) -&gt; str:\n    \"\"\"Given an unencrypted password, encrypt to Juniper $9$ type password.\n\n    Args:\n        unencrypted_password: A password that has not been encrypted, and will be compared against.\n        salt: A integer that can be set by the operator. Defaults to random generated one.\n\n    Returns:\n        The encrypted password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import encrypt_juniper_type9\n        &gt;&gt;&gt; encrypt_juniper_type9(\"juniper\", 35) # doctest: +SKIP\n        '$9$7YdwgGDkTz6oJz69A1INdb'\n        &gt;&gt;&gt;\n    \"\"\"\n    if not salt:\n        salt = random.randint(0, JUNIPER_KEYS_LENGTH) - 1  # noqa: S311\n\n    # Use salt to generate start of encrypted password\n    first_character = JUNIPER_KEYS_STRING[salt]\n    random_chars = \"\".join(\n        [\n            JUNIPER_KEYS_STRING[random.randint(0, JUNIPER_KEYS_LENGTH) - 1]  # noqa: S311\n            for x in range(0, JUNIPER_CHARACTER_KEYS[first_character])\n        ]\n    )\n    encrypted_password = \"$9$\" + first_character + random_chars\n\n    previous_character = first_character\n    for index, char in enumerate(unencrypted_password):\n        encode = JUNIPER_ENCODING[index % len(JUNIPER_ENCODING)][::-1]  # Get encoding modulus in reverse order\n        char_ord = ord(char)\n        gaps: t.List[int] = []\n        for modulus in encode:\n            gaps = [int(char_ord / modulus)] + gaps\n            char_ord %= modulus\n\n        for gap in gaps:\n            gap += JUNIPER_KEYS_STRING.index(previous_character) + 1\n            new_character = JUNIPER_KEYS_STRING[gap % JUNIPER_KEYS_LENGTH]\n            previous_character = new_character\n            encrypted_password += new_character\n\n    return encrypted_password\n</code></pre>"},{"location":"dev/code_reference/password.html#netutils.password.get_hash_salt","title":"<code>get_hash_salt(encrypted_password)</code>","text":"<p>Given an encrypted password obtain the salt value from it.</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_password</code> <code>str</code> <p>A password that has been encrypted, which the salt will be taken from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The encrypted password.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.password import get_hash_salt\n&gt;&gt;&gt; get_hash_salt('$1$ZLGo$J.gAGxS2wqO96drs0Cith/')\n'ZLGo'\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/password.py</code> <pre><code>def get_hash_salt(encrypted_password: str) -&gt; str:\n    \"\"\"Given an encrypted password obtain the salt value from it.\n\n    Args:\n        encrypted_password: A password that has been encrypted, which the salt will be taken from.\n\n    Returns:\n        The encrypted password.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.password import get_hash_salt\n        &gt;&gt;&gt; get_hash_salt('$1$ZLGo$J.gAGxS2wqO96drs0Cith/')\n        'ZLGo'\n        &gt;&gt;&gt;\n    \"\"\"\n    split_password = encrypted_password.split(\"$\")\n    if len(split_password) != 4:\n        raise ValueError(f\"Could not parse salt out password correctly from {encrypted_password}\")\n    return split_password[2]\n</code></pre>"},{"location":"dev/code_reference/ping.html","title":"Ping","text":""},{"location":"dev/code_reference/ping.html#netutils.ping","title":"<code>netutils.ping</code>","text":"<p>Functions to create a ping via pure Python.</p>"},{"location":"dev/code_reference/ping.html#netutils.ping.tcp_ping","title":"<code>tcp_ping(ip, port, timeout=1)</code>","text":"<p>Verifies whether a TCP port is open on a given IP address.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>An IP address in string format that is able to be converted by <code>ipaddress</code> library.</p> required <code>port</code> <code>int</code> <p>A valid TCP port.</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds before returning a False. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>bool</code> <p>The result as to whether or not you were able ping the IP address.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.ping import tcp_ping\n&gt;&gt;&gt; tcp_ping(\"1.1.1.1\", 443)\nTrue\n&gt;&gt;&gt; tcp_ping(\"1.0.100.0\", 27)\nFalse\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/ping.py</code> <pre><code>def tcp_ping(ip: str, port: int, timeout: int = 1) -&gt; bool:  # pylint: disable=invalid-name\n    \"\"\"Verifies whether a TCP port is open on a given IP address.\n\n    Args:\n        ip: An IP address in string format that is able to be converted by `ipaddress` library.\n        port: A valid TCP port.\n        timeout: The timeout in seconds before returning a False. Defaults to 1.\n\n    Returns:\n        The result as to whether or not you were able ping the IP address.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.ping import tcp_ping\n        &gt;&gt;&gt; tcp_ping(\"1.1.1.1\", 443)  # doctest: +SKIP\n        True\n        &gt;&gt;&gt; tcp_ping(\"1.0.100.0\", 27)  # doctest: +SKIP\n        False\n        &gt;&gt;&gt;\n    \"\"\"\n    sckt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sckt.settimeout(int(timeout))\n    try:\n        sckt.connect((ip, int(port)))  # pylint: disable=invalid-name\n        sckt.shutdown(socket.SHUT_RDWR)\n        return True\n    # We really only want to know if the TCP connection timed out.\n    # If anything else has happened the error should be raised.\n    except socket.timeout:\n        return False\n    finally:\n        sckt.close()\n</code></pre>"},{"location":"dev/code_reference/protocol_mapper.html","title":"Protocol Mapper","text":"<p>Review how to use code within the user documentation</p>"},{"location":"dev/code_reference/protocol_mapper.html#netutils.protocol_mapper","title":"<code>netutils.protocol_mapper</code>","text":"<p>Protocol Mappers.</p>"},{"location":"dev/code_reference/regex.html","title":"Regex","text":""},{"location":"dev/code_reference/regex.html#netutils.regex","title":"<code>netutils.regex</code>","text":"<p>Utilities to expose regex functions, primarily for Jinja2 filters.</p>"},{"location":"dev/code_reference/regex.html#netutils.regex.regex_findall","title":"<code>regex_findall(pattern, string)</code>","text":"<p>Given a regex pattern and string, return all non-overlapping matches of pattern in the string, as a list of strings.</p> <p>The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around <code>re.findall</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex string to match against.</p> required <code>string</code> <code>str</code> <p>String to check against.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of matches, when there is no match the list will be empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.regex import regex_findall\n&gt;&gt;&gt; match = regex_findall(\"\\w\\w\\w-RT\\d\\d\", \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\")\n&gt;&gt;&gt; len(match)\n3\n&gt;&gt;&gt; match[0]\n'NYC-RT01'\n</code></pre> Source code in <code>netutils/regex.py</code> <pre><code>def regex_findall(pattern: str, string: str) -&gt; t.List[str]:\n    r\"\"\"Given a regex pattern and string, return all non-overlapping matches of pattern in the string, as a list of strings.\n\n    The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around `re.findall`.\n\n    Args:\n        pattern: Regex string to match against.\n        string: String to check against.\n\n    Returns:\n        List of matches, when there is no match the list will be empty.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.regex import regex_findall\n        &gt;&gt;&gt; match = regex_findall(\"\\w\\w\\w-RT\\d\\d\", \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\")\n        &gt;&gt;&gt; len(match)\n        3\n        &gt;&gt;&gt; match[0]\n        'NYC-RT01'\n\n    \"\"\"\n    return re.findall(pattern, string)\n</code></pre>"},{"location":"dev/code_reference/regex.html#netutils.regex.regex_match","title":"<code>regex_match(pattern, string)</code>","text":"<p>Given a regex pattern and string, return <code>None</code> if there is no matching <code>re.Match.groups()</code> if using capture groups or regex match via <code>re.Match.group()</code> on start of string.</p> <p>This is useful in the following use cases:</p> <ol> <li>Truthy conditional check that a string matches a given regex.</li> <li>Returning regex capture groups from the string.</li> <li>Matching for the start of a string, see <code>regex_search</code> when you do not want only start of string matching.</li> </ol> <p>The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around <code>re.match</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex string to match against.</p> required <code>string</code> <code>str</code> <p>String to check against.</p> required <p>Returns:</p> Type Description <code>Union[List[str], str, None]</code> <p>List of matches, match, or None no match found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.regex import regex_match\n&gt;&gt;&gt; print(\"South Carolina\" if regex_match(\".+SC.+\\d\\d\", \"USSCAMS07\") else \"Not South Carolina\")\nSouth Carolina\n&gt;&gt;&gt;\n&gt;&gt;&gt; match = regex_match(\"([A-Z]{2})([A-Z]{2})([A-Z]{3})(\\d*)\", \"USSCAMS07\")\n&gt;&gt;&gt; match[0]\n'US'\n&gt;&gt;&gt; match[1]\n'SC'\n&gt;&gt;&gt; match[2]\n'AMS'\n&gt;&gt;&gt; match[3]\n'07'\n</code></pre> Source code in <code>netutils/regex.py</code> <pre><code>def regex_match(pattern: str, string: str) -&gt; t.Union[t.List[str], str, None]:\n    r\"\"\"Given a regex pattern and string, return `None` if there is no matching `re.Match.groups()` if using capture groups or regex match via `re.Match.group()` on start of string.\n\n    This is useful in the following use cases:\n\n    1. Truthy conditional check that a string matches a given regex.\n    2. Returning regex capture groups from the string.\n    3. Matching for the start of a string, see `regex_search` when you do not want only start of string matching.\n\n    The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around `re.match`.\n\n    Args:\n        pattern: Regex string to match against.\n        string: String to check against.\n\n    Returns:\n        List of matches, match, or None no match found\n\n    Examples:\n        &gt;&gt;&gt; from netutils.regex import regex_match\n        &gt;&gt;&gt; print(\"South Carolina\" if regex_match(\".+SC.+\\d\\d\", \"USSCAMS07\") else \"Not South Carolina\")\n        South Carolina\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; match = regex_match(\"([A-Z]{2})([A-Z]{2})([A-Z]{3})(\\d*)\", \"USSCAMS07\")\n        &gt;&gt;&gt; match[0]\n        'US'\n        &gt;&gt;&gt; match[1]\n        'SC'\n        &gt;&gt;&gt; match[2]\n        'AMS'\n        &gt;&gt;&gt; match[3]\n        '07'\n\n    \"\"\"\n    return _match_object(re.match(pattern, string))\n</code></pre>"},{"location":"dev/code_reference/regex.html#netutils.regex.regex_search","title":"<code>regex_search(pattern, string)</code>","text":"<p>Given a regex pattern and string, return <code>None</code> if there is no matching <code>re.Match.groups()</code> if using capture groups or regex match via <code>re.Match.group()</code>.</p> <p>The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around <code>re.search</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex string to match against.</p> required <code>string</code> <code>str</code> <p>String to check against.</p> required <p>Returns:</p> Type Description <code>Union[List[str], str, None]</code> <p>List of matches, match, or None no match found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.regex import regex_search\n&gt;&gt;&gt; print(\"South Carolina\" if regex_search(\".+SC.+\\d\\d\", \"USSCAMS07\") else \"Not South Carolina\")\nSouth Carolina\n&gt;&gt;&gt;\n&gt;&gt;&gt; match = regex_search(\"^([A-Z]{2})([A-Z]{2})([A-Z]{3})(\\d*)\", \"USSCAMS07\")\n&gt;&gt;&gt; match[0]\n'US'\n&gt;&gt;&gt; match[1]\n'SC'\n&gt;&gt;&gt; match[2]\n'AMS'\n&gt;&gt;&gt; match[3]\n'07'\n</code></pre> Source code in <code>netutils/regex.py</code> <pre><code>def regex_search(pattern: str, string: str) -&gt; t.Union[t.List[str], str, None]:\n    r\"\"\"Given a regex pattern and string, return `None` if there is no matching `re.Match.groups()` if using capture groups or regex match via `re.Match.group()`.\n\n    The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around `re.search`.\n\n    Args:\n        pattern: Regex string to match against.\n        string: String to check against.\n\n    Returns:\n        List of matches, match, or None no match found.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.regex import regex_search\n        &gt;&gt;&gt; print(\"South Carolina\" if regex_search(\".+SC.+\\d\\d\", \"USSCAMS07\") else \"Not South Carolina\")\n        South Carolina\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; match = regex_search(\"^([A-Z]{2})([A-Z]{2})([A-Z]{3})(\\d*)\", \"USSCAMS07\")\n        &gt;&gt;&gt; match[0]\n        'US'\n        &gt;&gt;&gt; match[1]\n        'SC'\n        &gt;&gt;&gt; match[2]\n        'AMS'\n        &gt;&gt;&gt; match[3]\n        '07'\n\n    \"\"\"\n    return _match_object(re.search(pattern, string))\n</code></pre>"},{"location":"dev/code_reference/regex.html#netutils.regex.regex_split","title":"<code>regex_split(pattern, string, maxsplit=0)</code>","text":"<p>Given a regex pattern and string, return the split the object based on the pattern a single element or single element of original value if there is no match.</p> <p>The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around <code>re.split</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex string to match against.</p> required <code>string</code> <code>str</code> <p>String to check against.</p> required <code>maxsplit</code> <code>int</code> <p>The maximum time to split.</p> <code>0</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of string of the match or single element list of original value if no match</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.regex import regex_split\n&gt;&gt;&gt; match = regex_split(\",\", \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\")\n&gt;&gt;&gt; match[0]\n'NYC-RT01'\n&gt;&gt;&gt; match[3]\n'SFO-RT01'\n</code></pre> Source code in <code>netutils/regex.py</code> <pre><code>def regex_split(pattern: str, string: str, maxsplit: int = 0) -&gt; t.List[str]:\n    \"\"\"Given a regex pattern and string, return the split the object based on the pattern a single element or single element of original value if there is no match.\n\n    The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around `re.split`.\n\n    Args:\n        pattern: Regex string to match against.\n        string: String to check against.\n        maxsplit: The maximum time to split.\n\n    Returns:\n        List of string of the match or single element list of original value if no match\n\n    Examples:\n        &gt;&gt;&gt; from netutils.regex import regex_split\n        &gt;&gt;&gt; match = regex_split(\",\", \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\")\n        &gt;&gt;&gt; match[0]\n        'NYC-RT01'\n        &gt;&gt;&gt; match[3]\n        'SFO-RT01'\n    \"\"\"\n    return re.split(pattern, string, maxsplit)\n</code></pre>"},{"location":"dev/code_reference/regex.html#netutils.regex.regex_sub","title":"<code>regex_sub(pattern, repl, string, count=0)</code>","text":"<p>Given a regex pattern, replacement, and string replace the pattern within the string and return.</p> <p>The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around <code>re.sub</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex string to match against.</p> required <code>repl</code> <code>str</code> <p>Replacement characters that were matched in the pattern.</p> required <code>string</code> <code>str</code> <p>String to check against.</p> required <code>count</code> <code>int</code> <p>The maximum time to replace.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>List of string of the match or single element list of original value if no match</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.regex import regex_sub\n&gt;&gt;&gt; match = regex_sub(\",\", \" \", \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\")\n&gt;&gt;&gt; match\n'NYC-RT01 NYC-RT02 SFO-SW01 SFO-RT01'\n&gt;&gt;&gt; match = regex_sub(\"(ROUTER|RTR)\", \"RT\", \"NYC-ROUTER01,NYC-ROUTER02,NYC-RTR03\")\n&gt;&gt;&gt; match\n'NYC-RT01,NYC-RT02,NYC-RT03'\n</code></pre> Source code in <code>netutils/regex.py</code> <pre><code>def regex_sub(pattern: str, repl: str, string: str, count: int = 0) -&gt; str:\n    \"\"\"Given a regex pattern, replacement, and string replace the pattern within the string and return.\n\n    The main purpose of this function is provide a Jinja2 filter as this is simply a wrapper around `re.sub`.\n\n    Args:\n        pattern: Regex string to match against.\n        repl: Replacement characters that were matched in the pattern.\n        string: String to check against.\n        count: The maximum time to replace.\n\n    Returns:\n        List of string of the match or single element list of original value if no match\n\n    Examples:\n        &gt;&gt;&gt; from netutils.regex import regex_sub\n        &gt;&gt;&gt; match = regex_sub(\",\", \" \", \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\")\n        &gt;&gt;&gt; match\n        'NYC-RT01 NYC-RT02 SFO-SW01 SFO-RT01'\n        &gt;&gt;&gt; match = regex_sub(\"(ROUTER|RTR)\", \"RT\", \"NYC-ROUTER01,NYC-ROUTER02,NYC-RTR03\")\n        &gt;&gt;&gt; match\n        'NYC-RT01,NYC-RT02,NYC-RT03'\n    \"\"\"\n    return re.sub(pattern, repl, string, count)\n</code></pre>"},{"location":"dev/code_reference/route.html","title":"Route","text":""},{"location":"dev/code_reference/route.html#netutils.route","title":"<code>netutils.route</code>","text":"<p>Utilities to get best route from routing table.</p>"},{"location":"dev/code_reference/route.html#netutils.route.NoRouteFound","title":"<code>NoRouteFound</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Custom Exception for No Route Found.</p> Source code in <code>netutils/route.py</code> <pre><code>class NoRouteFound(BaseException):\n    \"\"\"Custom Exception for No Route Found.\"\"\"\n</code></pre>"},{"location":"dev/code_reference/route.html#netutils.route.longest_prefix_match","title":"<code>longest_prefix_match(ip_addr, routes)</code>","text":"<p>From a list of networks and an IP address, find the most specific route.</p> <p>Parameters:</p> Name Type Description Default <code>ip_addr</code> <code>str</code> <p>String representation of an IP address.</p> required <code>routes</code> <code>List[Dict[str, str]]</code> <p>list of dictionaries with network and mask as keys. Subnet can also be CIDR(number) notation.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Longest Match Route</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.route import longest_prefix_match\n&gt;&gt;&gt; lookup = \"10.1.1.245\"\n&gt;&gt;&gt; routes = [{\"network\": \"192.168.1.1\", \"mask\": \"255.255.255.255\"},{\"network\": \"10.1.1.0\", \"mask\": \"24\"}]\n&gt;&gt;&gt; longest_prefix_match(lookup, routes)\n'10.1.1.0/24'\n</code></pre> Source code in <code>netutils/route.py</code> <pre><code>def longest_prefix_match(ip_addr: str, routes: t.List[t.Dict[str, str]]) -&gt; str:\n    \"\"\"From a list of networks and an IP address, find the most specific route.\n\n    Args:\n        ip_addr: String representation of an IP address.\n        routes: list of dictionaries with network and mask as keys. Subnet can also be CIDR(number) notation.\n\n    Returns:\n        Longest Match Route\n\n    Examples:\n        &gt;&gt;&gt; from netutils.route import longest_prefix_match\n        &gt;&gt;&gt; lookup = \"10.1.1.245\"\n        &gt;&gt;&gt; routes = [{\"network\": \"192.168.1.1\", \"mask\": \"255.255.255.255\"},{\"network\": \"10.1.1.0\", \"mask\": \"24\"}]\n        &gt;&gt;&gt; longest_prefix_match(lookup, routes)\n        '10.1.1.0/24'\n    \"\"\"\n    if not isinstance(routes, list):\n        raise TypeError(f\"'routing_table' should be a list, got {type(routes)}\")\n    if not len(routes) &gt; 0:\n        raise IndexError(f\"'routing_table' should have more than zero indexes. Got {len(routes)}\")\n    if isinstance(ip_addr, str):\n        ip_addr = ipaddress.ip_address(ip_addr)  # type: ignore\n    else:\n        if not isinstance(ip_addr, (ipaddress.IPv4Address, ipaddress.IPv6Address)):\n            raise TypeError(f\"'ip_addr' should be a str, got {type(ip_addr)}\")\n\n    networks = [\n        ipaddress.IPv4Network(f\"{route['network']}/{route['mask']}\")\n        for route in routes\n        if ip_addr in ipaddress.IPv4Network(f\"{route['network']}/{route['mask']}\")\n    ]\n    try:\n        return str(sorted(networks)[-1])\n    except IndexError as error:\n        raise NoRouteFound(\"No Matching Route Found.\") from error\n</code></pre>"},{"location":"dev/code_reference/time.html","title":"Time","text":""},{"location":"dev/code_reference/time.html#netutils.time","title":"<code>netutils.time</code>","text":"<p>Functions for working with time.</p>"},{"location":"dev/code_reference/time.html#netutils.time.uptime_seconds_to_string","title":"<code>uptime_seconds_to_string(uptime_seconds)</code>","text":"<p>Converts uptime in seconds to uptime in string format.</p> <p>Parameters:</p> Name Type Description Default <code>uptime_seconds</code> <code>int</code> <p>Uptime in seconds.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Uptime in string format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.time import uptime_seconds_to_string\n&gt;&gt;&gt; uptime_seconds_to_string(7250)\n'2 hours, 50 seconds'\n</code></pre> Source code in <code>netutils/time.py</code> <pre><code>def uptime_seconds_to_string(uptime_seconds: int) -&gt; str:\n    \"\"\"Converts uptime in seconds to uptime in string format.\n\n    Args:\n        uptime_seconds: Uptime in seconds.\n\n    Returns:\n        Uptime in string format.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.time import uptime_seconds_to_string\n        &gt;&gt;&gt; uptime_seconds_to_string(7250)\n        '2 hours, 50 seconds'\n    \"\"\"\n    result = []\n    for interval, count in TIME_MAPPINGS:\n        value = uptime_seconds // count\n        if value:\n            uptime_seconds -= value * count\n            if value == 1:\n                interval = interval.rstrip(\"s\")\n            result.append(f\"{value} {interval}\")\n\n    return \", \".join(result)\n</code></pre>"},{"location":"dev/code_reference/time.html#netutils.time.uptime_string_to_seconds","title":"<code>uptime_string_to_seconds(uptime_string)</code>","text":"<p>Converts uptime string seconds.</p> <p>Parameters:</p> Name Type Description Default <code>uptime_string</code> <code>str</code> <p>Uptime in string format</p> required <p>Returns:</p> Type Description <code>int</code> <p>Uptime string converted to seconds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.time import uptime_string_to_seconds\n&gt;&gt;&gt; uptime_string_to_seconds(\"58 minutes\")\n3480\n&gt;&gt;&gt; from netutils.time import uptime_string_to_seconds\n&gt;&gt;&gt; uptime_string_to_seconds(\"4m15s\")\n255\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>When uptime_string is unable to be parsed by regex.</p> Source code in <code>netutils/time.py</code> <pre><code>def uptime_string_to_seconds(uptime_string: str) -&gt; int:\n    \"\"\"Converts uptime string seconds.\n\n    Args:\n        uptime_string: Uptime in string format\n\n    Returns:\n        Uptime string converted to seconds.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.time import uptime_string_to_seconds\n        &gt;&gt;&gt; uptime_string_to_seconds(\"58 minutes\")\n        3480\n        &gt;&gt;&gt; from netutils.time import uptime_string_to_seconds\n        &gt;&gt;&gt; uptime_string_to_seconds(\"4m15s\")\n        255\n\n    Raises:\n        ValueError: When uptime_string is unable to be parsed by regex.\n    \"\"\"\n    compiled_regex_list = [re.compile(reg_pattern) for reg_pattern in UPTIME_REGEX_PATTERNS]\n\n    uptime_dict: t.Dict[str, str] = {}\n    for regex in compiled_regex_list:\n        match = regex.search(uptime_string)\n\n        if match:\n            uptime_dict = match.groupdict()\n            break\n\n    if not match:\n        raise ValueError(\"Unable to parse uptime string.\")\n\n    uptime_seconds = 0\n    for time_interval, value in TIME_MAPPINGS:\n        time_interval_as_int = uptime_dict.get(time_interval)\n        if time_interval_as_int:\n            uptime_seconds += int(time_interval_as_int) * value\n    return uptime_seconds\n</code></pre>"},{"location":"dev/code_reference/utils.html","title":"Protocol Mapper","text":"<p>Review how to use code within the user documentation</p>"},{"location":"dev/code_reference/utils.html#netutils.utils","title":"<code>netutils.utils</code>","text":"<p>Utilities for the netutils library.</p>"},{"location":"dev/code_reference/utils.html#netutils.utils.jinja2_convenience_function","title":"<code>jinja2_convenience_function()</code>","text":"<p>Convenience function that allows netutils filter to be used easily with jinja2.</p> <p>Returns:</p> Type Description <code>Dict[str, Callable[..., Any]]</code> <p>Keys are the function names for the Jinja2 filter and values are the function objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.utils import jinja2_convenience_function\n&gt;&gt;&gt; function_mappings = jinja2_convenience_function()\n&gt;&gt;&gt; function_mappings[\"get_first_usable\"](\"192.168.0.0/24\")\n'192.168.0.1'\n&gt;&gt;&gt; function_mappings[\"get_broadcast_address\"](\"192.168.0.0/24\")\n'192.168.0.255'\n</code></pre> Source code in <code>netutils/utils.py</code> <pre><code>def jinja2_convenience_function() -&gt; t.Dict[str, t.Callable[..., t.Any]]:\n    \"\"\"Convenience function that allows netutils filter to be used easily with jinja2.\n\n    Returns:\n        Keys are the function names for the Jinja2 filter and values are the function objects.\n\n    Examples:\n        &gt;&gt;&gt; from netutils.utils import jinja2_convenience_function\n        &gt;&gt;&gt; function_mappings = jinja2_convenience_function()\n        &gt;&gt;&gt; function_mappings[\"get_first_usable\"](\"192.168.0.0/24\")\n        '192.168.0.1'\n        &gt;&gt;&gt; function_mappings[\"get_broadcast_address\"](\"192.168.0.0/24\")\n        '192.168.0.255'\n    \"\"\"\n    result = {}\n\n    for jinja2_function_name, function_import_path in _JINJA2_FUNCTION_MAPPINGS.items():\n        module, function_name = function_import_path.rsplit(\".\", 1)\n        imported_module = import_module(f\"netutils.{module}\")\n        function_object = getattr(imported_module, function_name)\n        result[jinja2_function_name] = function_object\n    return result\n</code></pre>"},{"location":"dev/code_reference/vlan.html","title":"VLAN","text":""},{"location":"dev/code_reference/vlan.html#netutils.vlan","title":"<code>netutils.vlan</code>","text":"<p>Functions for working with VLANs.</p>"},{"location":"dev/code_reference/vlan.html#netutils.vlan.vlanconfig_to_list","title":"<code>vlanconfig_to_list(vlan_config)</code>","text":"<p>Given an IOS-like vlan list of configurations, return the list of VLANs.</p> <p>Parameters:</p> Name Type Description Default <code>vlan_config</code> <code>str</code> <p>IOS-like vlan list of configurations.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>Sorted string list of integers according to IOS-like vlan list rules</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vlan_config = '''switchport trunk allowed vlan 1025,1069-1072,1114,1173-1181,1501,1502'''\n&gt;&gt;&gt; vlanconfig_to_list(vlan_config)\n[1025, 1069, 1070, 1071, 1072, 1114, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1501, 1502]\n&gt;&gt;&gt;\n</code></pre> Source code in <code>netutils/vlan.py</code> <pre><code>def vlanconfig_to_list(vlan_config: str) -&gt; t.List[int]:\n    \"\"\"Given an IOS-like vlan list of configurations, return the list of VLANs.\n\n    Args:\n        vlan_config: IOS-like vlan list of configurations.\n\n    Returns:\n        Sorted string list of integers according to IOS-like vlan list rules\n\n    Examples:\n        &gt;&gt;&gt; vlan_config = '''switchport trunk allowed vlan 1025,1069-1072,1114,1173-1181,1501,1502'''\n        &gt;&gt;&gt; vlanconfig_to_list(vlan_config)\n        [1025, 1069, 1070, 1071, 1072, 1114, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1501, 1502]\n        &gt;&gt;&gt;\n    \"\"\"\n    # Check for invalid data within the vlan_config\n    # example: switchport trunk allowed vlan 1025,1069-1072,BADDATA\n    invalid_data = re.findall(r\",?[^0-9\\-],?$\", vlan_config)\n    # Regular VLANs that are not condensed and can be converted to integers\n    vlans = list(map(int, re.findall(r\"\\d+\", vlan_config)))\n\n    # Fail if invalid data is found\n    if invalid_data and vlans:\n        raise ValueError(f\"There were non-digits and dashes found in `{vlan_config}`.\")\n    if invalid_data:\n        raise ValueError(f\"No digits found in `{vlan_config}`\")\n\n    vlan_ranges = re.findall(r\"\\d+-\\d+\", vlan_config)\n    for v_range in vlan_ranges:\n        first, second = v_range.split(\"-\")\n        # Add one to first to prevent duplicates that already exist within vlans\n        vlans.extend(list(range(*[int(first) + 1, int(second)])))\n\n    vlans = sorted(vlans)\n    if vlans[-1] &gt; 4094:\n        raise ValueError(f\"Valid VLAN range is 1-4094, found {vlans[-1]}\")\n    return vlans\n</code></pre>"},{"location":"dev/code_reference/vlan.html#netutils.vlan.vlanlist_to_config","title":"<code>vlanlist_to_config(vlan_list, first_line_len=48, other_line_len=44, min_grouping_size=3, return_empty=False)</code>","text":"<p>Given a List of VLANs, build the IOS-like vlan list of configurations.</p> <p>Parameters:</p> Name Type Description Default <code>vlan_list</code> <code>List[int]</code> <p>Unsorted list of vlan integers.</p> required <code>first_line_len</code> <code>int</code> <p>The maximum length of the line of the first element of within the return list. Defaults to 48.</p> <code>48</code> <code>other_line_len</code> <code>int</code> <p>The maximum length of the line of all other elements of within the return list. Defaults to 44.</p> <code>44</code> <code>min_grouping_size</code> <code>int</code> <p>The minimum consecutive VLANs to aggregate with a hyphen. Defaults to Cisco's minimum grouping size of 3.</p> <code>3</code> <code>return_empty</code> <code>bool</code> <p>Whether or not to return an empty list instead of an <code>ValueError</code> when vlan_list is empty. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>Sorted string list of integers according to IOS-like vlan list rules</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from netutils.vlan import vlanlist_to_config\n&gt;&gt;&gt; vlanlist_to_config([1, 2, 3, 5, 6, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018])\n['1-3,5,6,1000,1002,1004,1006,1008,1010,1012,1014', '1016,1018']\n&gt;&gt;&gt; vlanlist_to_config([1,3,5,6,100,101,102,103,104,105,107,109], min_grouping_size=2)\n['1,3,5-6,100-105,107,109']\n&gt;&gt;&gt; vlanlist_to_config([1,3,5,6,100,101,102,103,104,105,107,109], min_grouping_size=1)\n['1,3,5,6,100,101,102,103,104,105,107,109']\n&gt;&gt;&gt; vlan_list = [1, 2, 3, 5, 6, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018]\n&gt;&gt;&gt; for index, vlan in enumerate(vlanlist_to_config(vlan_list)):\n...     if index == 0:\n...         print(f\"switchport trunk allowed vlan {vlan}\")\n...     else:\n...         print(f\"switchport trunk allowed vlan add {vlan}\")\n...\nswitchport trunk allowed vlan 1-3,5,6,1000,1002,1004,1006,1008,1010,1012,1014\nswitchport trunk allowed vlan add 1016,1018\n</code></pre> Source code in <code>netutils/vlan.py</code> <pre><code>def vlanlist_to_config(\n    vlan_list: t.List[int],\n    first_line_len: int = 48,\n    other_line_len: int = 44,\n    min_grouping_size: int = 3,\n    return_empty: bool = False,\n) -&gt; t.List[str]:\n    \"\"\"Given a List of VLANs, build the IOS-like vlan list of configurations.\n\n    Args:\n        vlan_list: Unsorted list of vlan integers.\n        first_line_len: The maximum length of the line of the first element of within the return list. Defaults to 48.\n        other_line_len: The maximum length of the line of all other elements of within the return list. Defaults to 44.\n        min_grouping_size: The minimum consecutive VLANs to aggregate with a hyphen. Defaults to Cisco's minimum grouping size of 3.\n        return_empty: Whether or not to return an empty list instead of an `ValueError` when vlan_list is empty. Defaults to False.\n\n    Returns:\n        Sorted string list of integers according to IOS-like vlan list rules\n\n    Examples:\n        &gt;&gt;&gt; from netutils.vlan import vlanlist_to_config\n        &gt;&gt;&gt; vlanlist_to_config([1, 2, 3, 5, 6, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018])\n        ['1-3,5,6,1000,1002,1004,1006,1008,1010,1012,1014', '1016,1018']\n        &gt;&gt;&gt; vlanlist_to_config([1,3,5,6,100,101,102,103,104,105,107,109], min_grouping_size=2)\n        ['1,3,5-6,100-105,107,109']\n        &gt;&gt;&gt; vlanlist_to_config([1,3,5,6,100,101,102,103,104,105,107,109], min_grouping_size=1)\n        ['1,3,5,6,100,101,102,103,104,105,107,109']\n        &gt;&gt;&gt; vlan_list = [1, 2, 3, 5, 6, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018]\n        &gt;&gt;&gt; for index, vlan in enumerate(vlanlist_to_config(vlan_list)):\n        ...     if index == 0:\n        ...         print(f\"switchport trunk allowed vlan {vlan}\")\n        ...     else:\n        ...         print(f\"switchport trunk allowed vlan add {vlan}\")\n        ...\n        switchport trunk allowed vlan 1-3,5,6,1000,1002,1004,1006,1008,1010,1012,1014\n        switchport trunk allowed vlan add 1016,1018\n    \"\"\"\n\n    def build_final_vlan_cfg(vlan_cfg: str) -&gt; t.List[str]:\n        if len(vlan_cfg) &lt;= first_line_len:\n            return [vlan_cfg]\n\n        # Split VLAN config if lines are too long\n        first_line = re.match(f\"^.{{0,{first_line_len}}}(?=,)\", vlan_cfg)\n        if not first_line:\n            raise ValueError(\n                f\"Line with comma seperated vlans is expected.(E.g. 1-3,5,6,1000,1002) Received {vlan_cfg}\"\n            )\n        vlan_cfg_lines = [first_line.group(0)]\n        next_lines = re.compile(f\"(?&lt;=,).{{0,{other_line_len}}}(?=,|$)\")\n        for line in next_lines.findall(vlan_cfg, first_line.end()):\n            vlan_cfg_lines.append(line)\n        return vlan_cfg_lines\n\n    if len(vlan_list) == 0 and return_empty:\n        return []\n\n    if len(vlan_list) == 0:\n        raise ValueError(\"The `vlan_list` argument provided is empty, a list of vlans is required, e.g. [10,20,30].\")\n\n    # Fail if min_grouping_size is less than 1.\n    if min_grouping_size &lt; 1:\n        raise ValueError(\"Minimum grouping size must be equal to or greater than one.\")\n\n    # Sort and de-dup VLAN list\n    vlan_list = sorted(set(vlan_list))\n\n    # If grouping size is zero, sort, and return the config list as no other processing is required.\n    if min_grouping_size == 1:\n        return build_final_vlan_cfg(\",\".join([str(vlan) for vlan in vlan_list]))\n\n    # Group consecutive VLANs\n    vlan_groups = []\n    for _, vlan in groupby(enumerate(vlan_list), lambda vlan: vlan[0] - vlan[1]):\n        vlan_groups.append(list(map(itemgetter(1), vlan)))\n\n    # Check for invalid VLAN IDs\n    if vlan_list[0] &lt; 1 or vlan_list[-1] &gt; 4094:\n        raise ValueError(\"Valid VLAN range is 1-4094\")\n\n    # Create VLAN portion of config\n    vlan_strings = []\n    for group in vlan_groups:\n        group_length = len(group)\n        group_string = f\"{group[0]}\"\n        # Compress based on grouping_size\n        if group_length &gt;= min_grouping_size:\n            group_string += f\"-{group[-1]}\"\n        # If it does not match grouping_size, and is greater than one\n        elif group_length != 1:\n            group_string += f\",{group[1]}\"\n        vlan_strings.append(group_string)\n\n    return build_final_vlan_cfg(\",\".join(vlan_strings))\n</code></pre>"},{"location":"user/faq.html","title":"Frequently Asked Questions","text":""},{"location":"user/faq.html#which-os-config-types-have-parsers","title":"Which OS Config types have Parsers?","text":"<p>The documentation is provided in the development docs</p> <p>For creating new Parsers, see the new parsers docs.</p>"},{"location":"user/faq.html#can-you-provide-an-example-of-how-to-use-the-functions","title":"Can you provide an example of how to use the functions?","text":"<p>The documentation is always provided in the function for code docs for each function. There is additional documentation in Use Cases and subsequent sections.</p>"},{"location":"user/faq.html#optional-dependencies","title":"Optional Dependencies","text":"<p>One of the requirements of this library is to avoid having dependencies; however, including a few optional dependencies in an opt in fashion allows <code>netutils</code> to remain lean while offering some powerful addons.</p> <p>Installing the optional dependencies is only needed when the user needs access to the functions using the dependencies. If the dependency is not installed the function simply raises an exception and warns the user that the library is not installed.</p>"},{"location":"user/include_jinja_list.html","title":"Include jinja list","text":"Filter name Function asn_to_int netutils.asn.asn_to_int int_to_asdot netutils.asn.int_to_asdot bits_to_name netutils.bandwidth.bits_to_name bytes_to_name netutils.bandwidth.bytes_to_name name_to_bits netutils.bandwidth.name_to_bits name_to_bytes netutils.bandwidth.name_to_bytes name_to_name netutils.bandwidth.name_to_name delimiter_change netutils.banner.delimiter_change normalise_delimiter_caret_c netutils.banner.normalise_delimiter_caret_c clean_config netutils.config.clean.clean_config sanitize_config netutils.config.clean.sanitize_config config_compliance netutils.config.compliance.compliance config_section_not_parsed netutils.config.compliance.config_section_not_parsed diff_network_config netutils.config.compliance.diff_network_config feature_compliance netutils.config.compliance.feature_compliance find_unordered_cfg_lines netutils.config.compliance.find_unordered_cfg_lines section_config netutils.config.compliance.section_config paloalto_panos_brace_to_set netutils.config.conversion.paloalto_panos_brace_to_set paloalto_panos_clean_newlines netutils.config.conversion.paloalto_panos_clean_newlines fqdn_to_ip netutils.dns.fqdn_to_ip is_fqdn_resolvable netutils.dns.is_fqdn_resolvable hash_data netutils.hash.hash_data abbreviated_interface_name netutils.interface.abbreviated_interface_name abbreviated_interface_name_list netutils.interface.abbreviated_interface_name_list canonical_interface_name netutils.interface.canonical_interface_name canonical_interface_name_list netutils.interface.canonical_interface_name_list interface_range_compress netutils.interface.interface_range_compress interface_range_expansion netutils.interface.interface_range_expansion sort_interface_list netutils.interface.sort_interface_list split_interface netutils.interface.split_interface cidr_to_netmask netutils.ip.cidr_to_netmask cidr_to_netmaskv6 netutils.ip.cidr_to_netmaskv6 get_all_host netutils.ip.get_all_host get_broadcast_address netutils.ip.get_broadcast_address get_first_usable netutils.ip.get_first_usable get_ips_sorted netutils.ip.get_ips_sorted get_peer_ip netutils.ip.get_peer_ip get_range_ips netutils.ip.get_range_ips get_usable_range netutils.ip.get_usable_range ip_addition netutils.ip.ip_addition ip_subtract netutils.ip.ip_subtract ip_to_bin netutils.ip.ip_to_bin ip_to_hex netutils.ip.ip_to_hex ipaddress_address netutils.ip.ipaddress_address ipaddress_interface netutils.ip.ipaddress_interface ipaddress_network netutils.ip.ipaddress_network is_classful netutils.ip.is_classful is_ip netutils.ip.is_ip is_ip_range netutils.ip.is_ip_range is_ip_within netutils.ip.is_ip_within is_netmask netutils.ip.is_netmask is_network netutils.ip.is_network is_reversible_wildcardmask netutils.ip.is_reversible_wildcardmask netmask_to_cidr netutils.ip.netmask_to_cidr netmask_to_wildcardmask netutils.ip.netmask_to_wildcardmask wildcardmask_to_netmask netutils.ip.wildcardmask_to_netmask get_napalm_getters netutils.lib_helpers.get_napalm_getters get_oui netutils.mac.get_oui is_valid_mac netutils.mac.is_valid_mac mac_normalize netutils.mac.mac_normalize mac_to_format netutils.mac.mac_to_format mac_to_int netutils.mac.mac_to_int mac_type netutils.mac.mac_type get_nist_urls netutils.nist.get_nist_urls get_nist_vendor_platform_urls netutils.nist.get_nist_vendor_platform_urls compare_version_loose netutils.os_version.compare_version_loose compare_version_strict netutils.os_version.compare_version_strict get_upgrade_path netutils.os_version.get_upgrade_path version_metadata netutils.os_version.version_metadata compare_cisco_type5 netutils.password.compare_cisco_type5 compare_cisco_type7 netutils.password.compare_cisco_type7 compare_cisco_type9 netutils.password.compare_cisco_type9 compare_type5 netutils.password.compare_type5 compare_type7 netutils.password.compare_type7 decrypt_cisco_type7 netutils.password.decrypt_cisco_type7 decrypt_juniper_type9 netutils.password.decrypt_juniper_type9 decrypt_type7 netutils.password.decrypt_type7 encrypt_cisco_type5 netutils.password.encrypt_cisco_type5 encrypt_cisco_type7 netutils.password.encrypt_cisco_type7 encrypt_cisco_type9 netutils.password.encrypt_cisco_type9 encrypt_juniper_type9 netutils.password.encrypt_juniper_type9 encrypt_type5 netutils.password.encrypt_type5 encrypt_type7 netutils.password.encrypt_type7 get_hash_salt netutils.password.get_hash_salt tcp_ping netutils.ping.tcp_ping regex_findall netutils.regex.regex_findall regex_match netutils.regex.regex_match regex_search netutils.regex.regex_search regex_split netutils.regex.regex_split regex_sub netutils.regex.regex_sub longest_prefix_match netutils.route.longest_prefix_match get_running_config_command netutils.running_config.get_running_config_command uptime_seconds_to_string netutils.time.uptime_seconds_to_string uptime_string_to_seconds netutils.time.uptime_string_to_seconds vlanconfig_to_list netutils.vlan.vlanconfig_to_list vlanlist_to_config netutils.vlan.vlanlist_to_config"},{"location":"user/lib_getting_started.html","title":"Getting Started with the Library","text":"<p>The library's primary use case is providing Python functions for the community. The primary way to use it is the same as any Python library. You <code>import</code> the functions, and use them, there are many examples on the Use Cases page.</p>"},{"location":"user/lib_getting_started.html#install-the-library","title":"Install the Library","text":"<p>To install the library, please follow the instructions detailed in the Installation Guide.</p>"},{"location":"user/lib_overview.html","title":"Library Overview","text":"<p>A Python library that is a collection of functions for common network automation tasks.</p> <p>This library intends to keep the following tenets:</p> <ul> <li>Must not be any dependencies required to run the library.<ul> <li>May be some optional dependencies, to be managed by the user in opt in fashion.</li> </ul> </li> <li>Shall prefer functions over classes.</li> <li>Shall prefer a folder and file structure that is flat.</li> <li>Shall leverage docstrings as the primary documentation mechanism.<ul> <li>Must provide examples in every public function.</li> </ul> </li> <li>Shall retain a high test coverage.</li> </ul>"},{"location":"user/lib_overview.html#descriptionoverview","title":"Description/Overview","text":"<p>A Python library that is a collection of functions that are used in the common network automation tasks. Tasks such as converting a BGP ASN to and from dotted format, normalizing an interface name, or \"type 5\" encrypting a password. The intention is to centralize these functions while keeping the library light.</p>"},{"location":"user/lib_overview.html#audience-user-personas-who-should-use-this-library","title":"Audience (User Personas) - Who should use this Library?","text":"<p>The intended audience is those who are programming network automation tasks with Python. Whether you are a seasoned veteran or a casual scripter, this library should help to reduce duplication between various reinventing the wheel.</p>"},{"location":"user/lib_overview.html#authors-and-maintainers","title":"Authors and Maintainers","text":"<ul> <li>@itdependsnetworks</li> <li>@jeffkala</li> <li>@qduk</li> </ul>"},{"location":"user/lib_upgrade_paths.html","title":"Upgrade Paths","text":"<p>The <code>UPGRADE_PATHS</code> definition in constants is maintained based on the following rules:</p> <ul> <li>They are not considered vendor recommendations, instead an interpretation based on the open source contributor.</li> <li>There is no expectation they will be updated, as such issues requesting updates will be closed but PRs to update--following the below rules--will be accepted.</li> <li>The lists can only be modified by added to during any patch or minor version.</li> <li>The list cannot be modified in any other way.</li> <li>Generate a new versioned list, e.g. PANOS_OFFICIAL_V2 vs PANOS_OFFICIAL_V1 and create an alternate list.</li> <li>During major version changes (e.g. 1.x.x to 2.x.x) lists may be removed.</li> </ul>"},{"location":"user/lib_use_cases.html","title":"Using the Library","text":"<p>As the Python library is intended to be a low-level implementation, the primary use case is within Code. On this page as well as subsequent pages we will provide an overview on the type of functions and examples.</p>"},{"location":"user/lib_use_cases.html#function-groupings","title":"Function Groupings","text":"<p>Functions are grouped with like functions, such as IP or MAC address based functions. Included to date are groupings of:</p> <ul> <li>ASN - Provides the ability to convert BGP ASN from integer to dot notation and back.</li> <li>Bandwidth - Provides the ability to convert between various bandwidth values.</li> <li>Banner - Provides the ability to normalize the various banner delimiters.</li> <li>Configuration<ul> <li>Cleaning - Provides the ability to remove or replace lines based on regex matches.</li> <li>Compliance - Provides the ability to compare two configurations to sanely understand the differences.</li> <li>Conversion - Provides the ability to convert between different syntax's within the same OS.</li> <li>Parsing - Provides the ability to parse configuration for the minor differences that are there.</li> </ul> </li> <li>DNS - Provides the ability to work with DNS, such as validating that a FQDN is resolvable.</li> <li>Hash - Provide a convenience method for hashlib to be used in Jinja2</li> <li>Interface - Provides the ability to work with interface names, expanding, abbreviating, and splitting the names.</li> <li>IP Address - Provides the ability to work with IP addresses, primarily exposing Python <code>ipaddress</code> functionality.</li> <li>Library Helpers - Provides helpers to pull useful information, e.g. NAPALM getters.</li> <li>Library Mapper - Provides mappings in expected vendor names between Netmiko, NAPALM, pyntc, ntc-templates, pyats, and scrapli.</li> <li>MAC Address - Provides the ability to work with MAC addresses such as validating or converting to integer.</li> <li>NIST - Provides the ability to obtain a URL formatted for NIST CPE Query.</li> <li>OS Version - Provides the ability to work with OS version, such as defining an upgrade path.</li> <li>Password - Provides the ability to compare and encrypt common password schemas such as type5 and type7 Cisco passwords.</li> <li>Ping - Provides the ability to ping, currently only tcp ping.</li> <li>Protocol Mapper - Provides a mapping for protocol names to numbers and vice versa.</li> <li>Regex - Provide convenience methods for regex to be used in Jinja2.</li> <li>Route - Provides the ability to provide a list of routes and an IP Address and return the longest prefix matched route.</li> <li>Time - Provides the ability to convert between integer time and string times.</li> <li>VLANs - Provide the ability to convert configuration into lists or lists into configuration.</li> </ul>"},{"location":"user/lib_use_cases.html#examples","title":"Examples","text":"<p>While all functions come with examples in the docstrings, for quick reference of the types of problems this library intends to solve the following examples are provided.</p> <p>The following function will help in deploying list of VLANs and match the configuration style in a standard IOS-like configurations.</p> <pre><code>&gt;&gt;&gt; from netutils.vlan import vlanlist_to_config\n&gt;&gt;&gt;\n&gt;&gt;&gt; vlan_cfg = vlanlist_to_config([1, 2, 3, 5, 6, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018])\n&gt;&gt;&gt;\n&gt;&gt;&gt; vlan_cfg\n[\"1-3,5,6,1000,1002,1004,1006,1008,1010,1012,1014\", \"1016,1018\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; for index, line in enumerate(vlan_cfg):\n...     if index == 0:\n...         print(f\"  switchport trunk allowed vlan {line}\")\n...     else:\n...         print(f\"  switchport trunk allowed vlan add {line}\")\n...\n  switchport trunk allowed vlan 1-3,5,6,1000,1002,1004,1006,1008,1010,1012,1014\n  switchport trunk allowed vlan add 1016,1018\n&gt;&gt;&gt;\n</code></pre> <p>You may want to compare a known password with a given encrypted password. This can help in verifying if the passwords are as expected for compliance reasons.</p> <pre><code>&gt;&gt;&gt; from netutils.password import compare_cisco_type5\n&gt;&gt;&gt;\n&gt;&gt;&gt; compare_cisco_type5(\"cisco\",\"$1$nTc1$Z28sUTcWfXlvVe2x.3XAa.\")\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; compare_cisco_type5(\"not_cisco\",\"$1$nTc1$Z28sUTcWfXlvVe2x.3XAa.\")\nFalse\n&gt;&gt;&gt;\n</code></pre> <p>Often times interfaces will come in various different shortened names, and it is helpful to normalize them.</p> <pre><code>&gt;&gt;&gt; from netutils.interface import canonical_interface_name\n&gt;&gt;&gt;\n&gt;&gt;&gt; canonical_interface_name(\"Gi1/0/1\")\n'GigabitEthernet1/0/1'\n&gt;&gt;&gt;\n&gt;&gt;&gt; canonical_interface_name(\"Eth1\")\n'Ethernet1'\n&gt;&gt;&gt;\n</code></pre> <p>Tip</p> <p>These are just some examples of the many functions provided by this library. Please review the Developer code for Examples on every public function</p>"},{"location":"user/lib_use_cases_acl.html","title":"ACL","text":"<p>The ACL classes are intended to help guide the ACL conversation. It is not intended to solve every ACL challenge you may have. In essence, it provides sane defaults and welcomes you to extend the logic via supported extension mechanisms. There are three patterns that heavily make up the capabilities:</p> <ul> <li>Expanding data to the \"Cartesian product\" (or permutations) of each rule, so that each product can be easily evaluated.</li> <li>Providing a <code>f\"{type}_*</code> method pattern, to dynamically find any <code>validate_*</code> or <code>enforce_*</code> method you provide.</li> <li>Providing a <code>f\"{type}_{attr}</code> method pattern, to dynamically find any <code>process_{attr}</code> or <code>match_{attr}</code> method you provide for the given attrs.</li> </ul> <p>Each of these are covered in detail, below in the core concepts section.</p> <p>Here you can see how the Python classes work together. There is a lot going on, so I encourage you to review the diagram briefly, and refer back to it often while reviewing the detailed information below.</p> <p></p> <p>Info</p> <p>It may be helpful to open the diagram in a new tab to view the full size, as an example, in Chrome you can right-click on the image and select \"Open Image on New Tab\".</p> <p>The intention of this page is not to cover every attribute and it's behavior, but a more human (although highly technical) understanding of what is going on. For more detailed information, please see the test and code docs.</p> <p>Info</p> <p>In the future the intention is to add features such as better de-duplication, partial match, and path analysis.</p>"},{"location":"user/lib_use_cases_acl.html#core-concepts","title":"Core Concepts","text":""},{"location":"user/lib_use_cases_acl.html#cartesian-product","title":"Cartesian Product","text":"<p>This \"Cartesian product\" concept is used throughout the page, so I thought it would be good to review. In this example, we have a single <code>rule</code>, and like many rules, it has multiple sources, destinations, and protocols. The <code>_cartesian_product</code> function creates the permutations, each of which is technically called a product.</p> <pre><code>&gt;&gt;&gt; from netutils.acl import _cartesian_product\n&gt;&gt;&gt; rule = dict(\n...         name=\"Allow to internal web\",\n...         src_ip=[\"192.168.0.0/24\", \"10.0.0.0/16\"],\n...         dst_ip=[\"172.16.0.0/16\", \"192.168.250.10-192.168.250.20\"],\n...         dst_port=[\"tcp/80\", \"udp/53\"],\n...         action=\"permit\",\n...     )\n&gt;&gt;&gt; for item in _cartesian_product(rule):\n...   print(item)\n... \n{'name': 'Allow to internal web', 'src_ip': '192.168.0.0/24', 'dst_ip': '172.16.0.0/16', 'dst_port': 'tcp/80', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '192.168.0.0/24', 'dst_ip': '172.16.0.0/16', 'dst_port': 'udp/53', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '192.168.0.0/24', 'dst_ip': '192.168.250.10-192.168.250.20', 'dst_port': 'tcp/80', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '192.168.0.0/24', 'dst_ip': '192.168.250.10-192.168.250.20', 'dst_port': 'udp/53', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '10.0.0.0/16', 'dst_ip': '172.16.0.0/16', 'dst_port': 'tcp/80', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '10.0.0.0/16', 'dst_ip': '172.16.0.0/16', 'dst_port': 'udp/53', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '10.0.0.0/16', 'dst_ip': '192.168.250.10-192.168.250.20', 'dst_port': 'tcp/80', 'action': 'permit'}\n{'name': 'Allow to internal web', 'src_ip': '10.0.0.0/16', 'dst_ip': '192.168.250.10-192.168.250.20', 'dst_port': 'udp/53', 'action': 'permit'}\n&gt;&gt;&gt; \n</code></pre> <p>Now that you have the Cartesian products, you can evaluate each one individually. In this example perhaps '192.168.0.0/24' -&gt; '172.16.0.0/16' is allowed, but '192.168.0.0/24' -&gt; '192.168.250.10-192.168.250.20' is denied. Yet another example is the access could be allowed on both sources and destinations IPs, but not for udp/53 (DNS).</p> <p>Having the ability to look at each product individually allows you to only have to worry about the check you wish to create, versus custom logic that attempts to understand the permutations. Building a <code>is_pci_to_non_pci</code> becomes trivial when looking at each product. This idea applies to validating, enforcing, matching, etc.</p>"},{"location":"user/lib_use_cases_acl.html#dynamic-method-attrs","title":"Dynamic Method - Attrs","text":"<p>The methods <code>process</code> and <code>match</code> both follow this pattern. As an example, the <code>process</code> method will dynamically find any method that follows <code>f\"process_{attr}</code> pattern. This allows a Python class that inherits from <code>ACLRule</code> to simply add a <code>process_src_ip</code> method and that method would be called.</p>"},{"location":"user/lib_use_cases_acl.html#dynamic-method-any","title":"Dynamic Method - Any","text":"<p>The methods <code>validate</code> and <code>enforce</code> both follow this pattern. As an example, the <code>validate</code> method will dynamically find any method that follows <code>f\"process_*</code> pattern. This allows a Python class that inherits from <code>ACLRule</code> to simply add a <code>validate_ip_in_network</code> method and that method would be called.</p> <p>In both methods, ordering can be controlled with order_validate and order_enforce respectively. The default ordering will be alphabetical, as returned by the Python dir function.</p>"},{"location":"user/lib_use_cases_acl.html#aclrule","title":"ACLRule","text":"<p>The <code>ACLRule</code> class at a high level:</p> <ul> <li>The class <code>ACLRule</code> is used for working with Access Control List (ACL) rules.</li> <li>It is built with extensibility in mind to allow you to customize how your business operates.</li> <li>It contains a list of attributes such as \"name,\" \"src_ip,\" \"src_zone,\" \"dst_ip,\" \"dst_port,\" \"dst_zone,\" and \"action\" that are commonly used to work with ACLs.</li> <li>Provides the ability for you to expand data such as converting an address-group name into detailed addresses with your custom code.</li> <li>Provides the Cartesian product (or permutations) of the rules to make evaluation simple.</li> <li>It provides options for verifying input data and result data (data expanded) with corresponding JSON schemas.</li> <li>Provides the ability to validate data, generally for tech feasibility testing such as \"are IPs on our network and in IPAM\" or \"is NAT IP provided vs actual IP\".</li> <li>Provides the ability to enforce data, generally for security testing such as \"is PCI attempting to talk with a non-PCI environment\" or \"is IP range not narrowly scoped enough\".<ul> <li>The class supports a matrix feature, which allows users to define custom rule matching based on predefined matrix definitions.</li> </ul> </li> <li>Provides the ability to match one rule to another, to understand if rule exists already.</li> </ul>"},{"location":"user/lib_use_cases_acl.html#initialization-loading-data","title":"Initialization &amp; Loading Data","text":"<p>The initialization process calls on the <code>load_data</code> method. This on a high level verifies schema of initial data, allows you to process data (e.g. convert tcp/https -&gt; 80/443), expand data, determine Cartesian product (or permutations) of the firewall rule (traditionally 5-tuple), and verifies schema of result data.</p> <p>The Cartesian product (or permutations) is key to the functionality of other steps, this allows you to evaluate each rule based on the smallest view of the data, so pay close attention to those steps, as it is important to other methods as well.</p> <p>To provide some ideas on what you may validate:</p> <ul> <li>Is one of the source or destination IPs in our network?</li> <li>Is one of the source or destination IPs in our IPAM?</li> <li>Is the source and destination IPs able to route to each other?</li> <li>Is the source and destination IPs on the same network?</li> <li>Is one of the destination IPs to the real IP vs the NAT IP?</li> <li>Is there routing from the source zone to the destination zone?</li> <li>Is the business unit name in the description ?</li> </ul> <p>Many of validations will be based on IPs, but not all.</p> <p>Here you will find a written understanding of what is happening in the code:</p> <ul> <li>The init method takes in data and calls <code>load_data</code>.</li> <li>The method <code>load_data</code> processes the input data.<ul> <li>The <code>input_data_check</code> method is called and verifies the input data based on the specified JSON schema.<ul> <li>This is controlled by the <code>input_data_verify</code> attribute and schema defined in <code>input_data_schema</code>.</li> </ul> </li> <li>For each <code>self.attrs</code>, a method name matching <code>f\"process_{attr}\"</code>, (e.g. <code>process_src_ip()</code>) is called.<ul> <li>This allows you to inherit from and provide your own custom processes to convert, expand, or otherwise modify data before being evaluated.</li> <li>The <code>process_dst_port</code> method processes the <code>dst_port</code> attribute by converting the protocol and port information, it is enabled by default but controlled with the <code>dst_port_process</code> attribute.</li> <li>Both a dictionary <code>self.processed</code> and attributes (e.g. self.action, self.src_ip, etc.) are created.</li> </ul> </li> <li>The <code>result_data_check</code> method verifies the processed data based on the specified JSON schema.<ul> <li>This is controlled by the <code>result_data_verify</code> attribute which is disabled by default.</li> </ul> </li> <li>The <code>validate</code> method validating the rule using a series of custom methods starting with <code>validate_</code> prefixes.<ul> <li>The ordering can be controlled based on the <code>order_validate</code> attribute or defaults to all matches.</li> </ul> </li> <li>The rules are expanded into <code>self.expanded_rules</code> by creating each permutations of the tuple, using a Cartesian product function.<ul> <li>An example permutations would be converting source: 10.1.1.1, 10.1.1.2, destination: 10.100.100.100, port: 80 -&gt; 10.1.1.1, destination: 10.100.100.100, port: 80 and 10.1.1.2, destination: 10.100.100.100, port: 80.</li> <li>This will be key, so that each permutations can be compared individually later.</li> </ul> </li> <li>Filter out the permutations that have the same source and destination IP, if <code>self.filter_same_ip</code> which is on by default.</li> </ul> </li> </ul>"},{"location":"user/lib_use_cases_acl.html#enforce","title":"Enforce","text":"<p>Enforce is generally used for security controls. An <code>enforce_matrix</code> is provided but not used by default. You can think of the matrix as an Excel sheet, in which you have source as the rows and destination as the column. You would identify the source/destination IP and find which x &amp; y coordinates in your Excel document, and perform whatever action it states, such as deny, review, approve, etc.</p> <p>To provide some ideas on what you may enforce:</p> <ul> <li>Is the request for a PCI to non-PCI network?</li> <li>Is the request for a security-zone-X to security-zone-Y network?</li> <li>Is the protocol a secure protocol?</li> <li>Is the request approved?</li> <li>Is the IPs requested narrowly scoped?</li> </ul> <p>Here you will find a written understanding of what is happening in the code:</p> <ul> <li>The <code>enforce</code> method validating the rule using a series of custom methods starting with <code>enforce_</code> prefixes such as <code>enforce_pci_checks</code>.<ul> <li>The ordering can be controlled based on the <code>order_enforce</code> attribute or defaults to all matches.</li> <li>The <code>enforce_matrix</code> method enforces ACL rules based on a predefined matrix feature.<ul> <li>This is controlled by the <code>self.matrix_enforced</code> attribute and is off by default.</li> <li>The <code>enforce_matrix</code> method runs the enforcement checks for each of the <code>self.expanded_rules</code> (or permutations of tuples)</li> <li>This matrix definition is very simple and not likely ready to be be used in a production environment, instead used for simple demonstrations and communicating potential ideas.</li> </ul> </li> <li>Each method should return a dictionary or list of dictionaries as both of these are handled<ul> <li>In the example there is the <code>obj</code> and <code>action</code> key.</li> <li>This could and should be extended, such as providing obj, action, detail_msg, notification_team, and any other metadata that the tooling using this system would require.</li> <li>Catastrophic errors will raise an error.</li> </ul> </li> </ul> </li> </ul> <p>While not accurate in all use cases it would be best practice to run any of your custom <code>enforce_</code> against <code>self.expanded_rules</code>. </p>"},{"location":"user/lib_use_cases_acl.html#match-match-details","title":"Match &amp; Match Details","text":"<p>The <code>match_details</code> method provides a verbose way of verifying match details between two ACL rule's, the <code>match</code> method uses <code>match_details</code> and provides a boolean if there are any rules in <code>rules_unmatched</code> which would tell you if you had a full match or not. We will only review in detail the <code>match_details</code>.</p> <p>Here you will find a written understanding of what is happening in the code:</p> <ul> <li>The <code>self.expanded_rules</code> is looped over for every permutations.<ul> <li>For each <code>self.attrs</code>, a method name matching <code>f\"match_{attr}\"</code>, (e.g. <code>match_src_ip()</code>) is called.<ul> <li>This allows you to inherit from and provide your own custom equality check or verify with your business logic.</li> <li>You do not need to have a <code>f\"match_{attr}\"</code> method for every attr, description as example would not be a good candidate to match on.</li> <li>Equality checks are done on <code>src_zone</code>, <code>dst_zone</code>, <code>action</code>, and <code>port</code> by default.</li> <li>An <code>is_ip_within</code> check is done with for <code>src_ip</code> and <code>dst_ip</code> by default.</li> </ul> </li> </ul> </li> <li>In the process, details are provided for and returned:<ul> <li><code>rules_matched</code> - Root key that is a list of dictionaries of rules that matched.</li> <li><code>rules_unmatched</code> - Root key that is a list of dictionaries of rules that did not match.</li> <li><code>existing_rule_product</code> - The original expanded_rule that existed in this item.</li> <li><code>existing_rule</code> - The full original rule (not expanded_rule) that existed.</li> <li><code>match_rule</code> - The full original rule that tested against, only shown in <code>rules_matched</code> root key.</li> </ul> </li> </ul> <p>This data could help you to understand what matched, why it matched, and other metadata. This detail data can be used to in <code>ACLRules</code> to aggregate and ask more interesting questions.</p>"},{"location":"user/lib_use_cases_acl.html#aclrules","title":"ACLRules","text":"<p>The <code>ACLRules</code> class at a high level:</p> <ul> <li>Loads up multiple <code>ACLRule</code> and loads the data from a list of dictionaries.<ul> <li>This is generally the data that exists on the firewall already, but there are other use cases.</li> </ul> </li> <li>Allows you to match the multiple <code>ACLRule</code> objects, and test against a single <code>ACLRule</code> object.<ul> <li>This is generally to see if the access to the rule you are testing exists already or not.</li> </ul> </li> </ul> <p>Using the <code>match_details</code> method, you could as an example, build logic if every product of the rule is matched, just not against a single rule. This is one of many different ways you could use the data. </p>"},{"location":"user/lib_use_cases_acl.html#example-usage","title":"Example Usage","text":"<p>Here we can test if a rule is matched via the existing ruleset. We can leverage the permit or deny to understand if this exists already or not.</p> <p>Simple Example</p> <pre><code>&gt;&gt;&gt; from netutils.acl import ACLRules\n&gt;&gt;&gt; \n&gt;&gt;&gt; existing_acls = [\n...     dict(\n...         name=\"Allow to internal web\",\n...         src_ip=[\"192.168.0.0/24\", \"10.0.0.0/16\"],\n...         dst_ip=[\"172.16.0.0/16\", \"192.168.250.10-192.168.250.20\"],\n...         dst_port=[\"tcp/80\", \"udp/53\"],\n...         action=\"permit\",\n...     ),\n...     dict(\n...         name=\"Allow to internal dns\",\n...         src_ip=[\"192.168.1.0/24\"],\n...         dst_ip=[\"172.16.0.0/16\"],\n...         dst_port=[\"tcp/80\", \"udp/53\"],\n...         action=\"permit\",\n...     )\n... ]\n&gt;&gt;&gt; \n&gt;&gt;&gt; new_acl_match = dict(\n...     name=\"Check multiple sources pass\",\n...     src_ip=[\"192.168.1.10\", \"192.168.1.11\", \"192.168.1.15-192.168.1.20\"],\n...     dst_ip=\"172.16.0.10\",\n...     dst_port=\"tcp/www-http\",\n...     action=\"permit\",\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; ACLRules(existing_acls).match(new_acl_match)\n'permit'\n&gt;&gt;&gt; \n&gt;&gt;&gt; \n&gt;&gt;&gt; new_acl_non_match = dict(\n...     name=\"Check no match\",\n...     src_ip=[\"10.1.1.1\"],\n...     dst_ip=\"172.16.0.10\",\n...     dst_port=\"tcp/www-http\",\n...     action=\"permit\",\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; ACLRules(existing_acls).match(new_acl_non_match)\n'deny'\n&gt;&gt;&gt; \n</code></pre> <p>Inherit Example</p> <pre><code>from netutils.acl import ACLRule\n\nclass ExpandAddrGroups(ACLRule):\n    address_groups = {\"red\": [\"white\", \"blue\"], \"blue\": [\"cyan\"], \"yellow\": [\"orange\"]}\n    addresses = {\"white\": [\"10.1.1.1\", \"10.2.2.2\"], \"cyan\": [\"10.3.3.3\"], \"orange\": [\"10.4.4.4\"]}\n\n    def __init__(self, data, *args, **kwargs):\n        self.flattened_addresses = self.flatten_addresses(self.address_groups, self.addresses)\n        super().__init__(data, *args, **kwargs)\n\n    def flatten_addresses(self, address_groups, addresses):\n        flattened_addresses = {}\n        for group, subgroups in address_groups.items():\n            if group in addresses:\n                flattened_addresses.setdefault(group, []).extend(addresses[group])\n            for subgroup in subgroups:\n                if subgroup in addresses:\n                    flattened_addresses.setdefault(group, []).extend(addresses[subgroup])\n                if subgroup in address_groups:\n                    subgroup_addresses = self.flatten_addresses({subgroup: address_groups[subgroup]}, addresses)\n                    for sub_group, ips in subgroup_addresses.items():\n                        flattened_addresses.setdefault(sub_group, []).extend(ips)\n                        if group != sub_group:\n                            flattened_addresses.setdefault(group, []).extend(ips)\n        return flattened_addresses\n\n    def process_ip(self, ip):\n        if not isinstance(ip, list):\n            ip = [ip]\n        output = []\n        for ip_name in ip:\n            if not ip_name[0].isalpha():\n                output.append(ip_name)\n            elif self.addresses.get(ip_name):\n                output.extend(self.addresses[ip_name])\n            elif self.flattened_addresses.get(ip_name):\n                output.extend(self.flattened_addresses[ip_name])\n        return sorted(list(set(output)))\n\n    def process_src_ip(self, src_ip):\n        return self.process_ip(src_ip)\n\n    def process_dst_ip(self, dst_ip):\n        return self.process_ip(dst_ip)\n</code></pre> <p>Using the above object, we can test with:</p> <pre><code>&gt;&gt;&gt; rule_data = dict(\n...     name=\"Check allow\",\n...     src_ip=[\"red\", \"blue\", \"10.4.4.4\"],\n...     dst_ip=[\"white\"],\n...     dst_port=\"6/www-http\",\n...     action=\"permit\",\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; address_object_expanded = ExpandAddrGroups(rule_data)\n&gt;&gt;&gt; for item in address_object_expanded.expanded_rules:\n...   print(item)\n... \n{'name': 'Check allow', 'src_ip': '10.1.1.1', 'dst_ip': '10.2.2.2', 'dst_port': '6/80', 'action': 'permit'}\n{'name': 'Check allow', 'src_ip': '10.2.2.2', 'dst_ip': '10.1.1.1', 'dst_port': '6/80', 'action': 'permit'}\n{'name': 'Check allow', 'src_ip': '10.3.3.3', 'dst_ip': '10.1.1.1', 'dst_port': '6/80', 'action': 'permit'}\n{'name': 'Check allow', 'src_ip': '10.3.3.3', 'dst_ip': '10.2.2.2', 'dst_port': '6/80', 'action': 'permit'}\n{'name': 'Check allow', 'src_ip': '10.4.4.4', 'dst_ip': '10.1.1.1', 'dst_port': '6/80', 'action': 'permit'}\n{'name': 'Check allow', 'src_ip': '10.4.4.4', 'dst_ip': '10.2.2.2', 'dst_port': '6/80', 'action': 'permit'}\n&gt;&gt;&gt; \n</code></pre> <p>In that example you can see how we expanded <code>red</code> -&gt; 10.1.1.1\", \"10.2.2.2\", \"10.3.3.3\" as an example.</p>"},{"location":"user/lib_use_cases_jinja_filters.html","title":"Netutils to Jinja2 Filters","text":"<p>In an effort to simplify the process of adding netutils' functions to Jinja2 as filters we have created a convenience function. Let's go through how you could add the filters to your Jinja2 environment. Here is the current folder structure.</p> <pre><code>.\n\u251c\u2500\u2500 jinja2_environment.py\n\u2514\u2500\u2500 templates\n    \u2514\u2500\u2500 test.j2\n</code></pre> <p>Below is the code in the <code>test.j2</code> file.</p> <p><pre><code>IP Address + 200 = {{ \"192.168.0.1\" | ip_addition(200) }}\n</code></pre> Below is a code in the <code>jinja2_environment.py</code> folder.</p> <pre><code>from jinja2.loaders import FileSystemLoader, PackageLoader\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom netutils.utils import jinja2_convenience_function\n\nenv = Environment(\n    loader=FileSystemLoader(\"templates\"),\n    autoescape=select_autoescape()\n)\n\nenv.filters.update(jinja2_convenience_function())\n\ntemplate = env.get_template(\"test.j2\")\nresult = template.render()\nprint(result)\n</code></pre> <p>When you run <code>jinja2_environment.py</code> the output will be:</p> <pre><code>IP Address + 200 = 192.168.0.201\n</code></pre>"},{"location":"user/lib_use_cases_jinja_filters.html#netutils-to-ansible-jinja2-filters","title":"Netutils to Ansible Jinja2 Filters","text":"<p>In Ansible, one can add with the following code by adding to a folder called <code>filter_plugins</code> in a file called <code>nutils.py</code> as an example.</p> <pre><code>from netutils.utils import jinja2_convenience_function\nclass FilterModule(object):\n    def filters(self):\n        return jinja2_convenience_function()\n</code></pre>"},{"location":"user/lib_use_cases_jinja_filters.html#ipaddress-convenience-functions","title":"ipaddress Convenience Functions","text":"<p>When adding the netutils functions to your Jinja2 environment, you also gain access to the built-in ipaddress python library using these three Jinja2 filters.</p> <pre><code>  \"ipaddress_address\": \"ip.ipaddress_address\",\n  \"ipaddress_interface\": \"ip.ipaddress_interface\",\n  \"ipaddress_network\": \"ip.ipaddress_network\",\n</code></pre> <p>When using these filters, you must specify an attribute of that given class. Here is an example of how you would use the <code>version</code> if the <code>ipaddress_interface</code> filter.</p> <pre><code>.\n.\n\u251c\u2500\u2500 jinja2_environment.py\n\u2514\u2500\u2500 templates\n    \u2514\u2500\u2500 test.j2\n</code></pre> <p>Below is the code in the <code>test.j2</code> file.</p> <pre><code>The version of 192.168.0.1/24 is IPv{{ \"192.168.0.1/24\" | ipaddress_interface(\"version\") }}.\n</code></pre> <p>Below is a code in the <code>jinja2_environment.py</code> folder.</p> <pre><code>from jinja2.loaders import FileSystemLoader, PackageLoader\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom netutils.utils import jinja2_convenience_function\n\nenv = Environment(\n    loader=FileSystemLoader(\"templates\"),\n    autoescape=select_autoescape()\n)\n\nenv.filters.update(jinja2_convenience_function())\n\ntemplate = env.get_template(\"test.j2\")\nresult = template.render()\nprint(result)\n</code></pre> <p>When you run <code>jinja2_environment.py</code> the output will be:</p> <pre><code>The version of 192.168.0.1/24 is IPv4.\n</code></pre>"},{"location":"user/lib_use_cases_jinja_filters.html#regex-convenience-functions","title":"regex Convenience Functions","text":"<p>When adding the netutils functions to your Jinja2 environment, you also gain access to the built-in <code>re</code> python library using these Jinja2 filters.</p> <pre><code>    \"regex_findall\": \"regex.regex_findall\",\n    \"regex_match\": \"regex.regex_match\",\n    \"regex_search\": \"regex.regex_search\",\n    \"regex_split\": \"regex.regex_split\",\n    \"regex_sub\": \"regex.regex_sub\",\n</code></pre> <p>These functions will always return a json serializable object and not a complex object like <code>re.Match</code> or similar to better serve the primary use case of functions to be used as Jinja2 filters. After all, they are simply small wrappers around Python <code>re</code> functions, the Python provided <code>re</code> functionality should be preferred when not using Jinja2 or similar templating language.</p> <p>Below is code that you can drop into your Python shell to help bring to life how these regex functions can be used.</p> <pre><code>from jinja2 import Environment, BaseLoader\nfrom netutils.utils import jinja2_convenience_function\n\nenv = Environment(loader=BaseLoader())\nenv.filters.update(jinja2_convenience_function())\n\nDATA = {\n    \"device\": \"USSCAMS07\", \n    \"comma_seperated_devices\": \"NYC-RT01,NYC-RT02,SFO-SW01,SFO-RT01\"\n}\n\nTEMPLATE_STRING = \"\"\"\n{% set device_details = '([A-Z]{2})([A-Z]{2})([A-Z]{3})(\\d*)' | regex_match(device) %}\n\nCountry: {{ ('^([A-Z]{2})([A-Z]{2})([A-Z]{3})(\\d*)' | regex_search(device))[0] }}\nSTATE: {{ device_details[1] }}\nFUNCTION: {{ device_details[2] }}\n\nALL DEVICES:\n{% for router in ',' | regex_split(comma_seperated_devices) -%}\n  - {{ router }}\n{% endfor %}\n\nONLY ROUTERS:\n{% for router in ',' | regex_split(comma_seperated_devices) -%}\n{% if '-RT' | regex_search(router) -%}\n  - {{ router }}\n{% endif -%}\n{% endfor %}\n\"\"\"\n\ntemplate = env.from_string(TEMPLATE_STRING, DATA)\nresult = template.render()\nprint(result)\n</code></pre> <p>Which would result in the following output.</p> <pre><code>Country: US\nSTATE: SC\nFUNCTION: AMS\n\nALL DEVICES:\n- NYC-RT01\n- NYC-RT02\n- SFO-SW01\n- SFO-RT01\n\nONLY ROUTERS:\n- NYC-RT01\n- NYC-RT02\n- SFO-RT01\n</code></pre>"},{"location":"user/lib_use_cases_jinja_filters.html#netutils-to-jinja2-filters-list","title":"Netutils to Jinja2 Filters List","text":"<p>The below list shows what jinja2 filters are added when you add them using the process above. The keys of the dictionary are the names you would use to call the jinja2 filter.</p> <p>Note</p> <p>The Jinja2 filter names match the python function names.</p> Filter name Function asn_to_int netutils.asn.asn_to_int int_to_asdot netutils.asn.int_to_asdot bits_to_name netutils.bandwidth.bits_to_name bytes_to_name netutils.bandwidth.bytes_to_name name_to_bits netutils.bandwidth.name_to_bits name_to_bytes netutils.bandwidth.name_to_bytes name_to_name netutils.bandwidth.name_to_name delimiter_change netutils.banner.delimiter_change normalise_delimiter_caret_c netutils.banner.normalise_delimiter_caret_c clean_config netutils.config.clean.clean_config sanitize_config netutils.config.clean.sanitize_config config_compliance netutils.config.compliance.compliance config_section_not_parsed netutils.config.compliance.config_section_not_parsed diff_network_config netutils.config.compliance.diff_network_config feature_compliance netutils.config.compliance.feature_compliance find_unordered_cfg_lines netutils.config.compliance.find_unordered_cfg_lines section_config netutils.config.compliance.section_config paloalto_panos_brace_to_set netutils.config.conversion.paloalto_panos_brace_to_set paloalto_panos_clean_newlines netutils.config.conversion.paloalto_panos_clean_newlines fqdn_to_ip netutils.dns.fqdn_to_ip is_fqdn_resolvable netutils.dns.is_fqdn_resolvable hash_data netutils.hash.hash_data abbreviated_interface_name netutils.interface.abbreviated_interface_name abbreviated_interface_name_list netutils.interface.abbreviated_interface_name_list canonical_interface_name netutils.interface.canonical_interface_name canonical_interface_name_list netutils.interface.canonical_interface_name_list interface_range_compress netutils.interface.interface_range_compress interface_range_expansion netutils.interface.interface_range_expansion sort_interface_list netutils.interface.sort_interface_list split_interface netutils.interface.split_interface cidr_to_netmask netutils.ip.cidr_to_netmask cidr_to_netmaskv6 netutils.ip.cidr_to_netmaskv6 get_all_host netutils.ip.get_all_host get_broadcast_address netutils.ip.get_broadcast_address get_first_usable netutils.ip.get_first_usable get_ips_sorted netutils.ip.get_ips_sorted get_peer_ip netutils.ip.get_peer_ip get_range_ips netutils.ip.get_range_ips get_usable_range netutils.ip.get_usable_range ip_addition netutils.ip.ip_addition ip_subtract netutils.ip.ip_subtract ip_to_bin netutils.ip.ip_to_bin ip_to_hex netutils.ip.ip_to_hex ipaddress_address netutils.ip.ipaddress_address ipaddress_interface netutils.ip.ipaddress_interface ipaddress_network netutils.ip.ipaddress_network is_classful netutils.ip.is_classful is_ip netutils.ip.is_ip is_ip_range netutils.ip.is_ip_range is_ip_within netutils.ip.is_ip_within is_netmask netutils.ip.is_netmask is_network netutils.ip.is_network is_reversible_wildcardmask netutils.ip.is_reversible_wildcardmask netmask_to_cidr netutils.ip.netmask_to_cidr netmask_to_wildcardmask netutils.ip.netmask_to_wildcardmask wildcardmask_to_netmask netutils.ip.wildcardmask_to_netmask get_napalm_getters netutils.lib_helpers.get_napalm_getters get_oui netutils.mac.get_oui is_valid_mac netutils.mac.is_valid_mac mac_normalize netutils.mac.mac_normalize mac_to_format netutils.mac.mac_to_format mac_to_int netutils.mac.mac_to_int mac_type netutils.mac.mac_type get_nist_urls netutils.nist.get_nist_urls get_nist_vendor_platform_urls netutils.nist.get_nist_vendor_platform_urls compare_version_loose netutils.os_version.compare_version_loose compare_version_strict netutils.os_version.compare_version_strict get_upgrade_path netutils.os_version.get_upgrade_path version_metadata netutils.os_version.version_metadata compare_cisco_type5 netutils.password.compare_cisco_type5 compare_cisco_type7 netutils.password.compare_cisco_type7 compare_cisco_type9 netutils.password.compare_cisco_type9 compare_type5 netutils.password.compare_type5 compare_type7 netutils.password.compare_type7 decrypt_cisco_type7 netutils.password.decrypt_cisco_type7 decrypt_juniper_type9 netutils.password.decrypt_juniper_type9 decrypt_type7 netutils.password.decrypt_type7 encrypt_cisco_type5 netutils.password.encrypt_cisco_type5 encrypt_cisco_type7 netutils.password.encrypt_cisco_type7 encrypt_cisco_type9 netutils.password.encrypt_cisco_type9 encrypt_juniper_type9 netutils.password.encrypt_juniper_type9 encrypt_type5 netutils.password.encrypt_type5 encrypt_type7 netutils.password.encrypt_type7 get_hash_salt netutils.password.get_hash_salt tcp_ping netutils.ping.tcp_ping regex_findall netutils.regex.regex_findall regex_match netutils.regex.regex_match regex_search netutils.regex.regex_search regex_split netutils.regex.regex_split regex_sub netutils.regex.regex_sub longest_prefix_match netutils.route.longest_prefix_match get_running_config_command netutils.running_config.get_running_config_command uptime_seconds_to_string netutils.time.uptime_seconds_to_string uptime_string_to_seconds netutils.time.uptime_string_to_seconds vlanconfig_to_list netutils.vlan.vlanconfig_to_list vlanlist_to_config netutils.vlan.vlanlist_to_config"},{"location":"user/lib_use_cases_lib_mapper.html","title":"Library Mappings","text":"<p>These dictionaries provide mappings in expected vendor names between Netmiko, NAPALM, pyntc, ntc-templates, pyats, and scrapli. For each non-reversed mapper, the keys of the dictionary represent the driver used for that library while the values represent the \"normalized\" driver based on netmiko.</p> <p>These dictionaries allow you to keep your Source of Truth platform data consistent and still easily switch between automation libraries. For example, you may be storing your device platform data in Nautobot. In a Nautobot platform, you can store the NAPALM driver needed for that platform. What if you wanted to write a python script to leverage the backup capabilities of pyntc? Here's an example of how you could use the following dictionaries to perform mappings from your stored Nautobot NAPALM driver to the pyntc driver needed for your script.</p> <pre><code>import pynautobot\nfrom netutils.lib_mapper import NAPALM_LIB_MAPPER, PYNTC_LIB_MAPPER_REVERSE\nfrom pyntc import ntc_device as NTC\n\n\n# Get device from Nautobot\nnautobot = pynautobot.api(url=\"http://mynautobotinstance.com\",token=\"mytoken\")\n\n# Get Napalm driver and save for later use.\ndevice = nautobot.dcim.devices.get(name=\"mydevice\")\nsot_driver = device.platform.napalm_driver\n\n\n# Connect to device via Napalm\ndriver = napalm.get_network_driver(sot_driver)\n\ndevice = driver(\n    hostname=\"device.name\",\n    username=\"demo\",\n    password=\"secret\"\n)\n\n# Do Napalm tasks\n\npyntc_driver = PYNTC_LIB_MAPPER_REVERSE.get(NAPALM_LIB_MAPPER.get(sot_driver))\nnet_con = NTC(host=device.name, username=\"demo\", password=\"secret\", device_type=pyntc_driver)\n\n# Do pyntc tasks\n</code></pre> <p>Another use case could be using an example like the above in an Ansible filter. That would allow you to write a filter utilizing whichever automation library you needed without having to store the driver for each one in your Source of Truth.</p> <p>There is also a dynamically built mapping that gives you all of the libraries given a normalized name, here is a condensed snippet to understand the data structure of <code>NAME_TO_ALL_LIB_MAPPER</code>:</p> <pre><code>{\n    \"cisco_ios\": {\n        \"ansible\": \"cisco.ios.ios\",\n        \"napalm\": \"ios\",\n    },\n    \"cisco_nxos\": {\n        \"ansible\": \"cisco.nxos.nxos\",\n        \"napalm\": \"nxos\",\n    }\n}\n</code></pre>"},{"location":"user/lib_use_cases_lib_mapper.html#aerleon-mapper","title":"Aerleon Mapper","text":"AERLEON NORMALIZED arista \u2192 arista_eos aruba \u2192 aruba_aoscx brocade \u2192 brocade_nos cisco \u2192 cisco_ios ciscoasa \u2192 cisco_asa cisconx \u2192 cisco_nxos ciscoxr \u2192 cisco_xr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper \u2192 juniper_junos juniperevo \u2192 juniper_junos k8s \u2192 k8s msmpc \u2192 juniper_junos nsxt \u2192 vmware_nsxt nsxv \u2192 vmware_nsxv openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto \u2192 paloalto_panos pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway srx \u2192 juniper_junos srxlo \u2192 juniper_junos windows \u2192 windows windows_advfirewall \u2192 windows"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-aerleon-mapper","title":"Reverse Aerleon Mapper","text":"NORMALIZED AERLEON arista_eos \u2192 arista aruba_aoscx \u2192 aruba brocade_nos \u2192 brocade cisco_asa \u2192 ciscoasa cisco_ios \u2192 cisco cisco_nxos \u2192 cisconx cisco_xe \u2192 cisco cisco_xr \u2192 ciscoxr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper_junos \u2192 juniper k8s \u2192 k8s openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto_panos \u2192 paloalto pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway vmware_nsxt \u2192 nsxt vmware_nsxv \u2192 nsxv windows \u2192 windows"},{"location":"user/lib_use_cases_lib_mapper.html#ansible-mapper","title":"Ansible Mapper","text":"ANSIBLE NORMALIZED a10.acos_axapi.a10 \u2192 a10 arista.eos.eos \u2192 arista_eos arubanetworks.aoscx \u2192 aruba_aoscx ciena.saos6.saos6 \u2192 ciena_saos cisco.asa.asa \u2192 cisco_asa cisco.ios.ios \u2192 cisco_ios cisco.iosxr.iosxr \u2192 cisco_xr cisco.meraki.meraki \u2192 cisco_meraki cisco.nxos.nxos \u2192 cisco_nxos community.network.ce \u2192 huawei community.network.cnos \u2192 lenovo_cnos community.network.enos \u2192 lenovo_enos community.network.eric_eccli \u2192 ericsson_ipos community.network.exos \u2192 extreme_exos community.network.icx \u2192 ruckus_icx community.network.ironware \u2192 extreme_netiron community.network.netvisor \u2192 pluribus community.network.nos \u2192 extreme_nos community.network.routeros \u2192 mikrotik_routeros community.network.slxos \u2192 extreme_slx community.network.sros \u2192 nokia_sros community.network.voss \u2192 extreme_vsp dellemc.enterprise_sonic.sonic \u2192 sonic dellemc.os10.0s10 \u2192 dell_os10 dellemc.os6.os6 \u2192 dell_os6 dellemc.os9.os9 \u2192 dell_os9 f5networks.f5_bigip.bigip \u2192 bigip_f5 fortinet.fortios.fortios \u2192 fortinet junipernetworks.junos.junos \u2192 juniper_junos nokia.srl \u2192 nokia_srl paloaltonetworks.panos.panos \u2192 paloalto_panos vyos.vyos.vyos \u2192 vyos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-ansible-mapper","title":"Reverse Ansible Mapper","text":"NORMALIZED ANSIBLE a10 \u2192 a10.acos_axapi.a10 arista_eos \u2192 arista.eos.eos aruba_aoscx \u2192 arubanetworks.aoscx bigip_f5 \u2192 f5networks.f5_bigip.bigip ciena_saos \u2192 ciena.saos6.saos6 cisco_asa \u2192 cisco.asa.asa cisco_ios \u2192 cisco.ios.ios cisco_meraki \u2192 cisco.meraki.meraki cisco_nxos \u2192 cisco.nxos.nxos cisco_xe \u2192 cisco.ios.ios cisco_xr \u2192 cisco.iosxr.iosxr dell_os10 \u2192 dellemc.os10.0s10 dell_os6 \u2192 dellemc.os6.os6 dell_os9 \u2192 dellemc.os9.os9 ericsson_ipos \u2192 community.network.eric_eccli extreme_exos \u2192 community.network.exos extreme_netiron \u2192 community.network.ironware extreme_nos \u2192 community.network.nos extreme_slx \u2192 community.network.slxos extreme_vsp \u2192 community.network.voss fortinet \u2192 fortinet.fortios.fortios huawei \u2192 community.network.ce juniper_junos \u2192 junipernetworks.junos.junos lenovo_cnos \u2192 community.network.cnos lenovo_enos \u2192 community.network.enos mikrotik_routeros \u2192 community.network.routeros nokia_srl \u2192 nokia.srl nokia_sros \u2192 community.network.sros paloalto_panos \u2192 paloaltonetworks.panos.panos pluribus \u2192 community.network.netvisor ruckus_icx \u2192 community.network.icx sonic \u2192 dellemc.enterprise_sonic.sonic vyos \u2192 vyos.vyos.vyos"},{"location":"user/lib_use_cases_lib_mapper.html#capirca-mapper","title":"Capirca Mapper","text":"CAPIRCA NORMALIZED arista \u2192 arista_eos aruba \u2192 aruba_aoscx brocade \u2192 brocade_nos cisco \u2192 cisco_ios ciscoasa \u2192 cisco_asa cisconx \u2192 cisco_nxos ciscoxr \u2192 cisco_xr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper \u2192 juniper_junos juniperevo \u2192 juniper_junos k8s \u2192 k8s msmpc \u2192 juniper_junos nsxt \u2192 vmware_nsxt nsxv \u2192 vmware_nsxv openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto \u2192 paloalto_panos pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway srx \u2192 juniper_junos srxlo \u2192 juniper_junos windows \u2192 windows windows_advfirewall \u2192 windows"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-capirca-mapper","title":"Reverse Capirca Mapper","text":"NORMALIZED CAPIRCA arista_eos \u2192 arista aruba_aoscx \u2192 aruba brocade_nos \u2192 brocade cisco_asa \u2192 ciscoasa cisco_ios \u2192 cisco cisco_nxos \u2192 cisconx cisco_xe \u2192 cisco cisco_xr \u2192 ciscoxr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper_junos \u2192 juniper k8s \u2192 k8s openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto_panos \u2192 paloalto pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway vmware_nsxt \u2192 nsxt vmware_nsxv \u2192 nsxv windows \u2192 windows"},{"location":"user/lib_use_cases_lib_mapper.html#dna-center-mapper","title":"DNA Center Mapper","text":"DNA_CENTER NORMALIZED IOS \u2192 cisco_ios IOS-XE \u2192 cisco_ios IOS-XR \u2192 cisco_xr NX-OS \u2192 cisco_nxos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-dna-center-mapper","title":"Reverse DNA Center Mapper","text":"NORMALIZED DNA_CENTER cisco_ios \u2192 IOS cisco_nxos \u2192 NX-OS cisco_xr \u2192 IOS-XR"},{"location":"user/lib_use_cases_lib_mapper.html#forward-networks-mapper","title":"Forward Networks Mapper","text":"FORWARDNETWORKS NORMALIZED ARISTA_EOS \u2192 arista_eos ARUBA_SWITCH \u2192 aruba_aoscx ASA \u2192 cisco_asa EXTREME_NOS \u2192 extreme_netiron F5 \u2192 bigip_f5 FORTINET \u2192 fortinet IOS \u2192 cisco_ios IOS_XE \u2192 cisco_ios IOS_XR \u2192 cisco_xr JUNOS \u2192 juniper_junos LINUX \u2192 linux LINUX_OVS_OFCTL \u2192 linux NETSCALER \u2192 netscaler NXOS \u2192 cisco_nxos PAN_OS \u2192 paloalto_panos SRX \u2192 juniper_junos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-forward-networks-mapper","title":"Reverse Forward Networks Mapper","text":"NORMALIZED FORWARDNETWORKS arista_eos \u2192 ARISTA_EOS aruba_aoscx \u2192 ARUBA_SWITCH bigip_f5 \u2192 F5 cisco_asa \u2192 ASA cisco_ios \u2192 IOS cisco_nxos \u2192 NXOS cisco_xe \u2192 IOS cisco_xr \u2192 IOS_XR extreme_netiron \u2192 EXTREME_NOS fortinet \u2192 FORTINET juniper_junos \u2192 JUNOS linux \u2192 LINUX netscaler \u2192 NETSCALER paloalto_panos \u2192 PAN_OS"},{"location":"user/lib_use_cases_lib_mapper.html#hier-config-mapper","title":"Hier Config Mapper","text":"HIERCONFIG NORMALIZED eos \u2192 arista_eos fastiron \u2192 ruckus_fastiron ios \u2192 cisco_ios iosxe \u2192 cisco_ios iosxr \u2192 cisco_xr junos \u2192 juniper_junos nxos \u2192 cisco_nxos vyos \u2192 vyos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-hier-config-mapper","title":"Reverse Hier Config Mapper","text":"NORMALIZED HIERCONFIG arista_eos \u2192 eos cisco_ios \u2192 ios cisco_nxos \u2192 nxos cisco_xe \u2192 ios cisco_xr \u2192 iosxr juniper_junos \u2192 junos ruckus_fastiron \u2192 fastiron vyos \u2192 vyos"},{"location":"user/lib_use_cases_lib_mapper.html#napalm-mapper","title":"Napalm Mapper","text":"NAPALM NORMALIZED aoscx \u2192 aruba_aoscx asa \u2192 cisco_asa cisco_wlc_ssh \u2192 cisco_wlc eos \u2192 arista_eos f5 \u2192 bigip_f5 fortios \u2192 fortinet huawei_vrp \u2192 huawei ios \u2192 cisco_ios iosxr \u2192 cisco_xr junos \u2192 juniper_junos nxos \u2192 cisco_nxos nxos_ssh \u2192 cisco_nxos panos \u2192 paloalto_panos ros \u2192 mikrotik_routeros srl \u2192 nokia_srl sros \u2192 nokia_sros vyos \u2192 vyos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-napalm-mapper","title":"Reverse Napalm Mapper","text":"NORMALIZED NAPALM arista_eos \u2192 eos aruba_aoscx \u2192 aoscx bigip_f5 \u2192 f5 cisco_asa \u2192 asa cisco_ios \u2192 ios cisco_nxos \u2192 nxos cisco_wlc \u2192 cisco_wlc_ssh cisco_xe \u2192 ios cisco_xr \u2192 iosxr fortinet \u2192 fortios huawei \u2192 huawei_vrp juniper_junos \u2192 junos mikrotik_routeros \u2192 ros nokia_srl \u2192 srl nokia_sros \u2192 sros paloalto_panos \u2192 panos vyos \u2192 vyos"},{"location":"user/lib_use_cases_lib_mapper.html#netmiko-mapper","title":"Netmiko Mapper","text":"NETMIKO NORMALIZED a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc cisco_xe \u2192 cisco_xe cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing f5_linux \u2192 bigip_f5 f5_ltm \u2192 bigip_f5 f5_tmsh \u2192 bigip_f5 flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-netmiko-mapper","title":"Reverse Netmiko Mapper","text":"NORMALIZED NETMIKO a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc cisco_xe \u2192 cisco_xe cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_use_cases_lib_mapper.html#netutils-parser-mapper","title":"Netutils Parser Mapper","text":"NETUTILSPARSER NORMALIZED arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch bigip_f5 \u2192 bigip_f5 cisco_aireos \u2192 cisco_aireos cisco_asa \u2192 cisco_asa cisco_ios \u2192 cisco_ios cisco_iosxr \u2192 cisco_xr cisco_nxos \u2192 cisco_nxos citrix_netscaler \u2192 citrix_netscaler extreme_netiron \u2192 extreme_netiron fortinet_fortios \u2192 fortinet hp_comware \u2192 hp_comware juniper_junos \u2192 juniper_junos linux \u2192 linux mikrotik_routeros \u2192 mikrotik_routeros mrv_optiswitch \u2192 mrv_optiswitch netscaler \u2192 netscaler nokia_sros \u2192 nokia_sros nvidia_onyx \u2192 nvidia_onyx paloalto_panos \u2192 paloalto_panos rad_etx \u2192 rad_etx ruckus_fastiron \u2192 ruckus_fastiron ubiquiti_airos \u2192 ubiquiti_airos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-netutils-parser-mapper","title":"Reverse Netutils Parser Mapper","text":"NORMALIZED NETUTILSPARSER arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch bigip_f5 \u2192 bigip_f5 cisco_aireos \u2192 cisco_aireos cisco_asa \u2192 cisco_asa cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_xe \u2192 cisco_ios cisco_xr \u2192 cisco_iosxr citrix_netscaler \u2192 citrix_netscaler extreme_netiron \u2192 extreme_netiron fortinet \u2192 fortinet_fortios hp_comware \u2192 hp_comware juniper_junos \u2192 juniper_junos linux \u2192 linux mikrotik_routeros \u2192 mikrotik_routeros mrv_optiswitch \u2192 mrv_optiswitch netscaler \u2192 netscaler nokia_sros \u2192 nokia_sros nvidia_onyx \u2192 nvidia_onyx paloalto_panos \u2192 paloalto_panos rad_etx \u2192 rad_etx ruckus_fastiron \u2192 ruckus_fastiron ubiquiti_airos \u2192 ubiquiti_airos"},{"location":"user/lib_use_cases_lib_mapper.html#ntc-templates-mapper","title":"NTC Templates Mapper","text":"NTCTEMPLATES NORMALIZED a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc cisco_wlc_ssh \u2192 cisco_wlc cisco_xe \u2192 cisco_xe cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing f5_linux \u2192 bigip_f5 f5_ltm \u2192 bigip_f5 f5_tmsh \u2192 bigip_f5 flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrp \u2192 huawei_vrp huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vmware_nsxv \u2192 vmware_nsxv vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_firebox \u2192 watchguard_firebox watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-ntc-templates-mapper","title":"Reverse NTC Templates Mapper","text":"NORMALIZED NTCTEMPLATES a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc_ssh cisco_xe \u2192 cisco_ios cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrp \u2192 huawei_vrp huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vmware_nsxv \u2192 vmware_nsxv vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_firebox \u2192 watchguard_firebox watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_use_cases_lib_mapper.html#nist-mapper","title":"NIST Mapper","text":"NIST NORMALIZED arista:eos \u2192 arista_eos arubanetworks:arubaos \u2192 aruba_os cisco:adaptive_security_appliance_software \u2192 cisco_asa cisco:ios \u2192 cisco_ios cisco:ios_xe \u2192 cisco_xe cisco:ios_xr \u2192 cisco_xr cisco:nx-os \u2192 cisco_nxos juniper:junos \u2192 juniper_junos paloaltonetworks:pan-os \u2192 paloalto_panos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-nist-mapper","title":"Reverse NIST Mapper","text":"NORMALIZED NIST arista_eos \u2192 arista:eos aruba_os \u2192 arubanetworks:arubaos cisco_asa \u2192 cisco:adaptive_security_appliance_software cisco_ios \u2192 cisco:ios cisco_nxos \u2192 cisco:nx-os cisco_xe \u2192 cisco:ios_xe cisco_xr \u2192 cisco:ios_xr juniper_junos \u2192 juniper:junos paloalto_panos \u2192 paloaltonetworks:pan-os"},{"location":"user/lib_use_cases_lib_mapper.html#pyats-mapper","title":"PyATS Mapper","text":"PYATS NORMALIZED asa \u2192 cisco_asa bigip \u2192 bigip_f5 dnac \u2192 cisco_dnac ios \u2192 cisco_ios iosxe \u2192 cisco_ios iosxr \u2192 cisco_xr junos \u2192 juniper_junos linux \u2192 linux nxos \u2192 cisco_nxos sros \u2192 nokia_sros viptela \u2192 cisco_viptella"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-pyats-mapper","title":"Reverse PyATS Mapper","text":"NORMALIZED PYATS bigip_f5 \u2192 bigip cisco_asa \u2192 asa cisco_dnac \u2192 dnac cisco_ios \u2192 iosxe cisco_nxos \u2192 nxos cisco_viptella \u2192 viptela cisco_xe \u2192 iosxe cisco_xr \u2192 iosxr juniper_junos \u2192 junos linux \u2192 linux nokia_sros \u2192 sros"},{"location":"user/lib_use_cases_lib_mapper.html#pyntc-mapper","title":"PyNTC Mapper","text":"PYNTC NORMALIZED arista_eos_eapi \u2192 arista_eos cisco_aireos_ssh \u2192 cisco_wlc cisco_asa_ssh \u2192 cisco_asa cisco_ios_ssh \u2192 cisco_ios cisco_nxos_nxapi \u2192 cisco_nxos f5_tmos_icontrol \u2192 bigip_f5 juniper_junos_netconf \u2192 juniper_junos"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-pyntc-mapper","title":"Reverse PyNTC Mapper","text":"NORMALIZED PYNTC arista_eos \u2192 arista_eos_eapi bigip_f5 \u2192 f5_tmos_icontrol cisco_asa \u2192 cisco_asa_ssh cisco_ios \u2192 cisco_ios_ssh cisco_nxos \u2192 cisco_nxos_nxapi cisco_wlc \u2192 cisco_aireos_ssh cisco_xe \u2192 cisco_ios_ssh juniper_junos \u2192 juniper_junos_netconf"},{"location":"user/lib_use_cases_lib_mapper.html#scrapli-mapper","title":"Scrapli Mapper","text":"SCRAPLI NORMALIZED arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx cisco_iosxe \u2192 cisco_ios cisco_iosxr \u2192 cisco_xr cisco_nxos \u2192 cisco_nxos juniper_junos \u2192 juniper_junos nokia_srlinux \u2192 nokia_srl"},{"location":"user/lib_use_cases_lib_mapper.html#reverse-scrapli-mapper","title":"Reverse Scrapli Mapper","text":"NORMALIZED SCRAPLI arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx cisco_ios \u2192 cisco_iosxe cisco_nxos \u2192 cisco_nxos cisco_xe \u2192 cisco_iosxe cisco_xr \u2192 cisco_iosxr juniper_junos \u2192 juniper_junos nokia_srl \u2192 nokia_srlinux"},{"location":"user/lib_use_cases_nist.html","title":"NIST","text":"<p>The NIST utility is used for functionality based around NIST DB Queries, and is primarily used to create URLs for the API based queries.</p>"},{"location":"user/lib_use_cases_nist.html#requirements","title":"Requirements","text":"<p>In order to use the URLs generated by <code>netutils.nist.get_nist_urls*</code>, you will need an api key provided by NIST here.  This key will need to be passed in as an additional header in your request in the form of <code>{\"apiKey\": \"&lt;key_value&gt;\"}</code> as stated by NIST in their Getting Started section.</p>"},{"location":"user/lib_use_cases_nist.html#custom-urls","title":"Custom URLs","text":"<p>The largest caveat in this functionality is the consistency of the URL values needed to obtain the CVE information.  NIST NVD has specific parameters that can be used for standardization, however this does not mean that entries are standardized.  Manually combing through a large amount of CPE Vendor submissions has shown that there are variations in how CPE Vendor data is presented.</p> <p>For this reason, for certain Vendor/OS combinations, a custom URL needs to be built. - Cisco IOS CPE String - <code>cpe:2.3:o:cisco:ios:15.5\\\\(2\\\\)s1c:*</code>     - <code>15.5\\\\(2\\\\)s1c:*</code> - As seen here, Cisco uses CPE strings that do not include the <code>:</code> delimiter, which can be queried using escape characters in the search string.  This is the format of ALL \"generic\" OS/Other platforms that do not have their own custom NIST URL builder when querying NIST.     - Default URL Output - <code>'https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:o:cisco:ios:15.5\\\\(2\\\\)s1c:*'</code></p> <ul> <li>Juniper JunOS CPE String - <code>cpe:2.3:o:juniper:junos:10.2:r2:*:*:*:*:*:*</code> <ul> <li><code>10.2:r2:*:*:*:*:*:*</code> - As noted here, one of the provided URLs to query for this Juniper JunOS OS platform includes additional values that follow NIST delimiter structures.  In the case where the parser provides multiple URLs, they will both be evaluated and the CVE from both will be added and associated.</li> <li>Custom URL Output - <code>['https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:o:juniper:junos:10.2r2:*:*:*:*:*:*:*', 'https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:o:juniper:junos:10.2:r2:*:*:*:*:*:*']</code></li> </ul> </li> </ul>"},{"location":"user/lib_use_cases_nist.html#examples","title":"Examples","text":"<p>Here are a few examples showing how to use this in your python code.</p> <pre><code>from netutils.nist import get_nist_urls\n\n# Get NIST URL for the Cisco IOS object\nget_nist_urls(\"cisco_ios\", \"15.5(2)S1c\")\n# ['https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:o:cisco:ios:15.5\\\\(2\\\\)s1c:*']\n\n# Get NIST URL(s) for the Juniper JunOS object\nget_nist_urls(\"juniper_junos\", \"10.2R2.11\")\n# ['https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:o:juniper:junos:10.2r2:*:*:*:*:*:*:*', 'https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:o:juniper:junos:10.2:r2:*:*:*:*:*:*']\n</code></pre> <p>Currently known OS/Other Platform types that require a custom NIST URL:</p> <ul> <li>Juniper JunOS</li> </ul>"},{"location":"user/lib_use_cases_os_version.html","title":"OS Version Tools","text":"<p>The OS Version Tools are used for working with versioning systems.</p>"},{"location":"user/lib_use_cases_os_version.html#version-parsingdeconstruction","title":"Version Parsing/Deconstruction","text":"<p>Version parsing takes the software version given as a string, and deconstructs that value into the standards of the vendor.  The version parsing takes place in the <code>netutils.os_version</code> module.  This is necessary when specific values or flags from a software version are required to make a logical decision.  </p> <p>Current Version Parsers:</p> <ul> <li>Default Parser</li> <li>Juniper JunOS</li> </ul> <p>See the following Default and Juniper JunOS parsed versions:</p> <pre><code>&gt;&gt;&gt; from netutils.os_version import version_metadata\n\n&gt;&gt;&gt; version_metadata(\"Cisco\", \"IOS\", \"15.5\")\n{\n    \"major\": \"15\",\n    \"minor\": \"5\",\n    \"vendor_metadata\": False,\n}\n&gt;&gt;&gt; version_metadata(\"juniper\", \"junos\", \"12.4R\")\n{\n    \"isservice\": False,\n    \"ismaintenance\": False,\n    \"isfrs\": True,\n    \"isspecial\": False,\n    \"service\": None,\n    \"service_build\": None,\n    \"service_respin\": None,\n    \"main\": \"12\",\n    \"minor\": \"4\",\n    \"type\": \"R\",\n    \"build\": None,\n    \"major\": \"12\",\n    \"patch\": None,\n    \"vendor_metadata\": True,\n}\n</code></pre>"},{"location":"user/lib_use_cases_protocol_mappers.html","title":"Protocol Mappers","text":"<p>These protocol mappers can be used when you have either the application protocol name or number but need the corresponding value. Something to note is that these mappings are divided up per IP protocol. The reasoning behind this is that the same port number could be tied to two different application protocols depending on the underlying IP protocol. For example, when using UDP, port 13400 is the application protocol <code>doip-disc</code>. Looking at the same port using TCP the application protocol is <code>doip-data</code>.</p> <p>Here are currently available mappers:</p> <ul> <li> <p>DCCP_NAME_TO_NUM - Allows mapping from a known DCCP application protocol name to DCCP application protocol number.</p> </li> <li> <p>DCCP_NUM_TO_NAME - Allows mapping from a known DCCP application protocol name to DCCP application protocol number.</p> </li> <li> <p>PROTO_NAME_TO_NUM - Allows mapping from a known IP protocol name to IP protocol number.</p> </li> <li> <p>PROTO_NUM_TO_NAME - Allows mapping from a known IP protocol number to IP protocol name.</p> </li> <li> <p>SCTP_NAME_TO_NUM -  Allows mapping from a known SCTP application protocol name to SCTP application protocol number.</p> </li> <li> <p>SCTP_NUM_TO_NAME - Allows mapping from a known SCTP application protocol number to SCTP application protocol name.</p> </li> <li> <p>TCP_NAME_TO_NUM - Allows mapping from a known TCP application protocol name to TCP application protocol number.</p> </li> <li> <p>TCP_NUM_TO_NAME - Allows mapping from a known TCP application protocol number to TCP application protocol name.</p> </li> <li> <p>UDP_NAME_TO_NUM - Allows mapping from a known UDP application protocol name to UDP application protocol number.</p> </li> <li> <p>UDP_NUM_TO_NAME - Allows mapping from a known UDP application protocol number to UDP application protocol name.</p> </li> </ul> <p>Here are a few examples showing how you would use these in your python code.</p> <pre><code>from netutils.protocol_mapper import (\n\n    PROTO_NAME_TO_NUM,\n    PROTO_NUM_TO_NAME,\n    TCP_NAME_TO_NUM,\n    TCP_NUM_TO_NAME,\n    UDP_NAME_TO_NUM,\n    UDP_NUM_TO_NAME,\n    SCTP_NAME_TO_NUM,\n    SCTP_NUM_TO_NAME,\n    DCCP_NAME_TO_NUM,\n    DCCP_NUM_TO_NAME,\n)\n\n# Get DCCP protocol port from known DCCP application name\nLTP_DEEPSPACE_PORT = DCCP_NAME_TO_NUM(\"ltp-deepspace\")\nprint(LTP_DEEPSPACE_PORT)\n# 1113\n\n# Get TCP protocol port from known TCP application name\nSSH_PORT = TCP_NAME_TO_NUM[\"ssh\"]\nprint(SSH_PORT)\n# 22\n\n# Get SCTP protocol name from known SCTP application port.\nSCTP_PORT_1021_APPLICATION_NAME = SCTP_NUM_TO_NAME[1021]\nprint(SCTP_PORT_1021_APPLICATION_NAME)\n# \"exp1\"\n\n# Get UDP protocol name from known UDP application port\nUDP_PORT_20_APPLICATION_NAME = UDP_NUM_TO_NAME[20]\nprint(UDP_PORT_20_APPLICATION_NAME)\n# \"ftp-data\n</code></pre>"},{"location":"user/lib_use_cases_protocol_mappers.html#handling-of-duplicate-services","title":"Handling of Duplicate Services","text":"<p>The ports are defined by iana and generated via an autogenerated process, however, there is not a strict name to number mapping provided by iana. Often names are duplicated across multiple port numbers. </p> <p>Take the below example.</p> Service Name Port Number Transport Protocol Description compressnet 2 tcp Management Utility compressnet 2 udp Management Utility compressnet 3 tcp Compression Process compressnet 3 udp Compression Process <p>As you can see, the service name and port combination is not unique. As such, on the second one, a <code>-secondary</code> is appended to the name to accommodate. The resulting structure looks something like:</p> <pre><code>    \"compressnet\": {\"port_number\": 2, \"protocols\": [\"tcp\", \"udp\"]},\n    \"compressnet-secondary\": {\"port_number\": 3, \"protocols\": [\"tcp\", \"udp\"]},\n</code></pre> <p>This behavior is to be expected.</p>"},{"location":"user/lib_mapper/aerleon.html","title":"Aerleon","text":"AERLEON NORMALIZED arista \u2192 arista_eos aruba \u2192 aruba_aoscx brocade \u2192 brocade_nos cisco \u2192 cisco_ios ciscoasa \u2192 cisco_asa cisconx \u2192 cisco_nxos ciscoxr \u2192 cisco_xr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper \u2192 juniper_junos juniperevo \u2192 juniper_junos k8s \u2192 k8s msmpc \u2192 juniper_junos nsxt \u2192 vmware_nsxt nsxv \u2192 vmware_nsxv openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto \u2192 paloalto_panos pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway srx \u2192 juniper_junos srxlo \u2192 juniper_junos windows \u2192 windows windows_advfirewall \u2192 windows"},{"location":"user/lib_mapper/aerleon_reverse.html","title":"Aerleon reverse","text":"NORMALIZED AERLEON arista_eos \u2192 arista aruba_aoscx \u2192 aruba brocade_nos \u2192 brocade cisco_asa \u2192 ciscoasa cisco_ios \u2192 cisco cisco_nxos \u2192 cisconx cisco_xe \u2192 cisco cisco_xr \u2192 ciscoxr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper_junos \u2192 juniper k8s \u2192 k8s openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto_panos \u2192 paloalto pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway vmware_nsxt \u2192 nsxt vmware_nsxv \u2192 nsxv windows \u2192 windows"},{"location":"user/lib_mapper/ansible.html","title":"Ansible","text":"ANSIBLE NORMALIZED a10.acos_axapi.a10 \u2192 a10 arista.eos.eos \u2192 arista_eos arubanetworks.aoscx \u2192 aruba_aoscx ciena.saos6.saos6 \u2192 ciena_saos cisco.asa.asa \u2192 cisco_asa cisco.ios.ios \u2192 cisco_ios cisco.iosxr.iosxr \u2192 cisco_xr cisco.meraki.meraki \u2192 cisco_meraki cisco.nxos.nxos \u2192 cisco_nxos community.network.ce \u2192 huawei community.network.cnos \u2192 lenovo_cnos community.network.enos \u2192 lenovo_enos community.network.eric_eccli \u2192 ericsson_ipos community.network.exos \u2192 extreme_exos community.network.icx \u2192 ruckus_icx community.network.ironware \u2192 extreme_netiron community.network.netvisor \u2192 pluribus community.network.nos \u2192 extreme_nos community.network.routeros \u2192 mikrotik_routeros community.network.slxos \u2192 extreme_slx community.network.sros \u2192 nokia_sros community.network.voss \u2192 extreme_vsp dellemc.enterprise_sonic.sonic \u2192 sonic dellemc.os10.0s10 \u2192 dell_os10 dellemc.os6.os6 \u2192 dell_os6 dellemc.os9.os9 \u2192 dell_os9 f5networks.f5_bigip.bigip \u2192 bigip_f5 fortinet.fortios.fortios \u2192 fortinet junipernetworks.junos.junos \u2192 juniper_junos nokia.srl \u2192 nokia_srl paloaltonetworks.panos.panos \u2192 paloalto_panos vyos.vyos.vyos \u2192 vyos"},{"location":"user/lib_mapper/ansible_reverse.html","title":"Ansible reverse","text":"NORMALIZED ANSIBLE a10 \u2192 a10.acos_axapi.a10 arista_eos \u2192 arista.eos.eos aruba_aoscx \u2192 arubanetworks.aoscx bigip_f5 \u2192 f5networks.f5_bigip.bigip ciena_saos \u2192 ciena.saos6.saos6 cisco_asa \u2192 cisco.asa.asa cisco_ios \u2192 cisco.ios.ios cisco_meraki \u2192 cisco.meraki.meraki cisco_nxos \u2192 cisco.nxos.nxos cisco_xe \u2192 cisco.ios.ios cisco_xr \u2192 cisco.iosxr.iosxr dell_os10 \u2192 dellemc.os10.0s10 dell_os6 \u2192 dellemc.os6.os6 dell_os9 \u2192 dellemc.os9.os9 ericsson_ipos \u2192 community.network.eric_eccli extreme_exos \u2192 community.network.exos extreme_netiron \u2192 community.network.ironware extreme_nos \u2192 community.network.nos extreme_slx \u2192 community.network.slxos extreme_vsp \u2192 community.network.voss fortinet \u2192 fortinet.fortios.fortios huawei \u2192 community.network.ce juniper_junos \u2192 junipernetworks.junos.junos lenovo_cnos \u2192 community.network.cnos lenovo_enos \u2192 community.network.enos mikrotik_routeros \u2192 community.network.routeros nokia_srl \u2192 nokia.srl nokia_sros \u2192 community.network.sros paloalto_panos \u2192 paloaltonetworks.panos.panos pluribus \u2192 community.network.netvisor ruckus_icx \u2192 community.network.icx sonic \u2192 dellemc.enterprise_sonic.sonic vyos \u2192 vyos.vyos.vyos"},{"location":"user/lib_mapper/capirca.html","title":"Capirca","text":"CAPIRCA NORMALIZED arista \u2192 arista_eos aruba \u2192 aruba_aoscx brocade \u2192 brocade_nos cisco \u2192 cisco_ios ciscoasa \u2192 cisco_asa cisconx \u2192 cisco_nxos ciscoxr \u2192 cisco_xr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper \u2192 juniper_junos juniperevo \u2192 juniper_junos k8s \u2192 k8s msmpc \u2192 juniper_junos nsxt \u2192 vmware_nsxt nsxv \u2192 vmware_nsxv openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto \u2192 paloalto_panos pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway srx \u2192 juniper_junos srxlo \u2192 juniper_junos windows \u2192 windows windows_advfirewall \u2192 windows"},{"location":"user/lib_mapper/capirca_reverse.html","title":"Capirca reverse","text":"NORMALIZED CAPIRCA arista_eos \u2192 arista aruba_aoscx \u2192 aruba brocade_nos \u2192 brocade cisco_asa \u2192 ciscoasa cisco_ios \u2192 cisco cisco_nxos \u2192 cisconx cisco_xe \u2192 cisco cisco_xr \u2192 ciscoxr cloudarmor \u2192 cloudarmor gce \u2192 gce gcp_hf \u2192 gcp_hf ipset \u2192 ipset iptables \u2192 iptables juniper_junos \u2192 juniper k8s \u2192 k8s openconfig \u2192 openconfig packetfilter \u2192 packetfilter paloalto_panos \u2192 paloalto pcap \u2192 pcap sonic \u2192 sonic speedway \u2192 speedway vmware_nsxt \u2192 nsxt vmware_nsxv \u2192 nsxv windows \u2192 windows"},{"location":"user/lib_mapper/dna_center.html","title":"Dna center","text":"DNA_CENTER NORMALIZED IOS \u2192 cisco_ios IOS-XE \u2192 cisco_ios IOS-XR \u2192 cisco_xr NX-OS \u2192 cisco_nxos"},{"location":"user/lib_mapper/dna_center_reverse.html","title":"Dna center reverse","text":"NORMALIZED DNA_CENTER cisco_ios \u2192 IOS cisco_nxos \u2192 NX-OS cisco_xr \u2192 IOS-XR"},{"location":"user/lib_mapper/forwardnetworks.html","title":"Forwardnetworks","text":"FORWARDNETWORKS NORMALIZED ARISTA_EOS \u2192 arista_eos ARUBA_SWITCH \u2192 aruba_aoscx ASA \u2192 cisco_asa EXTREME_NOS \u2192 extreme_netiron F5 \u2192 bigip_f5 FORTINET \u2192 fortinet IOS \u2192 cisco_ios IOS_XE \u2192 cisco_ios IOS_XR \u2192 cisco_xr JUNOS \u2192 juniper_junos LINUX \u2192 linux LINUX_OVS_OFCTL \u2192 linux NETSCALER \u2192 netscaler NXOS \u2192 cisco_nxos PAN_OS \u2192 paloalto_panos SRX \u2192 juniper_junos"},{"location":"user/lib_mapper/forwardnetworks_reverse.html","title":"Forwardnetworks reverse","text":"NORMALIZED FORWARDNETWORKS arista_eos \u2192 ARISTA_EOS aruba_aoscx \u2192 ARUBA_SWITCH bigip_f5 \u2192 F5 cisco_asa \u2192 ASA cisco_ios \u2192 IOS cisco_nxos \u2192 NXOS cisco_xe \u2192 IOS cisco_xr \u2192 IOS_XR extreme_netiron \u2192 EXTREME_NOS fortinet \u2192 FORTINET juniper_junos \u2192 JUNOS linux \u2192 LINUX netscaler \u2192 NETSCALER paloalto_panos \u2192 PAN_OS"},{"location":"user/lib_mapper/hierconfig.html","title":"Hierconfig","text":"HIERCONFIG NORMALIZED eos \u2192 arista_eos fastiron \u2192 ruckus_fastiron ios \u2192 cisco_ios iosxe \u2192 cisco_ios iosxr \u2192 cisco_xr junos \u2192 juniper_junos nxos \u2192 cisco_nxos vyos \u2192 vyos"},{"location":"user/lib_mapper/hierconfig_reverse.html","title":"Hierconfig reverse","text":"NORMALIZED HIERCONFIG arista_eos \u2192 eos cisco_ios \u2192 ios cisco_nxos \u2192 nxos cisco_xe \u2192 ios cisco_xr \u2192 iosxr juniper_junos \u2192 junos ruckus_fastiron \u2192 fastiron vyos \u2192 vyos"},{"location":"user/lib_mapper/napalm.html","title":"Napalm","text":"NAPALM NORMALIZED aoscx \u2192 aruba_aoscx asa \u2192 cisco_asa cisco_wlc_ssh \u2192 cisco_wlc eos \u2192 arista_eos f5 \u2192 bigip_f5 fortios \u2192 fortinet huawei_vrp \u2192 huawei ios \u2192 cisco_ios iosxr \u2192 cisco_xr junos \u2192 juniper_junos nxos \u2192 cisco_nxos nxos_ssh \u2192 cisco_nxos panos \u2192 paloalto_panos ros \u2192 mikrotik_routeros srl \u2192 nokia_srl sros \u2192 nokia_sros vyos \u2192 vyos"},{"location":"user/lib_mapper/napalm_reverse.html","title":"Napalm reverse","text":"NORMALIZED NAPALM arista_eos \u2192 eos aruba_aoscx \u2192 aoscx bigip_f5 \u2192 f5 cisco_asa \u2192 asa cisco_ios \u2192 ios cisco_nxos \u2192 nxos cisco_wlc \u2192 cisco_wlc_ssh cisco_xe \u2192 ios cisco_xr \u2192 iosxr fortinet \u2192 fortios huawei \u2192 huawei_vrp juniper_junos \u2192 junos mikrotik_routeros \u2192 ros nokia_srl \u2192 srl nokia_sros \u2192 sros paloalto_panos \u2192 panos vyos \u2192 vyos"},{"location":"user/lib_mapper/netmiko.html","title":"Netmiko","text":"NETMIKO NORMALIZED a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc cisco_xe \u2192 cisco_xe cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing f5_linux \u2192 bigip_f5 f5_ltm \u2192 bigip_f5 f5_tmsh \u2192 bigip_f5 flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_mapper/netmiko_reverse.html","title":"Netmiko reverse","text":"NORMALIZED NETMIKO a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc cisco_xe \u2192 cisco_xe cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_mapper/netutilsparser.html","title":"Netutilsparser","text":"NETUTILSPARSER NORMALIZED arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch bigip_f5 \u2192 bigip_f5 cisco_aireos \u2192 cisco_aireos cisco_asa \u2192 cisco_asa cisco_ios \u2192 cisco_ios cisco_iosxr \u2192 cisco_xr cisco_nxos \u2192 cisco_nxos citrix_netscaler \u2192 citrix_netscaler extreme_netiron \u2192 extreme_netiron fortinet_fortios \u2192 fortinet hp_comware \u2192 hp_comware juniper_junos \u2192 juniper_junos linux \u2192 linux mikrotik_routeros \u2192 mikrotik_routeros mrv_optiswitch \u2192 mrv_optiswitch netscaler \u2192 netscaler nokia_sros \u2192 nokia_sros nvidia_onyx \u2192 nvidia_onyx paloalto_panos \u2192 paloalto_panos rad_etx \u2192 rad_etx ruckus_fastiron \u2192 ruckus_fastiron ubiquiti_airos \u2192 ubiquiti_airos"},{"location":"user/lib_mapper/netutilsparser_reverse.html","title":"Netutilsparser reverse","text":"NORMALIZED NETUTILSPARSER arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch bigip_f5 \u2192 bigip_f5 cisco_aireos \u2192 cisco_aireos cisco_asa \u2192 cisco_asa cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_xe \u2192 cisco_ios cisco_xr \u2192 cisco_iosxr citrix_netscaler \u2192 citrix_netscaler extreme_netiron \u2192 extreme_netiron fortinet \u2192 fortinet_fortios hp_comware \u2192 hp_comware juniper_junos \u2192 juniper_junos linux \u2192 linux mikrotik_routeros \u2192 mikrotik_routeros mrv_optiswitch \u2192 mrv_optiswitch netscaler \u2192 netscaler nokia_sros \u2192 nokia_sros nvidia_onyx \u2192 nvidia_onyx paloalto_panos \u2192 paloalto_panos rad_etx \u2192 rad_etx ruckus_fastiron \u2192 ruckus_fastiron ubiquiti_airos \u2192 ubiquiti_airos"},{"location":"user/lib_mapper/nist.html","title":"Nist","text":"NIST NORMALIZED arista:eos \u2192 arista_eos arubanetworks:arubaos \u2192 aruba_os cisco:adaptive_security_appliance_software \u2192 cisco_asa cisco:ios \u2192 cisco_ios cisco:ios_xe \u2192 cisco_xe cisco:ios_xr \u2192 cisco_xr cisco:nx-os \u2192 cisco_nxos juniper:junos \u2192 juniper_junos paloaltonetworks:pan-os \u2192 paloalto_panos"},{"location":"user/lib_mapper/nist_reverse.html","title":"Nist reverse","text":"NORMALIZED NIST arista_eos \u2192 arista:eos aruba_os \u2192 arubanetworks:arubaos cisco_asa \u2192 cisco:adaptive_security_appliance_software cisco_ios \u2192 cisco:ios cisco_nxos \u2192 cisco:nx-os cisco_xe \u2192 cisco:ios_xe cisco_xr \u2192 cisco:ios_xr juniper_junos \u2192 juniper:junos paloalto_panos \u2192 paloaltonetworks:pan-os"},{"location":"user/lib_mapper/ntctemplates.html","title":"Ntctemplates","text":"NTCTEMPLATES NORMALIZED a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc cisco_wlc_ssh \u2192 cisco_wlc cisco_xe \u2192 cisco_xe cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing f5_linux \u2192 bigip_f5 f5_ltm \u2192 bigip_f5 f5_tmsh \u2192 bigip_f5 flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrp \u2192 huawei_vrp huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vmware_nsxv \u2192 vmware_nsxv vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_firebox \u2192 watchguard_firebox watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_mapper/ntctemplates_reverse.html","title":"Ntctemplates reverse","text":"NORMALIZED NTCTEMPLATES a10 \u2192 a10 accedian \u2192 accedian adtran_os \u2192 adtran_os alcatel_aos \u2192 alcatel_aos alcatel_sros \u2192 alcatel_sros allied_telesis_awplus \u2192 allied_telesis_awplus apresia_aeos \u2192 apresia_aeos arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx aruba_os \u2192 aruba_os aruba_osswitch \u2192 aruba_osswitch aruba_procurve \u2192 aruba_procurve avaya_ers \u2192 avaya_ers avaya_vsp \u2192 avaya_vsp bigip_f5 \u2192 bigip_f5 broadcom_icos \u2192 broadcom_icos brocade_fastiron \u2192 brocade_fastiron brocade_fos \u2192 brocade_fos brocade_netiron \u2192 brocade_netiron brocade_nos \u2192 brocade_nos brocade_vdx \u2192 brocade_vdx brocade_vyos \u2192 brocade_vyos calix_b6 \u2192 calix_b6 centec_os \u2192 centec_os checkpoint_gaia \u2192 checkpoint_gaia ciena_saos \u2192 ciena_saos cisco_asa \u2192 cisco_asa cisco_ftd \u2192 cisco_ftd cisco_ios \u2192 cisco_ios cisco_nxos \u2192 cisco_nxos cisco_s300 \u2192 cisco_s300 cisco_tp \u2192 cisco_tp cisco_wlc \u2192 cisco_wlc_ssh cisco_xe \u2192 cisco_ios cisco_xr \u2192 cisco_xr cloudgenix_ion \u2192 cloudgenix_ion coriant \u2192 coriant dell_dnos9 \u2192 dell_dnos9 dell_force10 \u2192 dell_force10 dell_isilon \u2192 dell_isilon dell_os10 \u2192 dell_os10 dell_os6 \u2192 dell_os6 dell_os9 \u2192 dell_os9 dell_powerconnect \u2192 dell_powerconnect dlink_ds \u2192 dlink_ds eltex \u2192 eltex eltex_esr \u2192 eltex_esr endace \u2192 endace enterasys \u2192 enterasys ericsson_ipos \u2192 ericsson_ipos extreme \u2192 extreme extreme_ers \u2192 extreme_ers extreme_exos \u2192 extreme_exos extreme_netiron \u2192 extreme_netiron extreme_nos \u2192 extreme_nos extreme_slx \u2192 extreme_slx extreme_vdx \u2192 extreme_vdx extreme_vsp \u2192 extreme_vsp extreme_wing \u2192 extreme_wing flexvnf \u2192 flexvnf fortinet \u2192 fortinet generic \u2192 generic generic_termserver \u2192 generic_termserver hp_comware \u2192 hp_comware hp_procurve \u2192 hp_procurve huawei \u2192 huawei huawei_olt \u2192 huawei_olt huawei_smartax \u2192 huawei_smartax huawei_vrp \u2192 huawei_vrp huawei_vrpv8 \u2192 huawei_vrpv8 ipinfusion_ocnos \u2192 ipinfusion_ocnos juniper \u2192 juniper juniper_junos \u2192 juniper_junos juniper_screenos \u2192 juniper_screenos keymile \u2192 keymile keymile_nos \u2192 keymile_nos linux \u2192 linux mellanox \u2192 mellanox mellanox_mlnxos \u2192 mellanox_mlnxos mikrotik_routeros \u2192 mikrotik_routeros mikrotik_switchos \u2192 mikrotik_switchos mrv_lx \u2192 mrv_lx mrv_optiswitch \u2192 mrv_optiswitch netapp_cdot \u2192 netapp_cdot netgear_prosafe \u2192 netgear_prosafe netscaler \u2192 netscaler nokia_srl \u2192 nokia_srl nokia_sros \u2192 nokia_sros oneaccess_oneos \u2192 oneaccess_oneos ovs_linux \u2192 ovs_linux paloalto_panos \u2192 paloalto_panos pluribus \u2192 pluribus quanta_mesh \u2192 quanta_mesh rad_etx \u2192 rad_etx raisecom_roap \u2192 raisecom_roap ruckus_fastiron \u2192 ruckus_fastiron ruijie_os \u2192 ruijie_os sixwind_os \u2192 sixwind_os sophos_sfos \u2192 sophos_sfos tplink_jetstream \u2192 tplink_jetstream ubiquiti_edge \u2192 ubiquiti_edge ubiquiti_edgerouter \u2192 ubiquiti_edgerouter ubiquiti_edgeswitch \u2192 ubiquiti_edgeswitch ubiquiti_unifiswitch \u2192 ubiquiti_unifiswitch vmware_nsxv \u2192 vmware_nsxv vyatta_vyos \u2192 vyatta_vyos vyos \u2192 vyos watchguard_firebox \u2192 watchguard_firebox watchguard_fireware \u2192 watchguard_fireware yamaha \u2192 yamaha zte_zxros \u2192 zte_zxros"},{"location":"user/lib_mapper/pyats.html","title":"Pyats","text":"PYATS NORMALIZED asa \u2192 cisco_asa bigip \u2192 bigip_f5 dnac \u2192 cisco_dnac ios \u2192 cisco_ios iosxe \u2192 cisco_ios iosxr \u2192 cisco_xr junos \u2192 juniper_junos linux \u2192 linux nxos \u2192 cisco_nxos sros \u2192 nokia_sros viptela \u2192 cisco_viptella"},{"location":"user/lib_mapper/pyats_reverse.html","title":"Pyats reverse","text":"NORMALIZED PYATS bigip_f5 \u2192 bigip cisco_asa \u2192 asa cisco_dnac \u2192 dnac cisco_ios \u2192 iosxe cisco_nxos \u2192 nxos cisco_viptella \u2192 viptela cisco_xe \u2192 iosxe cisco_xr \u2192 iosxr juniper_junos \u2192 junos linux \u2192 linux nokia_sros \u2192 sros"},{"location":"user/lib_mapper/pyntc.html","title":"Pyntc","text":"PYNTC NORMALIZED arista_eos_eapi \u2192 arista_eos cisco_aireos_ssh \u2192 cisco_wlc cisco_asa_ssh \u2192 cisco_asa cisco_ios_ssh \u2192 cisco_ios cisco_nxos_nxapi \u2192 cisco_nxos f5_tmos_icontrol \u2192 bigip_f5 juniper_junos_netconf \u2192 juniper_junos"},{"location":"user/lib_mapper/pyntc_reverse.html","title":"Pyntc reverse","text":"NORMALIZED PYNTC arista_eos \u2192 arista_eos_eapi bigip_f5 \u2192 f5_tmos_icontrol cisco_asa \u2192 cisco_asa_ssh cisco_ios \u2192 cisco_ios_ssh cisco_nxos \u2192 cisco_nxos_nxapi cisco_wlc \u2192 cisco_aireos_ssh cisco_xe \u2192 cisco_ios_ssh juniper_junos \u2192 juniper_junos_netconf"},{"location":"user/lib_mapper/running_config.html","title":"Running config","text":"NORMALIZED RUNNING_CONFIG_COMMAND arista_eos \u2192 show running-config aruba_os \u2192 show running-configuration aruba_osswitch \u2192 show running-config aruba_procurve \u2192 show running-config checkpoint_gaia \u2192 clish -c \"show configuration\" cisco_ios \u2192 show running-config cisco_nxos \u2192 show running-config cisco_wlc \u2192 show run-config commands cisco_xr \u2192 show running-config dell_os10 \u2192 show running-config dell_os9 \u2192 show running-config extreme_exos \u2192 show configuration extreme_slx \u2192 show running-config extreme_vsp \u2192 show running-config fortinet \u2192 show full-configuration hp_procurve \u2192 show running-config juniper_junos \u2192 show configuration mikrotik_routeros \u2192 /export nokia_srl \u2192 info nokia_sros \u2192 admin display-config rad_etx \u2192 info ruckus_fastiron \u2192 show running-config ubiquiti_edge \u2192 show configuration ubiquiti_edgerouter \u2192 show configuration ubiquiti_edgeswitch \u2192 show configuration vyos \u2192 show configuration"},{"location":"user/lib_mapper/scrapli.html","title":"Scrapli","text":"SCRAPLI NORMALIZED arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx cisco_iosxe \u2192 cisco_ios cisco_iosxr \u2192 cisco_xr cisco_nxos \u2192 cisco_nxos juniper_junos \u2192 juniper_junos nokia_srlinux \u2192 nokia_srl"},{"location":"user/lib_mapper/scrapli_reverse.html","title":"Scrapli reverse","text":"NORMALIZED SCRAPLI arista_eos \u2192 arista_eos aruba_aoscx \u2192 aruba_aoscx cisco_ios \u2192 cisco_iosxe cisco_nxos \u2192 cisco_nxos cisco_xe \u2192 cisco_iosxe cisco_xr \u2192 cisco_iosxr juniper_junos \u2192 juniper_junos nokia_srl \u2192 nokia_srlinux"}]}